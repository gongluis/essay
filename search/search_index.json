{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to LuisDocs 本模块介绍 词 一盏离愁孤单伫立在窗口，我在门后假装你人还没走。 旧地如重游，月圆更寂寞。 夜半清醒的烛火不忍苛责我。 一壶漂泊 浪迹天涯难入喉 你走之后 酒暖回忆思念瘦 水向东流 时间怎么偷 花开就一次成熟我却错过 -jay chou 2. 曲3 本模块说明 一路向北 听爸爸的话 本模块声明 hi hello","text_tokens":["没","之后","假装","hello","2","怎么","一壶","后","更","向东","一路","瘦","还","清醒","如","luisdocs","听","声明","。","向北","错过","月","寂寞","不忍","走","-","爸爸",".","浪迹","的话","一次","思念","烛火","孤单","本","我","夜半","酒暖","伫立","人","东流","苛责","偷","的","花开","介绍","chou","在","一盏","向东流","门","welcome","回忆","漂泊","hi","曲","，","你","to","喉","词","浪迹天涯","重游"," ","离愁","时间","窗口","却","水","jay","圆","难入","旧地","天涯","就","说明","成熟","3","模块"],"title":"一、介绍","title_tokens":["介绍","一","、"]},{"location":"#welcome-to-luisdocs","text":"","text_tokens":[],"title":"Welcome to LuisDocs","title_tokens":[" ","welcome","to","luisdocs"]},{"location":"#_1","text":"词 一盏离愁孤单伫立在窗口，我在门后假装你人还没走。 旧地如重游，月圆更寂寞。 夜半清醒的烛火不忍苛责我。 一壶漂泊 浪迹天涯难入喉 你走之后 酒暖回忆思念瘦 水向东流 时间怎么偷 花开就一次成熟我却错过 -jay chou 2. 曲3","text_tokens":["。","酒暖","伫立","错过","人","没"," ","东流","苛责","假装","之后","偷","2","离愁","月","时间","的","怎么","寂寞","花开","不忍","走","chou","在","窗口","一壶","一盏","向东流","却","水","门","后","-","jay","圆","难入","旧地","更","天涯",".","就","浪迹","回忆","一次","漂泊","向东","瘦","曲","还","，","你","孤单","烛火","思念","清醒","成熟","如","喉","词","3","浪迹天涯","重游","我","夜半"],"title":"本模块介绍","title_tokens":["本","介绍","模块"]},{"location":"#_2","text":"一路向北 听爸爸的话","text_tokens":["爸爸","向北","的话"," ","一路","听"],"title":"本模块说明","title_tokens":["本","模块","说明"]},{"location":"#_3","text":"hi hello","text_tokens":[" ","hi","hello"],"title":"本模块声明","title_tokens":["本","模块","声明"]},{"location":"SmartPos/","text":"SmartPos 项目依赖关系图 激活模块 build.gradle里面的depandence中 implementation project(':PosSDK') implementation project(':jbig-kit') implementation project(':kprogresshud') MyApplication中初始化 CILSDK.setCILAppVersion(); CILSDK.setDebug(BuildConfig.DEBUG); CILSDK.setAddress(BuildConfig.ADDRESS); CILSDK.connect(this); 如果还适配了联迪A8，login需要传入activity的context建议在每个可能调用设备刷卡，加密，打印的actiivty调用CILSDK.connect()保证使用过程中设备连接不断开推荐使用activitylifecyclerCallbacks. SplashActivity 设置了activity的进入动画。 下方设置了版本号+背景颜色表示不同环境。 跑了一个handler(根据是否激活和是否下载参数来进入MainActivity还是ActivateActivity)。 ActivateActivity 两种激活方式 扫二维码 输入商户号和终端号（要求在服务平台手动录入sn号） 两种方式的区别：扫二维码比手输多了个去服务平台请求商户号和终端号的接口 激活的过程（服务平台） 扫二维码：读码成功立马调用getMerchantInfo获取商户信息，点击激活按钮调用activeDevice接口（接口内部调用了downloadParameters终端参数下载接口+notifyActive激活完成） 输入商户号和终端号：active+loadparameters ACTIVE:服务平台激活 LOADPARAMETERS:下载交易需要的相关信息；交易Ip和端口，币种，超时时间，权限，报文加密标志位。 MainActivity 检查APP版本 jobScheldure 后台服务进行下载apk 终端密钥下载 下载RSA->装载RSA->下载主密钥->装载主密钥->启用主密钥->下载工作密钥->装载工作密钥->下载aids->装载aids->下载ICPKS->装载ICPKS 签到（更新工作密钥（下载+装载工作密钥）的过程）网关平台要求应用每天签到一次 CILSDK.signIn() 6.交易 扫码交易 先检查本地缓存的币种与交易报文的币种是否一致 check transe currency 不一致--->结算 一致，继续 最小交易金额Math.pow(10,-2) 0.01 根据交易币种小数位来确定 银行卡交易 api 收单服务平台 getMerName 终端注册码获取商户信息接口 ActiveActivity的onActivityResult中调用 sdk中调用 active 获取Authentication Token接口 旧版本激活方式使用的是devicetoken(推送模块生成) activeCode 新激活接口，使用激活码 激活码方式激活使用的是sn，token传的null graph TD; A-->B; A-->C; B-->D; C-->D; sdk功能点整理 激活模块（在录入终端的时候需要选择方式） app~收单服务平台 1. 传统输入商户号和终端号的方式激活（重置的方法是清空sn号然后点击确定） * 调用sdk激活接口 CILSDK.active(merCode, termCode, callback); * 接口调用成功后立马调用终端参数下载接口下载交易时使用的参数 CILSDK.downloadParam(mer,term,callback); * 跳转到MainActivity onCreat的时候调用终端密钥下载接口 CILSDK.downloadParamWithProgress(callback); 汇总： 1.sp的抽取   传入三个参数put(Context context,String str,Object   object),根据object的类型，选择putString还是putInt。。。get(...)同上 2.KProgressHUD github上第三方包直接引用源代码 3.抽取CILlog类，只有在debug模式下才输出日志，另使用sd记录一些错误日志 4.存储sn（会率先使用A没有后然后使用B）   A.virtualSN：使用激活码激活成功后，服务平台会返回sn，存储到sp   B.REAL_SN：a8,联迪。。。在设备连接的时候会获取一个REAL_SN 5.devicetoken   推送平台使用的设备唯一标识识别，可以通过推送服务的注册获得   旧版本激活前如果devicetoken为空，会尝试进行重新注册一次来获取devicetoken,如果依然为空，传 \"\" 6.versionname   2.4.0：20190527：SDK 7.激活同步、异步-------->是否使用RXjava进行切换的区别 8.激活成功后进行参数下载，sn号传的null值，然后通过4.获取真正的sn 9.参数下载（交易相关的）：流水号，批次号，交易币种，交易ip,商户信息，全报文加密标志位 输入/扫描激活码激活设备 通过打开扫描页面扫激活码，在扫码成功的回调中根据激活码查询商户名等信息 CILSDK.getMechantInfo(activeCode,time.appVersion); 点击激活按钮调用激活码激活接口 CILSDK.activeWithCode(activeCode,deviceToken, callback); 激活接口调用成功后紧接着调用下载终端参数的接口 CILSDK.downloadParamWithProgress(callback); 终端密钥下载 终端密钥下载只需要成功执行一次即可，密钥会被转载到POS的硬件模块 下载RSA公钥 装载RSA公钥 下载主密钥 装载主密钥 启用主密钥 下载工作密钥 装载工作密钥 下载AIDS 装载AIDS 下载ICPKS 装载ICPKS 上送联机版本号 激活完成接口 CILSDK.notifyActived(mer,term); 交易 1. 扫码交易（不需要硬件模块读卡器） 扫码消费consume request.setAmount() request.setScanCode() request.setOrderId() CILSDK.consumeQr(request,callback); 在callback中判断如果有应答09/98需要发起查询操作 CILSDK.QueryQr(request,callback);//查询6次10s不超过60s,查询出结果返回，如果最后一次仍然是09、98sdk会自动发起取消操作 扫码取消/冲正cancel CILSDK.sCanCodeCancel(request,callback); * 扫码撤销revoke CILSDK.revokConsumerQr(request,callback); 扫码退货refund CILSDK.returnConsumeQr 2. 刷卡交易区分卡类型（mscCard,icCard ,nfcCard,默认使用mscCard） 通过继承BaseCardActivity复写 getAmount()接口方法 通过跳转的时候传过来 cardReaderHandler() 读卡信息的接听返回 密码键盘调用 1.在BaseCardActivity的oncreat方法中实例话的类MyPosTransferListener中有个方法监听键盘事件sendPinRequest(String accNo). 2.监听被带进cardEventDelegate--->Pos--->指定的卡事件处理类 3.输入密码时候锁住当前线程 CILSDK 类直接对外提供方法的类 SwipCardTrade 类中处理刷卡相关报文的发送 transactionUtils 交易相关的辅助类 cardEventDelegate 代理卡片事件管理 basecardactyivity调用这个类 读卡 打开键盘 完成读卡 失败 通过startactivityforResult 返回时判断requestcode来处理unlock线程 每个品牌posreader类都实现接口（openCardread,cancelCardReader）,通过工厂模式创建各品牌的读卡模块 汇总： 1.抽象类实现一个接口(cardHandlerResult)，然后具体的类去继承抽象类（BaseCardActivitivity），便可选择性的复写需要的方法。 WithOutCardTrade 两种不需要卡的交易分别是小费和DCC转EDC 刷卡消费 CILSDK.consume(request,callback); 刷卡撤销 CILSDK.revokeConsume(request,cardType,Callback); 刷卡退货 CILSDK.returnConsume(requst,cardtype,callback); 刷卡余额查询 CILSDK.checkBalance(request,cardtype,callback); 刷卡预授权 CILSDK.preAuth(request,cardtype,callback); 刷卡预授权完成 CILSDK.preAuthComplete(request,cardtype,callback); DCC转EDC CILSDK.dccToEdc(request,callback); 账单查询 * 获取账单列表 CILSDK.getBillsAsync(pager,size,txtype,callback); * 获取账单统计 CILSDK.getBillStateAsync(type,callback) * 根据凭证号获取订单详情（获取当前批次下得订单详情，凭证号：） CILSDK.getBillByTraceNumAsync(trancenum,callback) 结算 每日交易结束得时候或收银员交接班时，对某段时间内得账款核对，商户每日交易结束得时候，收银员需要统计并核对所有得交易，核对交易统计准确后结算，打印出结算单，结算会涉及一个概念 批次号，我们在前面的交易都会传入一个批次号给request,调用结算后，后续的交易需要将这个批次号加一，因为此批次号已经打包结算掉了 CILSDK.transSettleAsync(batchNum,callback) 打印 * 打印银行卡类交易、扫码类交易 CILSDK.printKindsReceipts(trans，linebreak,formartTransCode,kind,isForeignTrans,callback); * 打印结算小票 CILSDK.pintSettleReceipts(transSettles,transDatetime,batchNum,formatTransCode,lineBreak,formatTransCode,callback); * 自定义打印 (超过2000个字符需要采用分段式打印，否则出现异常DeviceRTException) CILSDK.printBufferReceipt(buffer,lineBreak,callback); * 打印二维码 CILSDK. printQRCode(qrCode,positon,width,linebreak,callback); * 打印条形码 CILSDK.printBarCode(barCode,posion,lineBreak,callback); * 打印图片 CILSDK.printImage(bitmap,lineBreak,offset,callback) 其他设置 获取sdk版本号 CILSDK.VERSION_NAME; CILSDK.VERSION_CODE; * 获取sn号 CILSDK.getDeviceSN(); 设置流水号 CILSDK.setSericalNum(int serialNum); * 获取流水号 CILSDK.getSerialNum(); * 设置批次号 CILSDK.setBatchNum(int batchNum); 获取批次号 CILSDK.getBatchNum(); 设置联迪密钥区(取值范围1~15) 需要在CILSDK.connect之前调用 CILSDK.setTingA8KeyIndex(2); * 设置密钥索引(MAIN,MAC,PIN,MES) 需要在CILSDK.connect之前调用 CILSDK.setTingKeyIndex(4,101,10,150); 日志收集（uncaughtExceptionHandler） 将日志写到sd文件中，然后上传的时候在从文件中取出上传 1.编译时异常在编码的时候就会提示编码人员进行try catch,运行时异常会出现忘记trycatch的现象，可以通过uncaughtExceptionHandler来进行捕获 具体用法：继承这个类复写uncaughtException方法，具体的异常会回调到这个方法中（https://www.cnblogs.com/jadic/p/3532580.html） 捕获后写到本地的sdcard中 2.上传log文件IntentService debugInfoActivity右上角的optionsMenu有上传日志的选项 开启IntentService在handleIntent中执行上传日志操作 开启线程池一条一条的上传日志SingleThreadExcutor MainActivity-->mainpagerFragment-->DebugInfoActiivty标题栏的头像点击8下，进入调试暗门","text_tokens":["上传","get","区","1","其他","oncreat","网关","余额","mainactivity","进行","开","传入","二维码","不断","sp","implementation","是","setaddress","60s","address","抽取","_","本地","结算","devicetoken","authentication","d","错误","卡","已经","出现","指定","继续","当前","标志","自定","分段","还","注册","功能","权限","事件处理","setamount","字符","withoutcardtrade","订单","put","getmername","string","depandence","紧接着","消费","jobscheldure","每日","cnblogs","versionname","下方","notifyactive","（","现象","preauthcomplete","只有","对外","-","getserialnum","batchnum","dcctoedc","立马","会","涉及","rsa","这个","没有","给","密码","实现","printkindsreceipts","a","msccard","4","serialnum","txtype","setscancode","代码","下才","https","通过","包","仍然","setbatchnum","日志","应答","返回","概念","银员","签到","activitylifecyclercallbacks","将","8","列表","offset","time","收银","revokeconsume","catch","表示","内部","putstring","时候","推荐","cardreaderhandler","比手","getbillbytracenumasync","printqrcode","类中","键盘","我们","旧版","pos","api"," ","jbig","width","aids","edc","发送","getmerchantinfo","适配","term","小数位","结果","检查","scancodecancel","activecode","intentservice","transdatetime","因为","project","activewithcode","完成","管理","sd","捕获","可选","positon","过程","背景","check","环境","信息","详情","池","downloadparam","buildconfig","选择","/","pager","都","notifyactived","页面","发起","注册码","c","结束","确定","putint","possdk","build","getbillstateasync","15","关系","10","gradle","debuginfoactivity","可选择性","optionsmenu","设备","装载","紧接","0.01","凭证","取值","重置","上角","模式","currency","size","号加","类型","name","输入","formarttranscode","项目","myapplication","个","便","trancenum","编码","时","调用","取消","版本号","扫","downloadparameters","transsettleasync","颜色",".","工作","一次","object","real","前面","3532580","转","联迪","加密","默认","'","7","activeactivity","操作","输出","个字符","刷卡","5","sdcard","accno","预","callback","log","新","basecardactyivity","或","异常","报文","平台","被","requestcode","setorderid","金额","kind","splashactivity","某","依赖","式","handleintent","扫描","setdebug","实例","rxjava","两种","basecardactivitivity","银行卡","下载","流水","mac","active","98sdk","小票","打包","iccard","handler","sdk","type","交易","头像","生成","对","写到","清空","buffer","basecardactivity","取出","具体","mypostransferlistener","即可","cardhandlerresult","ip","监听","pin","98","uncaughtexception","returnconsume","不","代理","appversion","标题栏","使用",">","流水号","处理","段时间","跳转","queryqr",")","终端","请求","获取","批次","交接班","银行","trycatch","等","debug","2.4","推送","重新","不同","requst","读码","锁住","posreader","接听","com","3","模块","singlethreadexcutor","编译","需要","收集","try","收银员","2","账单","bitmap","actiivty","consumeqr","transe","+","要求","所有","trans","只","setcilappversion","创建","索引",";","手动","超过","线程","内得","icpks","为空","硬件","区分","退货",",","服务平台","一致","抽象类","devicertexception","apk","记录","opencardread","选择性","接着",":","商户","isforeigntrans","上","工厂","cardtype","数位","）","graph","150","识别","类","查询","与","提示","\"","密钥","送","获得","联机","request","失败","里面","kprogresshud","另","连接不断","开启","话","还是","一些","--------","app","图","this","sendpinrequest","中有","一个","settinga8keyindex","名","准确","得","context","值","存储","图片","下","根据","virtualsn","github","过来","核对","前","printbarcode","在","int","打印","区别","保证","传","超时","downloadparamwithprogress","人员","读卡器","每天","整理","接口","preauth","9","(","二维","barcode","品牌","激活码","各","cardeventdelegate","activateactivity"," ","打开","revokconsumerqr","onactivityresult","str","引用","条形","printimage","2000","revoke","旧版本","unlock","尝试","右上角","缓存","唯一","a8","单","checkbalance","参数","应用","connect","激活","td","第三","html","getamount","refund","全","动画","...","swipcardtrade","最小","settingkeyindex","main","跑","token","形码","null","；","后续","次","mer","nfccard","sn","可能","cancel","同","activedevice","运行","暗门","101","主","冲正","依然","---","可以","0","termcode","10s","debuginfoactiivty","方法","服务","端口","有","复写","printbufferreceipt","mes","dcc","点击","后","方式","startactivityforresult","传统","中","执行","cancelcardreader","是否","出","用法","pintsettlereceipts","率先","授权","录入","~","。","收单","后写","getbillsasync","www","带进","smartpos","启用","位","传过","账款","提供","按钮","扫码","交接","posion","自定义","formattranscode","直接","并","连接","三方","linebreak","去","转载","标题","pow","一条","标识","异步","activity","mainpagerfragment","math","三个","事件","此","回调","进入","自动","公钥","code","然后","*","同步","qrcode","真正","判断","b","先","getmechantinfo","相关","从文件","采用","每个","的","条形码","setsericalnum","p","了","之前","版本","接班","否则","第三方","mercode","建议","cillog","kit","卡片","一","returnconsumeqr","右上","号","如果","抽象","最后","getbatchnum","，","传过来","version","忘记","到","设置","jadic","uncaughtexceptionhandler","辅助","切换","getdevicesn","点","文件","和","来","更新","范围","consume","时间","分别","币种","signin","login","后台","继承","--","6","定义","读卡","出现异常","20190527","掉","初始","小费","就","小数","：","初始化","源代码","transactionutils","汇总","撤销","loadparameters","输多","、","选项","transsettles","成功","cilsdk","调试","09","统计"],"title":"1. 鲁迅语录","title_tokens":[".","鲁迅","1"," ","语录"]},{"location":"SmartPos/#smartpos","text":"","text_tokens":[],"title":"SmartPos","title_tokens":["smartpos"]},{"location":"SmartPos/#_1","text":"","text_tokens":[],"title":"项目依赖关系图","title_tokens":["项目","依赖","图","关系"]},{"location":"SmartPos/#_2","text":"build.gradle里面的depandence中 implementation project(':PosSDK') implementation project(':jbig-kit') implementation project(':kprogresshud') MyApplication中初始化 CILSDK.setCILAppVersion(); CILSDK.setDebug(BuildConfig.DEBUG); CILSDK.setAddress(BuildConfig.ADDRESS); CILSDK.connect(this); 如果还适配了联迪A8，login需要传入activity的context建议在每个可能调用设备刷卡，加密，打印的actiivty调用CILSDK.connect()保证使用过程中设备连接不断开推荐使用activitylifecyclerCallbacks. SplashActivity 设置了activity的进入动画。 下方设置了版本号+背景颜色表示不同环境。 跑了一个handler(根据是否激活和是否下载参数来进入MainActivity还是ActivateActivity)。 ActivateActivity 两种激活方式 扫二维码 输入商户号和终端号（要求在服务平台手动录入sn号） 两种方式的区别：扫二维码比手输多了个去服务平台请求商户号和终端号的接口 激活的过程（服务平台） 扫二维码：读码成功立马调用getMerchantInfo获取商户信息，点击激活按钮调用activeDevice接口（接口内部调用了downloadParameters终端参数下载接口+notifyActive激活完成） 输入商户号和终端号：active+loadparameters ACTIVE:服务平台激活 LOADPARAMETERS:下载交易需要的相关信息；交易Ip和端口，币种，超时时间，权限，报文加密标志位。 MainActivity 检查APP版本 jobScheldure 后台服务进行下载apk 终端密钥下载 下载RSA->装载RSA->下载主密钥->装载主密钥->启用主密钥->下载工作密钥->装载工作密钥->下载aids->装载aids->下载ICPKS->装载ICPKS 签到（更新工作密钥（下载+装载工作密钥）的过程）网关平台要求应用每天签到一次 CILSDK.signIn() 6.交易 扫码交易 先检查本地缓存的币种与交易报文的币种是否一致 check transe currency 不一致--->结算 一致，继续 最小交易金额Math.pow(10,-2) 0.01 根据交易币种小数位来确定 银行卡交易 api","text_tokens":["主","需要","---","buildconfig","网关","2","mainactivity","actiivty","开","服务","传入","端口","进行","二维码","不断","transe","implementation","possdk","确定","+","setaddress","要求","build","address","本地","结算","10","点击","gradle","方式","setcilappversion",";","中","手动","继续","icpks","标志","设备","装载","还","是否",",","服务平台","0.01","一致","权限","apk","录入",":","。","商户","currency","数位","）","启用","位","depandence","jobscheldure","与","按钮","下方","输入","扫码","notifyactive","（","myapplication","个","密钥","调用","版本号","-","扫","downloadparameters","连接","颜色",".","去","里面","kprogresshud","工作","连接不断","立马","pow","一次","activity","联迪","加密","还是","rsa","'","math","app","this","刷卡","一个","进入","context","报文","平台","先","相关","根据","金额","splashactivity","每个","的","了","签到","在","版本","activitylifecyclercallbacks","打印","区别","建议","setdebug","保证","kit","两种","超时","银行卡","下载","每天","接口","active","号","如果","handler","交易","(","表示","二维","，","内部","推荐","activateactivity","比手","设置","缓存","api","ip"," ","a8","和","来","更新","参数","jbig","应用","connect","激活","时间","币种","aids","signin","login","不","getmerchantinfo","适配","后台","小数位","6","使用",">","检查","动画","最小",")","终端","请求","获取","银行","初始","跑","小数","project","初始化","：","；","debug","完成","不同","loadparameters","输多","读码","sn","过程","背景","check","可能","环境","成功","cilsdk","信息","activedevice"],"title":"激活模块","title_tokens":["模块","激活"]},{"location":"SmartPos/#_3","text":"getMerName 终端注册码获取商户信息接口 ActiveActivity的onActivityResult中调用 sdk中调用 active 获取Authentication Token接口 旧版本激活方式使用的是devicetoken(推送模块生成) activeCode 新激活接口，使用激活码 激活码方式激活使用的是sn，token传的null graph TD; A-->B; A-->C; B-->D; C-->D;","text_tokens":["商户","旧版","b"," ","graph","getmername","注册码","激活","td","的","c","版本","是","--","使用",">","调用","devicetoken","传","方式","authentication",")","终端","获取","activecode","d",";","中","接口","token","active","null","sdk","(","推送","activeactivity","，","激活码","a","注册","生成","sn","信息","onactivityresult","新","模块","旧版本"],"title":"收单服务平台","title_tokens":["收单","服务平台","平台","服务"]},{"location":"SmartPos/#sdk","text":"激活模块（在录入终端的时候需要选择方式） app~收单服务平台 1. 传统输入商户号和终端号的方式激活（重置的方法是清空sn号然后点击确定） * 调用sdk激活接口 CILSDK.active(merCode, termCode, callback); * 接口调用成功后立马调用终端参数下载接口下载交易时使用的参数 CILSDK.downloadParam(mer,term,callback); * 跳转到MainActivity onCreat的时候调用终端密钥下载接口 CILSDK.downloadParamWithProgress(callback); 汇总： 1.sp的抽取   传入三个参数put(Context context,String str,Object   object),根据object的类型，选择putString还是putInt。。。get(...)同上 2.KProgressHUD github上第三方包直接引用源代码 3.抽取CILlog类，只有在debug模式下才输出日志，另使用sd记录一些错误日志 4.存储sn（会率先使用A没有后然后使用B）   A.virtualSN：使用激活码激活成功后，服务平台会返回sn，存储到sp   B.REAL_SN：a8,联迪。。。在设备连接的时候会获取一个REAL_SN 5.devicetoken   推送平台使用的设备唯一标识识别，可以通过推送服务的注册获得   旧版本激活前如果devicetoken为空，会尝试进行重新注册一次来获取devicetoken,如果依然为空，传 \"\" 6.versionname   2.4.0：20190527：SDK 7.激活同步、异步-------->是否使用RXjava进行切换的区别 8.激活成功后进行参数下载，sn号传的null值，然后通过4.获取真正的sn 9.参数下载（交易相关的）：流水号，批次号，交易币种，交易ip,商户信息，全报文加密标志位 输入/扫描激活码激活设备 通过打开扫描页面扫激活码，在扫码成功的回调中根据激活码查询商户名等信息 CILSDK.getMechantInfo(activeCode,time.appVersion); 点击激活按钮调用激活码激活接口 CILSDK.activeWithCode(activeCode,deviceToken, callback); 激活接口调用成功后紧接着调用下载终端参数的接口 CILSDK.downloadParamWithProgress(callback); 终端密钥下载 终端密钥下载只需要成功执行一次即可，密钥会被转载到POS的硬件模块 下载RSA公钥 装载RSA公钥 下载主密钥 装载主密钥 启用主密钥 下载工作密钥 装载工作密钥 下载AIDS 装载AIDS 下载ICPKS 装载ICPKS 上送联机版本号 激活完成接口 CILSDK.notifyActived(mer,term); 交易 1. 扫码交易（不需要硬件模块读卡器） 扫码消费consume request.setAmount() request.setScanCode() request.setOrderId() CILSDK.consumeQr(request,callback); 在callback中判断如果有应答09/98需要发起查询操作 CILSDK.QueryQr(request,callback);//查询6次10s不超过60s,查询出结果返回，如果最后一次仍然是09、98sdk会自动发起取消操作 扫码取消/冲正cancel CILSDK.sCanCodeCancel(request,callback); * 扫码撤销revoke CILSDK.revokConsumerQr(request,callback); 扫码退货refund CILSDK.returnConsumeQr 2. 刷卡交易区分卡类型（mscCard,icCard ,nfcCard,默认使用mscCard） 通过继承BaseCardActivity复写 getAmount()接口方法 通过跳转的时候传过来 cardReaderHandler() 读卡信息的接听返回 密码键盘调用 1.在BaseCardActivity的oncreat方法中实例话的类MyPosTransferListener中有个方法监听键盘事件sendPinRequest(String accNo). 2.监听被带进cardEventDelegate--->Pos--->指定的卡事件处理类 3.输入密码时候锁住当前线程 CILSDK 类直接对外提供方法的类 SwipCardTrade 类中处理刷卡相关报文的发送 transactionUtils 交易相关的辅助类 cardEventDelegate 代理卡片事件管理 basecardactyivity调用这个类 读卡 打开键盘 完成读卡 失败 通过startactivityforResult 返回时判断requestcode来处理unlock线程 每个品牌posreader类都实现接口（openCardread,cancelCardReader）,通过工厂模式创建各品牌的读卡模块 汇总： 1.抽象类实现一个接口(cardHandlerResult)，然后具体的类去继承抽象类（BaseCardActivitivity），便可选择性的复写需要的方法。 WithOutCardTrade 两种不需要卡的交易分别是小费和DCC转EDC 刷卡消费 CILSDK.consume(request,callback); 刷卡撤销 CILSDK.revokeConsume(request,cardType,Callback); 刷卡退货 CILSDK.returnConsume(requst,cardtype,callback); 刷卡余额查询 CILSDK.checkBalance(request,cardtype,callback); 刷卡预授权 CILSDK.preAuth(request,cardtype,callback); 刷卡预授权完成 CILSDK.preAuthComplete(request,cardtype,callback); DCC转EDC CILSDK.dccToEdc(request,callback); 账单查询 * 获取账单列表 CILSDK.getBillsAsync(pager,size,txtype,callback); * 获取账单统计 CILSDK.getBillStateAsync(type,callback) * 根据凭证号获取订单详情（获取当前批次下得订单详情，凭证号：） CILSDK.getBillByTraceNumAsync(trancenum,callback) 结算 每日交易结束得时候或收银员交接班时，对某段时间内得账款核对，商户每日交易结束得时候，收银员需要统计并核对所有得交易，核对交易统计准确后结算，打印出结算单，结算会涉及一个概念 批次号，我们在前面的交易都会传入一个批次号给request,调用结算后，后续的交易需要将这个批次号加一，因为此批次号已经打包结算掉了 CILSDK.transSettleAsync(batchNum,callback) 打印 * 打印银行卡类交易、扫码类交易 CILSDK.printKindsReceipts(trans，linebreak,formartTransCode,kind,isForeignTrans,callback); * 打印结算小票 CILSDK.pintSettleReceipts(transSettles,transDatetime,batchNum,formatTransCode,lineBreak,formatTransCode,callback); * 自定义打印 (超过2000个字符需要采用分段式打印，否则出现异常DeviceRTException) CILSDK.printBufferReceipt(buffer,lineBreak,callback); * 打印二维码 CILSDK. printQRCode(qrCode,positon,width,linebreak,callback); * 打印条形码 CILSDK.printBarCode(barCode,posion,lineBreak,callback); * 打印图片 CILSDK.printImage(bitmap,lineBreak,offset,callback) 其他设置 获取sdk版本号 CILSDK.VERSION_NAME; CILSDK.VERSION_CODE; * 获取sn号 CILSDK.getDeviceSN(); 设置流水号 CILSDK.setSericalNum(int serialNum); * 获取流水号 CILSDK.getSerialNum(); * 设置批次号 CILSDK.setBatchNum(int batchNum); 获取批次号 CILSDK.getBatchNum(); 设置联迪密钥区(取值范围1~15) 需要在CILSDK.connect之前调用 CILSDK.setTingA8KeyIndex(2); * 设置密钥索引(MAIN,MAC,PIN,MES) 需要在CILSDK.connect之前调用 CILSDK.setTingKeyIndex(4,101,10,150); 日志收集（uncaughtExceptionHandler） 将日志写到sd文件中，然后上传的时候在从文件中取出上传 1.编译时异常在编码的时候就会提示编码人员进行try catch,运行时异常会出现忘记trycatch的现象，可以通过uncaughtExceptionHandler来进行捕获 具体用法：继承这个类复写uncaughtException方法，具体的异常会回调到这个方法中（https://www.cnblogs.com/jadic/p/3532580.html） 捕获后写到本地的sdcard中 2.上传log文件IntentService debugInfoActivity右上角的optionsMenu有上传日志的选项 开启IntentService在handleIntent中执行上传日志操作 开启线程池一条一条的上传日志SingleThreadExcutor MainActivity-->mainpagerFragment-->DebugInfoActiivty标题栏的头像点击8下，进入调试暗门","text_tokens":["上传","get","区","1","其他","oncreat","余额","mainactivity","进行","传入","二维码","sp","是","60s","抽取","_","本地","结算","devicetoken","错误","卡","已经","出现","指定","当前","标志","自定","分段","注册","事件处理","setamount","字符","withoutcardtrade","订单","put","string","消费","紧接着","每日","cnblogs","versionname","（","现象","preauthcomplete","只有","对外","getserialnum","batchnum","dcctoedc","立马","会","涉及","rsa","这个","没有","给","密码","实现","printkindsreceipts","a","msccard","4","serialnum","txtype","setscancode","代码","下才","https","通过","包","仍然","setbatchnum","日志","应答","返回","概念","银员","将","8","列表","offset","time","收银","revokeconsume","catch","putstring","时候","cardreaderhandler","getbillbytracenumasync","printqrcode","类中","键盘","我们","旧版","pos"," ","width","aids","edc","发送","term","结果","scancodecancel","activecode","intentservice","transdatetime","因为","activewithcode","完成","管理","sd","捕获","可选","positon","信息","详情","池","downloadparam","pager","选择","/","都","notifyactived","页面","发起","结束","确定","putint","getbillstateasync","15","10","debuginfoactivity","可选择性","optionsmenu","设备","装载","紧接","凭证","取值","重置","上角","模式","size","号加","类型","name","输入","formarttranscode","trancenum","个","便","编码","时","调用","取消","版本号","扫","transsettleasync",".","工作","一次","object","real","前面","3532580","转","联迪","加密","默认","7","操作","输出","个字符","刷卡","5","sdcard","accno","预","callback","log","basecardactyivity","或","异常","报文","平台","被","requestcode","setorderid","kind","某","handleintent","式","扫描","实例","rxjava","两种","basecardactivitivity","银行卡","下载","流水","mac","active","98sdk","小票","打包","iccard","sdk","type","交易","头像","对","写到","清空","buffer","basecardactivity","取出","具体","mypostransferlistener","即可","cardhandlerresult","ip","监听","pin","98","uncaughtexception","returnconsume","不","代理","appversion","标题栏","使用",">","流水号","处理","段时间","跳转","queryqr",")","终端","获取","批次","交接班","银行","trycatch","等","debug","2.4","推送","重新","requst","锁住","posreader","接听","com","3","模块","singlethreadexcutor","编译","需要","收集","try","收银员","2","账单","bitmap","consumeqr","所有","trans","只","创建","索引",";","超过","线程","内得","icpks","为空","硬件","区分","退货",",","服务平台","抽象类","devicertexception","记录","opencardread","选择性","接着","商户","isforeigntrans",":","上","工厂","cardtype","）","150","识别","类","查询","提示","\"","密钥","送","获得","联机","request","失败","kprogresshud","另","开启","话","还是","一些","--------","app","sendpinrequest","中有","一个","settinga8keyindex","名","准确","得","context","值","存储","图片","下","根据","virtualsn","github","过来","核对","前","printbarcode","在","int","打印","区别","传","downloadparamwithprogress","人员","读卡器","接口","preauth","9","(","二维","barcode","品牌","激活码","各","cardeventdelegate"," ","打开","revokconsumerqr","str","引用","条形","printimage","2000","revoke","旧版本","unlock","尝试","右上角","唯一","a8","单","checkbalance","参数","第三","connect","激活","html","getamount","refund","全","...","swipcardtrade","settingkeyindex","main","形码","null","后续","次","mer","nfccard","sn","cancel","同","运行","暗门","101","主","冲正","依然","---","可以","0","termcode","10s","debuginfoactiivty","方法","服务","有","复写","printbufferreceipt","mes","dcc","点击","后","方式","startactivityforresult","传统","中","执行","cancelcardreader","是否","出","用法","pintsettlereceipts","率先","授权","录入","~","。","收单","后写","getbillsasync","www","带进","启用","传过","位","账款","提供","按钮","扫码","交接","posion","自定义","formattranscode","直接","并","连接","三方","linebreak","去","转载","标题","一条","标识","异步","mainpagerfragment","三个","事件","此","回调","进入","自动","公钥","code","然后","*","同步","qrcode","真正","判断","b","getmechantinfo","相关","从文件","采用","每个","的","条形码","setsericalnum","p","了","之前","版本","接班","否则","第三方","mercode","cillog","卡片","一","returnconsumeqr","右上","号","如果","抽象","最后","getbatchnum","，","传过来","version","忘记","到","设置","jadic","uncaughtexceptionhandler","辅助","切换","getdevicesn","文件","和","来","范围","consume","时间","分别","币种","继承","定义","6","--","读卡","出现异常","20190527","掉","小费","就","：","源代码","transactionutils","汇总","撤销","、","选项","transsettles","成功","cilsdk","调试","09","统计"],"title":"sdk功能点整理","title_tokens":["功能","整理","点","sdk"]},{"location":"algorithm/","text":"HashMap 概念 用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。 put方法原理 调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。 get方法 首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找 初始化长度 初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。 高并发下的HashMap Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap. 什么是ConcurrentHashMap？ ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。 put和get原理 get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash 红黑树 （数据结构） 二叉树的特性 1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树 红黑树特性 节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。 调整红黑树的两种方法（变色、旋转） AES算法（对称加密算法） MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。 三个基本概念（密钥、填充、模式） 密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。 在java中的具体实现 注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。 AES算法的底层原理 一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey） 字节替代 subByte 十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11] 行移位 shiftRows 如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节 列混淆MixColumns 输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列 加 论密钥(add round key) 128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。 不同工作模式在加密流程中有什么不同？ 所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度 MD5 可以从任意长度的明文字符串生成128位的哈希值 验签过程 1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制 MD5底层原理 分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c Base64 排序 冒泡算法和优化","text_tokens":["异或","知道","get","缺少","175","二块","sign","1","拆分","i","一个个","进行","feedback","二个","怎么","三步","不断","完全","是","多个","优势","任一","分成","_","第二","32","匹配","过去","对比","第四个","二叉","第四行","d","扩容","0x76543210","创造者","出现","cipher","128","4x4","当前","1234","计算器","分段","aes","一股","h","几乎","大小","遇到","张图","这","只要","容量","水线","字符","使得","hash","多少","第一位","指针","论","put","干涉","java8","一直","经过","电码本","很多","参数值","0xfedcba98","=","进制","（","[","现象","相当于","只有","主干","-","意思","用于","z","结构","由","开始","j","限制","会","其它","验证","本身","这个","大打折扣","没有","密码","实现","a","初始值","4","函数","映射","第一","有限","pkcs5padding","代码","包含","通过","树","之所以","101110001110101110","aes256","旋转","代表","持有","概念","一列","加盐","即","总","当","将","8","nopadding","旧","取代","round","加","最","缺点","md5","resize","64","传输","难免","segment","根","完后","签名","表示","内部","数","流程","读写","时候","shiftrows","次数","一共","位置","盒","演变","坏人","mj"," ","为了","几种","每","决定","上面","发送","加入","结果","理过","尾端","参与","归纳","mixcolumns","几位","两次","因为","完整","大于","反馈","分组","完成","y","码本","有利","田字","直到","第一行","过程","信息","哈希","填充","并发","幂","两位","复杂度","所","任意","用到","计算","/","交替","第二行","都","255","最高","体现","c","n","结束","subtitution","ecb","假设","因子","addroundkey","既","思想","大","15","说","10","^","整个","最终","求余","语言","左子","sha256","如下","非线性","m16","ecb2","加解密","好","当于","两个","修补","左右","增长","如何","同时","让","且","替换","模式","aes192","之一","达到","0x01234567","累加","带上","size","原来","acount","例如","阈值","31","成","链接","负载","安全性","数倍","防止","amout","输入","必须","阶段","数值","私密","除了","可能性","个","差别","之间","时","调用","顺着","codebook","得出","规则","加轮","互不干涉",".","12","工作","ctr","或者","subbyte","高","降低","一次","对象","底层","表","数据结构","加密","默认","7","16","操作","后面","属于","输出","中当","5","四种","量值","电码","3029737","一把","起来","新","java","一组","或","第四","任何","subbytes","}","16x16","十六","192bit","add","平台","被","得到","那么","金额","iso126padding","列","环","一等","独立","第三行","基本概念","安全","排列成","这些","index","子","loadfactor","ki","两件","两种","有利于","以上","右子","就是","比如","流水","三种","空","校验","可逆","篡改","释放","等份","counter","锁","依次","生成","对","一行","也","变化","整数倍","1001","黑色","连续","组是","键值","具体","00","如图","即可","双方","相当","官方","|","所以","outputfeedback","ade876ishdfakhdj","混淆","循环","攻击","常量","不","initial","但是","红黑树","等同于","使用","二级","当新","头",">","另外","长度","原文","处理","四行",")","发生变化","不变","获取","请求","二进制","排序","book","&","性能","key","第一步","粒度","矩阵","重新","块","不同","带","#","主要","关联","k","一股脑","二行","链表","越来越","两倍","调整","整段","3","成一","s","一位","一致性","外","electronoc","解决","需要","不如","是非","收集","-------------------------","iv","均","2","元素","额外","final","多","等于","赋值","冒泡","+","要求","aes128","所有","只","大家","行","指向","例","创建","定位","拆","发生","较差","entry","超过","线程","分布","验签","向","从根","主体","变成","而","对称","接插","常用","g",",","一致","越来","记录","移位","显然","无误","一起",":","数目","数组","上","并行计算","实际","同一个","集合","完整性","体位","）","512","共","与","ofb","某种","\"","相同","密钥","一段","二分","密文","做","攻击者","运算","按照","支付","假定","作为","补全","次子","流水线","四步","第一个","第","相应","<","hashcode","中有","一个","少于","keyexpentions","名","vector","只能","concurrenthashmap","最大","有些","普通","补足","值","存储","表面","原始","遍历","不止","增加","下图","从","ff","插入","左","下","根据","线性","查找","写入","注意","同样","向量","前","所用","一样","冲突","在","最好","典型","轮","保证","近似","走到","mi","种子","很","而是","9","(","左移","二维","组","搞笑","cfb","加工","铭文","剩余","尝试","0.75","原本","折扣","节点","要","步骤","]","单","value","为什么","解密","参数","创造","刚好","第三","capacity","事情","cbc","不是","w","再","block","泄漏","bit","处理过程","fix","实践","这种","null","后续","次","5b","轮数","换成","第三个","说明","封装","不足","插法","下面","64bit","个个","可能","electronic","表达","三行","第二块","接收","分散","字","主","均匀分布","并行","0","可以","图中","右","之后","分为","打折扣","利于","方法","hashmap","有","等同","难免会","算器","命名","那个","？","优点","rehash","引入","找","首先","利用","initialization","后","四个","技术","十进制","方式","绿色","算法","对应","中","这样","是因为","不能","摘要","m","原","整数","有点","产生","是否","有个","出","256","1111","字符串","第二个","约定","呢","chainning","0x89abcdef","情况","加密算法","。","十六进制","~","这里","单次","黄色","原理","同一","互不","宏观","字节","重入","更高","认为","位","提供","五种","”","具体位置","则","前会","11","值补","许多","原先","修改","打折","叶子","直接","并","zegment","abcd","三方","一轮","平时","替代","m15","高度","e","条件","覆盖","账户","相加","二叉树","三个","随之","变色","路径","孩子","用","有点像","二进制位","其余","128bit","*","由于","扩展","直接插入","又","真正","b","业务","数量","相关","排列","采用","每个","13","的","47","作用","了","上锁","简单","无法","next","把","第三方","代替","田","随机","beauty","m0","问题","448","》","拼接","小于","14","数据","子树","如果","均匀","base64","最后","复杂","box","特性","，","平衡","到","当中","设置","替换成","同于","效率","一步","影响","取决","依据","叫做","rounds","和","“","来","可","matrix","优化","基本","分别","全为","支持","6","它","x","m1","{","明文","\\","......","目标","初始","什么","就","末尾","细节","chaining","二位","：","初始化","源代码","length","f","加密器","160","列成","为","192","取决于","各种","给定","、","阻塞","份","相乘","向下","除去","加锁","红色","统计","生变"],"title":"算法","title_tokens":["算法"]},{"location":"algorithm/#hashmap","text":"","text_tokens":[],"title":"HashMap","title_tokens":["hashmap"]},{"location":"algorithm/#_1","text":"用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。","text_tokens":["。","分散","键值","数组","get","叫做","集合"," ","和","value","）","都","put","每","元素","hashmap","的","方法","在","是","（","这些","主干","-",")","用于","最","初始","就是","中","entry","key","null","这个","(","，","常用","初始值","一个",",","对","也","存储"],"title":"概念","title_tokens":["概念"]},{"location":"algorithm/#put","text":"调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。","text_tokens":["1","0","可以","2","元素","hashmap","难免会","多","是","大","后","指向","对应","创造者","entry","出现","超过","变成","接插","遇到",",","越来","。","数组","size","指针","put","认为","java8","”","=","\"","现象","可能性","时","调用","-","假定","得出","直接",".","对象","会","hashcode","中当","一个","通过","直接插入","不止","插入","被","下","查找","采用","的","冲突","next","当","index","8","beauty","难免","最后","(","，","到","位置","即可","节点"," ","“","创造","每","但是","红黑树","当新","头","它","长度",")","&","key","：","为","链表","插法","越来越","可能"],"title":"put方法原理","title_tokens":["put","方法","原理"]},{"location":"algorithm/#get","text":"首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找","text_tokens":["位置","上","size","hash","1","同一个","需要","节点"," ","同一","根据","得到","hashmap","的","有","=","输入","多个","index","头","找","首先","做","匹配","顺着","-",")",".","entry","一次","&","key","这个","(","hashcode","，","时候","一个",",","链表","映射","可能","到","向下"],"title":"get方法","title_tokens":["get","方法"]},{"location":"algorithm/#_2","text":"初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。","text_tokens":[":","。","101110001110101110","取决","size","hash","1","计算","-------------------------"," ","下","2","所以","同于","hashmap","的","与","全为","等同","=","输入","进制","是","结果","等同于","index","15","长度","做","1001","运算","-","后",")","例","十进制","以上",".","算法","二进制","初始","book","对应","几位","就是","&","这种","key","初始化","其它","9","均匀","length","最后","本身","(","hashcode","16","情况","为","，","后面","取决于",",","函数","1111","两个","只要","增长","哈希","3029737","3","二进制位","幂","值","或"],"title":"初始化长度","title_tokens":["初始","初始化","长度"]},{"location":"algorithm/#hashmap_1","text":"Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap.","text_tokens":["解决","需要","1","计算","是非","2","进行","hashmap","方法","那个","因子","是","？","rehash","后","创建","扩容","发生","出现","线程","当前","如下","是否","容量","如何","情况",":","达到","。","数组","size","hash","原来","负载","=","做","规则",".","会","条件","默认","随之","concurrenthashmap","有限","新","*","下","的","环","了","在","安全","index","loadfactor","两件","resize","(","，","时候","也","变化","0.75","要"," ","为什么","capacity","事情","使用",">","长度",")","发生变化","什么","因为","：","f","链表","两倍","可能","并发","幂","生变"],"title":"高并发下的HashMap","title_tokens":["的","高","下","并发","hashmap"]},{"location":"algorithm/#concurrenthashmap","text":"ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。","text_tokens":["。","影响","又","hash","需要","同一个"," ","相当","互不","同一","持有","都","写入","更高","采用","每个","的","怎么","独立","并发","了","上锁","是","安全","？","优势","二级","相当于","它","之间","保证","技术","zegment","就是","降低","segment","线程","表","粒度","分段","，","操作","实现","读写","当于","搞笑","一个","锁","阻塞","concurrenthashmap","如何","一把","同时","让","效率"],"title":"什么是ConcurrentHashMap？","title_tokens":["concurrenthashmap","？","什么","是"]},{"location":"algorithm/#putget","text":"get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash","text_tokens":["get","均匀分布","计算","1","方法","元素","进行","结束","+","所有","定位","中","entry","超过","分布","是否",",","数组","累加","上","size","hash","原理","阈值","体位","重入","put","具体位置","则","输入","修改","做","时","运算",".","或者","一次","对象","覆盖","没有","实现","中有","一个","concurrenthashmap","起来","值","通过","遍历","插入","数量","得到","的","了","在","把","总","将","segment","如果","均匀","，","释放","锁","对","到","次数","尝试","具体","位置"," ","为了","可","每","不是","再","获取","两次","大于","key","重新","说明","过程","3","加锁","统计"],"title":"put和get原理","title_tokens":["put","get","和","原理"]},{"location":"algorithm/#_3","text":"","text_tokens":[],"title":"红黑树  （数据结构）","title_tokens":["结构","（","红黑树"," ","数据","）","数据结构"]},{"location":"algorithm/#_4","text":"1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树","text_tokens":["解决","1","右","均","2","打折扣","方法","结束","等于","是","？","所有","思想","找","10","利用","二叉","例","从根","左子","变成","如下","几乎","左右","如何","11","相同","二分","打折",".","或者","开始","高度","大打折扣","二叉树","4","5","孩子","最大","值","由于","树","插入","左","线性","查找","13","的","了","8","右子","走到","缺点","根","小于","子树","9","，","平衡","依次","也","次数","折扣","节点"," ","分别","不","6","红黑树","它","排序","就","性能","大于","这种","：","为","、","3"],"title":"二叉树的特性","title_tokens":["的","特性","二叉树","二叉"]},{"location":"algorithm/#_5","text":"节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。","text_tokens":["数目","。","从","节点"," ","都","每个","有","的","是","相同","任一","所有","子","叶子",")","或者","根","null","空","不能","(","两个","路径","到","红色","包含","黑色","连续"],"title":"红黑树特性","title_tokens":["特性","红黑树"]},{"location":"algorithm/#_6","text":"","text_tokens":[],"title":"调整红黑树的两种方法（变色、旋转）","title_tokens":["的","变色","、","（","旋转","红黑树","调整","）","两种","方法"]},{"location":"algorithm/#aes","text":"MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。","text_tokens":["。","一致性","完整性","和","被","进行","的","作用","不","是","私密","保证","泄漏","md5","算法","完整","sha256","摘要","校验","加密","对称","可逆","，","属于","主要","对","一致","信息","加密算法"],"title":"AES算法（对称加密算法）","title_tokens":["算法","（","）","加密","aes","对称","加密算法"]},{"location":"algorithm/#_7","text":"密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。","text_tokens":["成一","缺少","二块","需要","拆分","1","计算","2","最高","体现","一个个","进行","c","feedback","算器","ecb","等于","是","？","要求","分成","aes128","思想","说","第二","大家","后","方式","例","d","拆","算法","整个","最终","中","语言","cipher","128","主体","计算器","aes","整数","一股","有个","g","256",",","且","一起","aes192","。",":","字符","模式","加密算法","上","实际","字节","成","）","链接","安全性","数倍","位","经过","提供","五种","ofb","电码本","则","必须","某种","（","许多","相同","只有","密钥","一段","个","差别","密文","做","时","之间","codebook","并","补全","工作","ctr","平时","其它","e","加密","相应","这个","默认","16","7","密码","输出","a","中有","一个","少于","4","5","用","电码","有些","128bit","pkcs5padding","补足","值","任何","}","aes256","192bit","从","b","数量","注意","同样","采用","每个","iso126padding","的","独立","了","最好","安全","在","典型","把","这些","8","nopadding","近似","随机","问题","就是","拼接","而是","三种","如果","最后","复杂","(","，","数","时候","counter","cfb","生成","对","铭文","也","整数倍"," ","几种","解密","outputfeedback","不","加入","支持","结果","但是","6","cbc","使用","不是","理过","长度","处理","{","block",")","明文","\\","尾端","处理过程","就","什么","末尾","细节","book","性能","chaining","：","反馈","分组","码本","加密器","块","不同","轮数","192","为","#","一股脑","不足","、","过程","64bit","个个","整段","可能","electronic","填充","3","第二块"],"title":"三个基本概念（密钥、填充、模式）","title_tokens":["概念","三个","基本概念","、","（","密钥","填充","）","基本","模式"]},{"location":"algorithm/#java","text":"注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。","text_tokens":["。","上","原本","外","真正","注意","字节","解密","都","数倍","的","额外","除了","使用","不是","密钥","nopadding","时","调用","长度","并","方式","明文","用于","算法","种子","就是","会","而是","：","key","其它","如果","aes","整数","16","块","，","加解密","好","封装","生成","填充","整数倍","一组","表面"],"title":"在java中的具体实现","title_tokens":["的","具体","实现","在","中","java"]},{"location":"algorithm/#aes_1","text":"一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey）","text_tokens":["需要","1","0","255","有","n","final","？","addroundkey","aes128","10","行","四个","最终","对应","如下","aes",",","两个","移位","aes192","。","十六进制","~","多少","字节","成","）","论","位","经过","很多","阶段","进制","（","只有","密钥","密文","加轮","12","由","一次","加密","三个","一个","普通","subbytes","十六","aes256","ff","列","的","把","轮","代替","round","》","而是","14","(","表示","，","shiftrows","也","具体","00","rounds","步骤"," ","可","混淆","刚好","initial","不是","长度","处理",")","明文","mixcolumns","初始","key","：","次","不同","轮数","各种","除去"],"title":"AES算法的底层原理","title_tokens":["的","算法","原理","底层","aes"]},{"location":"algorithm/#subbyte","text":"十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11]","text_tokens":["。","数组","s","盒","16x16","十六","依据","步骤","例如"," ","被","]","字节","b","两位","都","2","排列","那么","每","位","的","常量","subtitution","=","11","在","是","[","另外","进制","排列成","把","处理",")","明文","就是","中","替代","二位","第一个","4x4","(","块","box","列成","，","换成","二维","大小","a","5b","输出","一个",",","5","第一","替换成","值","替换","通过","十六进制"],"title":"字节替代 subByte","title_tokens":[" ","subbyte","字节","替代"]},{"location":"algorithm/#shiftrows","text":"如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节","text_tokens":["如图"," ","第二行","字节","第三","循环","第三行","第二","四行","第四行","不变","：","左移","三个","二行","第一行","一个","两个","第一","一行","三行","第四"],"title":"行移位 shiftRows","title_tokens":["行","移位"," ","shiftrows"]},{"location":"algorithm/#mixcolumns","text":"输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列","text_tokens":["数组","要","和"," ","得到","每","matrix","列","的","一列","常量","输入","做",")","明文","对应","fix","二位","矩阵","(","，","输出","一个","修补","相乘"],"title":"列混淆MixColumns","title_tokens":["混淆","列","mixcolumns"]},{"location":"algorithm/#add-round-key","text":"128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。","text_tokens":["异或","175","用到","1","计算","0","i","都","2","元素","等同","赋值","是","+","所有","15","32","10","对应","最终","中","4x4","aes","而",",","。","数组","31","字节","）","一直","与","输入","[","（","密钥","做","-","用于","一轮","由","j","一次","加密","第","16","输出","a","一个","4","keyexpentions","用","128bit","*","代码","值","存储","扩展","}","b","被","同样","排列","的","47","了","排列成","轮","(","，","生成","到","当中","同于","位置"," ","]","来","和","每","原始","等同于","长度","w","处理","{",")","......","就","初始","源代码","后续","完成","矩阵","160","列成","不同","为","直到","k"],"title":"加 论密钥(add round key)","title_tokens":["round","加","add"," ","密钥","key","论","(",")"]},{"location":"algorithm/#_8","text":"所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度","text_tokens":["复杂度","异或","所","electronoc","1","并行","计算","不如","iv","都","2","体现","利于","ecb","完全","是","优点","所有","引入","initialization","只","较差","这样","cipher","变成","aes","有点","出","ecb2",",","chainning","让","显然","模式","。",":","上","并行计算","宏观","互不","成","防止","安全性","更高","干涉","经过","与","前会","相同","差别","密文","之间","做","codebook","作为","互不干涉",".","工作","会","第一个","加密","操作","一个","vector","有点像","第一","值","增加","同样","向量","前","的","概念","独立","简单","了","作用","加盐","一样","在","安全","无法","即","有利于","最","缺点","md5","(","复杂","内部","，","流程"," ","和","每","不","cbc","处理","block",")","明文","参与","初始","book","性能","：","初始化","后续","有利","加密器","块","关联"],"title":"不同工作模式在加密流程中有什么不同？","title_tokens":["不同","流程","工作","中有","在","什么","？","加密","模式"]},{"location":"algorithm/#md5","text":"可以从任意长度的明文字符串生成128位的哈希值","text_tokens":["的","明文","字符","任意","从","字符串","生成","可以","128","哈希","长度","位","值"],"title":"MD5","title_tokens":["md5"]},{"location":"algorithm/#_9","text":"1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制","text_tokens":["接收","知道","sign","1","需要","收集","2","三步","是","？","既","_","32","只","利用","过去","后","对比","算法","是因为","128","1234","字符串","两个","约定","同时","如何","无误","十六进制","。","这里","字符",":","带上","上","hash","acount","成","位","参数值","则","=","amout","数值","进制","除了","相同","密钥","时","攻击者","支付","按照","做","直接","规则","abcd","三方",".","限制","验证","账户","本身","一个","4","名","5","只能","最大","起来","*","值","通过","之所以","又","十六","从","平台","业务","相关","金额","的","了","在","把","第三方","md5","就是","比如","拼接","传输","如果","签名","，","篡改","时候","生成","到","也","双方","坏人"," ","和","来","参数","所以","ade876ishdfakhdj","第三","基本","攻击","发送","不","原文","请求","目标","参与","二进制","因为","key","带","不同","给定","可能","信息","哈希","3"],"title":"验签过程","title_tokens":["过程","验签"]},{"location":"algorithm/#md5_1","text":"分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c","text_tokens":["所","字","一位","主","s","用到","1","计算","需要","0","图中","/","交替","之后","可以","都","分为","i","2","方法","进行","有","n","c","二个","不断","假设","命名","等于","？","是","+","分成","32","首先","第二","^","后","四个","第四个","d","绿色","0x76543210","求余","这样","中","向","128","如下","m","非线性","整数","原","产生","m16","g","h",",","张图","第二个","这","呢","记录","让","0x89abcdef","水线","十六进制","。","0x01234567","使得","~","单次","之一","黄色","第一位","多少","512","）","共","数倍","位","经过","0xfedcba98","”","=","进制","（","值补","原先","按照","-","意思","abcd","z",".","次子","由","流水线","四步","一次","会","m15","第一个","相加","<","16","三个","a","初始值","一个","4","函数","5","四种","用","第一","量值","其余","新","*","一组","值","包含","第四","真正","十六","下图","b","代表","线性","得到","每个","所用","的","一等","简单","了","在","把","子","田","ki","旧","取代","m0","448","最","md5","mi","就是","64","拼接","流水","很","完后","如果","最后","(","复杂","左移","，","流程","等份","组","加工","对","到","设置","剩余","整数倍","也","次数","组是","一步","一共","位置","演变","mj"," ","单","“","官方","和","|","每","决定","上面","第三","循环","常量","不","结果","原文","使用","x","m1","长度","处理","再",")","bit","归纳","二进制","初始","就","实践","&","：","分组","第一步","y","次","f","田字","不同","为","第三个","、","下面","份","填充","信息","哈希","表达","3","红色"],"title":"MD5底层原理","title_tokens":["原理","md5","底层"]},{"location":"algorithm/#base64","text":"","text_tokens":[],"title":"Base64","title_tokens":["base64"]},{"location":"algorithm/#_10","text":"","text_tokens":[],"title":"排序","title_tokens":["排序"]},{"location":"algorithm/#_11","text":"","text_tokens":[],"title":"冒泡算法和优化","title_tokens":["和","冒泡","优化","算法"]},{"location":"basic/","text":"'this is about me page'","text_tokens":["page","this","about"," ","is","me","'"],"title":"Basic","title_tokens":["basic"]},{"location":"contact/","text":"'hey guys! this is contact me page'","text_tokens":["!","page","this","contact"," ","is","me","hey","guys","'"],"title":"Contact","title_tokens":["contact"]},{"location":"garbage/","text":"jvm内存模型 要理解gc必须理解jvm，jvm主要管理两种内存：堆非堆 堆(Heap Memory)：类实例和数组的内存 非堆(No-heap Memory)：方法区，类结构（运行时常数池，字段和方法），类加载信息 GC主要回收的内存是堆内存 堆内存模型 1. 堆内存分两块，新生代和老年代，比例(1:2) * 老年代主要存放应用程序中生命周期较长的的存活对象 2. 新生代分三个部分，一个eden区和两个survivor区，比例8：1：1 * eden区存放新生的对象 * survivor区存放每次垃圾回收后存活的对象 可回收对象的判定 什么样的对象是垃圾？ 1. 引用计数算法 原理就是给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1， 当引用失效时，计数值就减1，计数器为0的对象就是不在被使用的。 * 简单、高效（objectiveC用的该算法） * 很难处理循环引用（相互引用两个对象） 可达性分析算法 为了解决循环引用，java采用新的算法 从GC的ROOT作为起点，向下搜索它们引用的对象，可生成一棵引用树，树的节点可视为可达对象，反之视为不可达 如何定义GC root,java语言定义如下GC-ROOT对象 * 虚拟机栈中引用的对象 * 方法区中静态属性引用的对象 * 方法区中常量引用的对象 * 本地方法栈中jni引用的对象 ## stop the world 垃圾回收时需要整个引用状态保持不变，否则判定是垃圾，等会就不是了，GC的时候所有的程序执行处于暂停的状态，卡住，这种卡顿非常短，对程序的影响微乎其微，GC的卡顿由此而来。 几种垃圾回收算法 如何回收？Java虚拟机采用的是分代回收算法，想要理解分代回收算法，有必要先了解其它几种简单算法 1. 标记清楚算法(Mark-Sweep) 标记阶段：标记所有需要被回收的对象 清楚阶段：回收被标记对象占用的空间 * 简单，容易实现 * 容易产生内存碎片，碎片太多可能导致后续需要为大对象分配空间无法找到足够的空间，提前触发新的一次垃圾收集动作。 复制算法（Copying） 将内存分为大小相同的两块，每次只使用其中的一块，当这一块用完了，将还活着的对象复制到另外一块，再把已使用的一块一次清理掉，这样就不会出现内存碎片问题， * 简单，高效 * 对内存空间的使用付出了高昂的代价，可 使用内存缩少到了原来的一半 Copying算法的效率取决于活着的对象，活着的对象越多copying越多，效率越慢 标记整理算法（Mark-compact） 标记阶段和Mark-sweep一样，标记出需要被回收的对象，完成标记后，将存活的对象向一端移动，清理掉端边界以外的内存 * 适用于存活对象多，回收对象少的情况 分代回收算法 不是一种新的算法而是复制算法和标记整理算法的整合 复制算法：适用于存活对象少，回收对象多 标记整理算法：适用于存活对象多，回收对象少 堆内存分为老年代(Old generation)和新生代(young Generation),老年代的特点是每次垃圾收集时只有少量的对象需要被回收，新生代的特点是每次垃圾回收时都有大量的对象需要被回收，根据不同代的特点采用不同的算法，这就是分代算法。 详细分析 1. 对于新生代采用Copying算法，因为新生代每次垃圾回收的时候都要回收大部分对象，也就是说需要复制的存活的对象较少，所以采用Copying算法的效率最高，实际中并不是按照上面Copying算法中说的1：1分成相等的两块，而是将新生代分为eden空间和survivor空间8：1：1 2. 由于老年代每次只回收少量对象，一般使用Mark-compact算法 QA1.为什么需要两块Survivor空间？ 这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次GC的时候，我们可以把Eden区的存活对象放到Survivor A空间，但是第二次GC的时候，Survivor A空间的存活对象也需要再次用Copying算法，放到Survivor B空间上，而把刚刚的Survivor A空间和Eden空间清除。第三次GC时，又把Survivor B空间的存活对象复制到Survivor A空间，如此反复。 所以，这里就需要两块Survivor空间来回倒腾。 QA2.为什么EDEN空间这么大而Survivor空间这么小？ 新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。 我看8：1：1就挺好的，当然这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。 新的问题又来了，从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？直接放到老年代去。 Eden空间和两块Survivor空间的工作流程？ 现在假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。 // 分配了一个又一个对象 放到Eden区 // 不好，Eden区满了，只能GC(新生代GC：Minor GC)了 把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的） // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区 // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区 // ... // 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区 // 有的对象太大，超过了Eden区，直接被分配在Old区 // 有的存活对象，放不下Survivor区，也被分配到Old区 // ... // 在某次Minor GC的过程中突然发现： // 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC) Old区慢慢的整理一番，空间又够了 // 继续Minor GC // ... // ... 通过日志分析GC类型 GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。 GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。 GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。 GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。","text_tokens":["区","1","compact","复制","参考","看","进行","怎么","是","分成","_","本地","第二","qa2","minor","够","两块","出现","继续","还","大小","回收","这","部分","属性","努力","足够","倒腾","qa1","虚拟","区中","（","只有","-","一定量","特点","sigusr1","结构","会","非常","其它","涉及","这个","细分","给","实现","a","mark","信号","vmruntime","常数","经历","第一","动作","树","通过","合理","##","栈中","日志","系统","三块","程序","一块","减","当","将","8","第一次","它们","缺点","标记","表示","流程","时候","卡住","高昂","非堆","太","我们","虚拟机"," ","为了","几种","每当","较","上面","仅供参考","老","转移","不下","反复","一端","因为","起点","完成","管理","必要","计数","可达","过程","供参考","信息","池","/","都","最高","临时","以外","也就是说","该","能","暂停","大","15","于","整个","提高","语言","如下","内存空间","major","root","缓解","好","两个","如何","活着","达到","原来","计","内存不足","类型","容易","必须","数值","阶段","相等","呆","新生代","缩少","判定","时","调用","快要","卡顿","新创",".","工作","或者","刚刚","一次","对象","发现","详细","计数器","操作","现在","高效","java","新","某次","我","异常","绝大","使用率","被","程序执行","其中","字段","对于","由此","这些","周期","实例","存放","survivor","world","一番","两种","就是","比如","模型","generation","空","了解","释放","什么样","很难","生成","对","before","保持","清空","也","往","the","所以","循环","常量","不","相互","定量","另外","但是","使用","视为","越慢","处理",")","不变","不可","这是","等","年代","objectivec","不同","sweep","主要","变量","来回","满","explicit","调整","提前","concurrent","生命","解决","本来","需要","收集","2","老生","多","比例","所有","只","for","创建","地方","超过","向","而","就加",",","malloc","频繁",":","数组","上","实际","状态","）","类","二次","存活","相同","如此","按照","移到","假定","作为","空间","局部变量","微乎其微","三次","一般","应用程序","大部分","一个","只能","准备","应该","system","大部","堆","大大提高","从","根据","不好","突然","一样","在","用率","适用","分配","整理","接口","分析","而来","不会","而是","很","中说","memory","(","移动","一半","代","静态","引用","一种","触发","收到","大大","理解","young","节点","要","jni","小","为什么","一棵","应用","第三","仅供","old","局部","越多","不是","清楚","再","...","尤其","想要","不够","这种","添加","后续","怎么办","导致","次","内存","少","不足","清除","可能","运行","no","0","可以","挺","清理","分","绝大部分","分为","方法","有","复制到","边界","马上","？","放到","不过","后","算法","中","这样","详细分析","这么","执行","copy","达","产生","出","往往","付出","当然","情况","。","这里","原理","第三次","下来","由此而来","失效","放不下","已","就是说","大而","代价","区满","直接","并","gc","去","copying","大量","oom","三个","可回收","自动","用","然后","*","新生","由于","反之","又","完","b","先","放在","采用","的","包括","简单","了","短","无法","找到","之前","否则","把","heap","问题","慢慢","一定","jvm","碎片","eden","最后","，","第二次","较长","到","生命周期","抛","设置","每次","加载","效率","影响","取决","分代","和","来","搜索","可","可达性","定义","新创建","它","掉","整合","就","什么","垃圾","：","处于","再次","stop","为","少量","取决于","较大","、","向下","端","占用"],"title":"垃圾回收机制","title_tokens":["回收","垃圾","机制"]},{"location":"garbage/#jvm","text":"要理解gc必须理解jvm，jvm主要管理两种内存：堆非堆 堆(Heap Memory)：类实例和数组的内存 非堆(No-heap Memory)：方法区，类结构（运行时常数池，字段和方法），类加载信息 GC主要回收的内存是堆内存","text_tokens":["堆","no","数组","区","池","理解","要"," ","和","）","类","方法","的","字段","必须","是","（","heap","实例","时","-","两种",")","gc","结构","jvm","：","管理","memory","(","内存","，","主要","回收","常数","信息","非堆","加载","运行"],"title":"jvm内存模型","title_tokens":["内存","模型","jvm"]},{"location":"garbage/#_1","text":"1. 堆内存分两块，新生代和老年代，比例(1:2) * 老年代主要存放应用程序中生命周期较长的的存活对象 2. 新生代分三个部分，一个eden区和两个survivor区，比例8：1：1 * eden区存放新生的对象 * survivor区存放每次垃圾回收后存活的对象","text_tokens":["堆",":","部分","生命","区","1"," ","和","分","2","应用","的","存活","程序","老","比例","新生代","8","周期","存放","survivor","后",")",".","两块","中","垃圾","对象","：","年代","eden","(","应用程序","内存","，","三个","主要","一个","回收","两个","较长","生命周期","每次","*","新生"],"title":"堆内存模型","title_tokens":["堆","内存","模型"]},{"location":"garbage/#_2","text":"什么样的对象是垃圾？ 1. 引用计数算法 原理就是给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1， 当引用失效时，计数值就减1，计数器为0的对象就是不在被使用的。 * 简单、高效（objectiveC用的该算法） * 很难处理循环引用（相互引用两个对象） 可达性分析算法 为了解决循环引用，java采用新的算法 从GC的ROOT作为起点，向下搜索它们引用的对象，可生成一棵引用树，树的节点可视为可达对象，反之视为不可达 如何定义GC root,java语言定义如下GC-ROOT对象 * 虚拟机栈中引用的对象 * 方法区中静态属性引用的对象 * 方法区中常量引用的对象 * 本地方法栈中jni引用的对象 ## stop the world 垃圾回收时需要整个引用状态保持不变，否则判定是垃圾，等会就不是了，GC的时候所有的程序执行处于暂停的状态，卡住，这种卡顿非常短，对程序的影响微乎其微，GC的卡顿由此而来。","text_tokens":["解决","1","需要","0","方法","有","是","？","该","所有","暂停","本地","地方","算法","整个","语言","执行","如下","达","就加","root",",","回收","两个","如何","。","属性","状态","计","原理","）","由此而来","失效","虚拟","数值","区中","（","判定","时","-","作为","卡顿",".","gc","微乎其微","对象","会","非常","计数器","给","一个","用","高效","java","新","*","树","反之","从","##","栈中","被","程序执行","采用","的","简单","了","短","程序","在","由此","减","否则","当","world","它们","就是","分析","而来","，","什么样","时候","卡住","很难","生成","静态","对","保持","引用","影响","虚拟机","节点","the"," ","为了","jni","搜索","每当","可","一棵","循环","可达性","常量","不","相互","定义","使用","视为","不是","它","处理","不变","不可","就","什么","垃圾","这种","起点","处于","添加","等","stop","objectivec","为","计数","、","可达","向下"],"title":"可回收对象的判定","title_tokens":["的","回收","可回收","对象","判定"]},{"location":"garbage/#_3","text":"如何回收？Java虚拟机采用的是分代回收算法，想要理解分代回收算法，有必要先了解其它几种简单算法 1. 标记清楚算法(Mark-Sweep) 标记阶段：标记所有需要被回收的对象 清楚阶段：回收被标记对象占用的空间 * 简单，容易实现 * 容易产生内存碎片，碎片太多可能导致后续需要为大对象分配空间无法找到足够的空间，提前触发新的一次垃圾收集动作。 复制算法（Copying） 将内存分为大小相同的两块，每次只使用其中的一块，当这一块用完了，将还活着的对象复制到另外一块，再把已使用的一块一次清理掉，这样就不会出现内存碎片问题， * 简单，高效 * 对内存空间的使用付出了高昂的代价，可 使用内存缩少到了原来的一半 Copying算法的效率取决于活着的对象，活着的对象越多copying越多，效率越慢 标记整理算法（Mark-compact） 标记阶段和Mark-sweep一样，标记出需要被回收的对象，完成标记后，将存活的对象向一端移动，清理掉端边界以外的内存 * 适用于存活对象多，回收对象少的情况 分代回收算法 不是一种新的算法而是复制算法和标记整理算法的整合 复制算法：适用于存活对象少，回收对象多 标记整理算法：适用于存活对象多，回收对象少 堆内存分为老年代(Old generation)和新生代(young Generation),老年代的特点是每次垃圾收集时只有少量的对象需要被回收，新生代的特点是每次垃圾回收时都有大量的对象需要被回收，根据不同代的特点采用不同的算法，这就是分代算法。 详细分析 1. 对于新生代采用Copying算法，因为新生代每次垃圾回收的时候都要回收大部分对象，也就是说需要复制的存活的对象较少，所以采用Copying算法的效率最高，实际中并不是按照上面Copying算法中说的1：1分成相等的两块，而是将新生代分为eden空间和survivor空间8：1：1 2. 由于老年代每次只回收少量对象，一般使用Mark-compact算法 QA1.为什么需要两块Survivor空间？ 这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次GC的时候，我们可以把Eden区的存活对象放到Survivor A空间，但是第二次GC的时候，Survivor A空间的存活对象也需要再次用Copying算法，放到Survivor B空间上，而把刚刚的Survivor A空间和Eden空间清除。第三次GC时，又把Survivor B空间的存活对象复制到Survivor A空间，如此反复。 所以，这里就需要两块Survivor空间来回倒腾。 QA2.为什么EDEN空间这么大而Survivor空间这么小？ 新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。 我看8：1：1就挺好的，当然这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。 新的问题又来了，从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？直接放到老年代去。 Eden空间和两块Survivor空间的工作流程？ 现在假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。 // 分配了一个又一个对象 放到Eden区 // 不好，Eden区满了，只能GC(新生代GC：Minor GC)了 把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的） // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区 // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区 // ... // 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区 // 有的对象太大，超过了Eden区，直接被分配在Old区 // 有的存活对象，放不下Survivor区，也被分配到Old区 // ... // 在某次Minor GC的过程中突然发现： // 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC) Old区慢慢的整理一番，空间又够了 // 继续Minor GC // ... // ...","text_tokens":["区","1","compact","复制","参考","看","怎么","是","分成","第二","qa2","minor","够","两块","出现","继续","还","大小","回收","这","部分","足够","倒腾","qa1","虚拟","（","只有","-","特点","其它","涉及","这个","细分","实现","a","mark","经历","第一","动作","合理","三块","一块","当","将","8","第一次","缺点","标记","流程","时候","高昂","太","我们","虚拟机"," ","几种","较","上面","仅供参考","老","转移","不下","反复","一端","因为","完成","必要","过程","供参考","/","都","最高","临时","以外","也就是说","能","大","15","于","提高","内存空间","major","缓解","好","如何","活着","原来","容易","阶段","相等","呆","缩少","新生代","时","新创",".","工作","或者","刚刚","一次","对象","发现","详细","现在","java","高效","新","某次","我","绝大","使用率","被","其中","对于","这些","周期","survivor","一番","就是","比如","generation","空","了解","对","清空","也","往","所以","不","另外","但是","使用","越慢",")","这是","年代","不同","sweep","满","变量","来回","调整","提前","本来","需要","收集","2","老生","多","比例","所有","只","创建","超过","向","而",",","频繁","上","实际","）","二次","存活","相同","如此","按照","移到","假定","空间","局部变量","三次","一般","大部分","一个","只能","应该","大部","堆","大大提高","从","根据","不好","突然","一样","在","用率","适用","分配","整理","不会","分析","很","而是","中说","(","移动","一半","代","一种","触发","大大","理解","young","要","小","为什么","第三","仅供","old","局部","越多","不是","清楚","再","...","尤其","想要","不够","后续","怎么办","导致","次","内存","少","清除","可能","可以","挺","清理","绝大部分","分为","有","复制到","边界","马上","？","放到","不过","后","算法","这样","中","详细分析","这么","copy","产生","出","往往","付出","当然","情况","。","这里","第三次","下来","放不下","已","就是说","大而","代价","区满","直接","并","gc","去","copying","大量","用","然后","*","新生","由于","又","完","b","先","放在","采用","的","包括","简单","找到","无法","了","把","问题","慢慢","碎片","eden","，","第二次","到","设置","每次","效率","取决","分代","和","来","可","新创建","掉","整合","就","什么","垃圾","：","再次","为","少量","取决于","较大","端","占用"],"title":"几种垃圾回收算法","title_tokens":["回收","几种","算法","垃圾"]},{"location":"garbage/#gc","text":"GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。 GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。 GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。 GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。","text_tokens":[":","堆","。","达到","上","理解","努力","可以","内存不足"," ","来","系统","应用","进行","的","收到","之前","程序","在","是","定量","当","_","时","调用","分配","一定量","for","快要","gc",".","sigusr1","或者","接口","一定","对象","会","异常","最后","而","oom","应用程序","表示","内存","，","为","操作","满","释放","时候","explicit","不足","malloc","、","自动","vmruntime","信号","before","准备","抛","system","触发","我们","concurrent"],"title":"通过日志分析GC类型","title_tokens":["gc","分析","类型","日志","通过"]},{"location":"knowledge/","text":"","text_tokens":[],"title":"Knowledge","title_tokens":["knowledge"]},{"location":"kotuis/","text":"introduce why kotlin? concise safe interoperable","text_tokens":["?","why","introduce","safe"," ","kotlin","concise","interoperable"],"title":"学习笔记","title_tokens":["学习","笔记"]},{"location":"kotuis/#introduce","text":"why kotlin? concise safe interoperable","text_tokens":["?","why","safe"," ","concise","kotlin","interoperable"],"title":"introduce","title_tokens":["introduce"]},{"location":"main/","text":"由于语法众多，因此将 大部分语法 汇总在下面表格里，便于一览。 但该表并未涵盖全部语法(如某些特殊符号) ，因此详情请翻看语法的具体章节。 符号 用途 # 标题 空行 段落 > 引用 [^sth] 脚注 !!! 注解 ??? 折叠注解 \\ 转义 * 列表 + 列表 - 列表 *[x] 任务列表 +[x] 任务列表 -[x] 任务列表 --- 分割线 :shortname: emoji ` 行内代码 ```语言 代码块,带高亮 TAB 代码块 #! 代码高亮 ::: 代码高亮 *sth* 斜体 _sth_ 斜体 **sth** 粗体 __sth__ 粗体 ***sth*** 粗斜体 ___sth___ 粗斜体 \\^sth\\^ 上标 \\~sth\\~ 下标 \\^\\^sth\\^\\^ 文字下划线 \\~\\~sth\\~\\~ 文字中横线 {++sth++} 文字下划线,绿色背景高亮 {--sth--} 文字中横线,红色背景高亮 {\\~\\~false\\~>true\\~\\~} 文字下划线接文字横线,绿接红背景高亮 {>>sth<<} 表示注解,灰色背景高亮 \\=\\=sth\\=\\= 黄色背景高亮 {\\=\\=sth\\=\\=} 黄色背景高亮 \\$sth$ 行内式数学公式 \\(sth)\\ 行内式数学公式 \\$\\$...$$ 区块式数学公式 \\begin{}...\\end{} 区块式数学公式 [text](url \"title\") 行内式链接 [text][index],文档最后[index]: url \"title\" 参考式链接 符合要求的URL 自动链接 ![alt](url \"title\") 行内式图片 ![alt][index],文档最后[index]: url \"title\" 参考式图片","text_tokens":["里","详情","---","下划","alt","参考","!","粗体","一览","+","要求","_","全部","^","绿色","高亮","中","语言","文档","false","数学公式",",","如","sth","空行","~","。","部分",":","黄色","begin","`","用途","涵盖","链接","表格","=","[","\"","语法","接","emoji","-","符合要求","end","标题","url","下标","<","符号","?","该表","++","割线","并未","众多","大部分","自动","划线","代码","*","由于","折叠","大部","分割线","}","转义","title","图片","因此","特殊","任务","text","红","的","翻看","在","斜体","式","灰色","将","index","列表","段落","分割","便于","最后","(","true","表示","，","行内","粗","shortname","引用","区块","章节","具体","上标"," ","]","横线","数学","注解","公式","--","文字",">","x","...","{","tab","符合",")","脚注","\\","___","带高亮","绿接","但","特殊符号","__","汇总","块","详情请","#","$","某些","下面","下划线","背景","红色"],"title":"main","title_tokens":["main"]},{"location":"show_money/","text":"云收银APP阅读文档 SplashActicity 1.initUmeng+initSunmiBlePrint 2.延时3s一个handler来决定接下来进入哪个页面（括号里面是条件）  进入GuidActivity(判断sp版本号跟配置文件版本号是否一致，进入登陆页面时保存版本号)  进入MainActivity(通过logintoken判断是否进入MainActivity)  进入LoginAcitivity(else进入LoginActivity) 3.开启日志上传Service GuidActivity  一个很简单滑动的轮播图外加一个进入LoginActivity的按钮 LoginActivity  自定义EditText(主要功能有：清除图标，EditText抖动动画)  重置密码  登陆（包含获取公钥接口+登陆接口）   1.对于登陆参数pwd字段的加密（RSA(pwd,publicKey)）   2.自定义Toast(YellowToastUtils密码错误顶部显示一段黄色背景提示)   3.使用Linerlayout+RelativeLayout framlayout+权重布局法  4.","text_tokens":["service","上传","登陆","1","edittext","2","页面","mainactivity","轮播","有","sp","是","+","权重","顶部","错误","framlayout","接下","文档","3s","配置文件","自定","logintoken","是否","initumeng",",","linerlayout","功能","一致","重置","黄色","阅读","）","下来","按钮","提示","（","一段","保存","自定义","时","布局","loginacitivity","版本号","guidactivity",".","里面","开启","条件","加密","splashacticity","滑动","rsa","密码","app","图","一个","4","进入","公钥","包含","通过","法","判断","toast","哪个","日志","括号","的","字段","简单","对于","版本","relativelayout","跟","yellowtoastutils","显示","接口","收银","很","handler","(","，"," ","else","publickey","文件"," ","来","参数","决定","延时","loginactivity","定义","pwd","使用","抖动","外加","动画",")","接下来","获取","initsunmibleprint","图标","：","云","配置","主要","清除","背景","3"],"title":"2. 云收银","title_tokens":[".","收银"," ","2","云"]},{"location":"show_money/#app","text":"SplashActicity 1.initUmeng+initSunmiBlePrint 2.延时3s一个handler来决定接下来进入哪个页面（括号里面是条件）  进入GuidActivity(判断sp版本号跟配置文件版本号是否一致，进入登陆页面时保存版本号)  进入MainActivity(通过logintoken判断是否进入MainActivity)  进入LoginAcitivity(else进入LoginActivity) 3.开启日志上传Service GuidActivity  一个很简单滑动的轮播图外加一个进入LoginActivity的按钮 LoginActivity  自定义EditText(主要功能有：清除图标，EditText抖动动画)  重置密码  登陆（包含获取公钥接口+登陆接口）   1.对于登陆参数pwd字段的加密（RSA(pwd,publicKey)）   2.自定义Toast(YellowToastUtils密码错误顶部显示一段黄色背景提示)   3.使用Linerlayout+RelativeLayout framlayout+权重布局法  4.","text_tokens":["service","上传","登陆","1","edittext","2","页面","mainactivity","轮播","有","sp","是","+","权重","顶部","错误","framlayout","接下","3s","配置文件","自定","logintoken","是否","initumeng",",","linerlayout","功能","一致","重置","黄色","）","下来","按钮","提示","（","一段","保存","自定义","时","布局","loginacitivity","版本号","guidactivity",".","里面","开启","条件","加密","splashacticity","滑动","rsa","密码","图","一个","4","进入","公钥","包含","通过","法","判断","toast","哪个","日志","括号","的","字段","简单","对于","版本","relativelayout","跟","yellowtoastutils","显示","接口","很","handler","(","，"," ","else","publickey","文件"," ","来","参数","决定","延时","loginactivity","定义","pwd","使用","抖动","外加","动画",")","接下来","获取","initsunmibleprint","图标","：","配置","主要","清除","背景","3"],"title":"云收银APP阅读文档","title_tokens":["阅读","app","收银","文档","云"]},{"location":"syntax/code_block/","text":"4个空格 在每行前面加上4个空格 text = \"Hello, world!\" print text 效果 text = \"Hello, world!\" print text 3个 ` ```text text = \"Hello, world!\" print text ``` 效果 text = \"Hello, world!\" print text 注1: 支持代码高亮 ，详见\" 区块代码高亮 \" 注2: 如果代码区块上方是列表，如 无序列表 或 有序列表 ，那么4个空格不会被解析为代码区块，而是被解析为一个普通缩进","text_tokens":[":","`","每行","1"," ","被","加上","hello","2","text","那么","有","!","=","上方","在","支持","\"","是","个","列表","world","序列表","解析","空格","效果","高亮","序列","不会","而是","前面","详见","如果","缩进","注","，","为","一个","4",",","如","区块","普通","print","3","无序","代码","或"],"title":"Code block","title_tokens":[" ","code","block"]},{"location":"syntax/code_block/#4","text":"在每行前面加上4个空格 text = \"Hello, world!\" print text 效果 text = \"Hello, world!\" print text","text_tokens":["!","world","空格","=","效果","在","每行","4","\"",","," ","前面","个","加上","hello","print","text"],"title":"4个空格","title_tokens":["个","4","空格"]},{"location":"syntax/code_block/#3","text":"```text text = \"Hello, world!\" print text ``` 效果 text = \"Hello, world!\" print text 注1: 支持代码高亮 ，详见\" 区块代码高亮 \" 注2: 如果代码区块上方是列表，如 无序列表 或 有序列表 ，那么4个空格不会被解析为代码区块，而是被解析为一个普通缩进","text_tokens":[":","`","1"," ","被","hello","2","那么","text","有","!","=","上方","支持","\"","是","个","列表","world","序列表","解析","空格","效果","高亮","序列","不会","而是","详见","如果","缩进","注","，","为","一个",",","如","4","普通","print","区块","无序","代码","或"],"title":"3个 `","title_tokens":[" ","个","3","`"]},{"location":"syntax/code_highlight/","text":"高亮部分详见 代码高亮 章节","text_tokens":["部分","高亮"," ","详见","代码","章节"],"title":"Code highlight","title_tokens":[" ","highlight","code"]},{"location":"syntax/code_inline/","text":"在一行内要标记的文本前后各加一个 ` AAA`BBB`CCC 效果： AAA BBB CCC 注: 支持代码高亮 ，详见\" 行内代码高亮 \"","text_tokens":[":","前后","`"," ","bbb","的","在","支持","\"","效果","高亮","：","文本","详见","aaa","ccc","标记","注","内要","，","各加","行内","一个","一行","代码"],"title":"Code inline","title_tokens":[" ","code","inline"]},{"location":"syntax/cutline/","text":"分割线使用三个或以上 * ，也可以使用 - 和 _ ，下面仅以 - 作为示例 --- 效果","text_tokens":["分割线","---","可以"," ","和","示例","使用","_","-","作为","以上","分割","效果","，","三个","割线","下面","仅以","也","*","或"],"title":"Cutline","title_tokens":["cutline"]},{"location":"syntax/emoji_main/","text":"什么是emoji emoji是日本在无线通信中所使用的视觉情感符号，已被unicode采纳，当前unicode包含了非常多的emoji图标，每一次unicode更新都会发布新的emoji图标。只要操作系统支持unicode，就能在任意使用unicode编码的地方看到漂亮的彩色图标，比如文本、mysql表里、网页。 emoji现状 虽然unicode官网可以查到所有emoji图标，但并未提供一个便利的图标分类查询和使用方法。因此就有一些第三方emoji厂商将部分emoji图标，制作成不同格式、不同尺寸(例如64x64 PNG、128x128 PNG或SVG等格式)的图片放入自己的CDN库。然后将这些CDN图片以免费或付费方式对外提供。 如何获得emoji 根据使用需求分为2种: 不满足于unicode的emoji图标，希望更好看，并且尺寸可选，那么就使用第三方emoji厂商库，推荐使用EmojiOne的png图库，分为免费和付费，其中免费的图库已足够满足一般性使用需求，如果想使用svg，免费的只有EmojiOne-2.2.7以内版本，最新的svg都是要付费的。使用方法是在文档里用 :短名 来让mkdocs自动匹配并渲染为 标签 ??? note \"举例说明2.2.7与高版本区别\" 如果用的 :短名: 是2.2.7包含的，那么图标能正常显示，否则显示不出来 比如： https://cdn.jsdelivr.net/emojione/assets/svg/1f600.svg 这个是2.2.7就有的，访问这个url可以看到图标 https://cdn.jsdelivr.net/emojione/assets/svg/1f92e.svg 这个是2.2.7之后才有的，需要付费才能获得图标，未付费直接访问会得到报错： ![](./../../img/emoji_denied.png) https://cdn.jsdelivr.net/emojione/assets/3.1/png/64/1f92e.png 这个是png，不属于付费部分，访问这个url可以看到图标 因此推荐的最佳入门实践应当是首选png。 能够接受unicode的emoji图标，就简单了，直接将图标复制粘贴到文本里即可 这2种方法并不冲突，可以在一个markdown文本里混合使用","text_tokens":["所","里","任意","渲染","1f600","..","需要","可以","/","复制","之后","emojione","都","分为","2","cdn","看","尺寸","表里","方法","有","!","png","多","通信","采纳","是","放入","能","所有","_","unicode","虽然","匹配","混合","方式","于","免费","地方","中","文档","当前","64x64","举例说明","3.1","短名","付费","只要","这","才能","如何","让","。","部分",":","更好","以内","格式","希望","例如","成","足够","denied","提供","查询","一般性","与","以","彩色","已","mysql","\"","种","[","日本","对外","只有","编码","正常","获得","emoji","制作","-","直接","并","首选","并且","三方","svg",".","url","发布","高","一次","会","非常","一般","文本","符号","一些","7","?","这个","markdown","操作","属于","并未","选","一个","自动","用","网页","访问","入门","然后","满足","新","包含","或","https","图片","note","因此","被","mkdocs","根据","得到","系统","那么","其中","的","最新","了","简单","冲突","在","版本","现状","无线通信","否则","第三方","这些","看到","将","区别","漂亮","jsdelivr","未","64","比如","想","显示","便利","分类","1f92e","最佳","如果","(","应当","，","推荐","到","图库","厂商","接受","assets","即可","要"," ","和","更新","视觉","官网","来","]","可","每","第三","报错","出来","无线","操作系统","不","支持","自己","使用","net","能够",")","查","标签","就","什么","图标","实践","才","复制粘贴","情感","但","等","库","：","不同","为","需求","说明","128x128","、","粘贴","2.2","举例","img"],"title":"Emoji main","title_tokens":[" ","main","emoji"]},{"location":"syntax/emoji_main/#emoji","text":"emoji是日本在无线通信中所使用的视觉情感符号，已被unicode采纳，当前unicode包含了非常多的emoji图标，每一次unicode更新都会发布新的emoji图标。只要操作系统支持unicode，就能在任意使用unicode编码的地方看到漂亮的彩色图标，比如文本、mysql表里、网页。","text_tokens":["。","所","任意","被","更新","视觉","mysql","都","系统","每","表里","的","彩色","多","通信","无线","了","采纳","在","是","已","操作系统","无线通信","使用","支持","日本","能","看到","编码","漂亮","unicode","emoji","地方","发布","就","中","图标","比如","一次","会","非常","情感","文本","当前","符号","，","操作","、","只要","网页","新","包含"],"title":"什么是emoji","title_tokens":["什么","是","emoji"]},{"location":"syntax/emoji_main/#emoji_1","text":"虽然unicode官网可以查到所有emoji图标，但并未提供一个便利的图标分类查询和使用方法。因此就有一些第三方emoji厂商将部分emoji图标，制作成不同格式、不同尺寸(例如64x64 PNG、128x128 PNG或SVG等格式)的图片放入自己的CDN库。然后将这些CDN图片以免费或付费方式对外提供。","text_tokens":["。","部分","格式","图片","可以","因此","和","例如"," ","官网","成","cdn","尺寸","第三","方法","查询","的","提供","有","png","以","自己","使用","第三方","放入","所有","将","这些","对外","unicode","虽然","emoji","制作","方式",")","免费","三方","查","svg","就","图标","便利","分类","库","但","等","64x64","一些","(","不同","，","并未","128x128","一个","、","付费","到","然后","厂商","或"],"title":"emoji现状","title_tokens":["现状","emoji"]},{"location":"syntax/emoji_main/#emoji_2","text":"根据使用需求分为2种: 不满足于unicode的emoji图标，希望更好看，并且尺寸可选，那么就使用第三方emoji厂商库，推荐使用EmojiOne的png图库，分为免费和付费，其中免费的图库已足够满足一般性使用需求，如果想使用svg，免费的只有EmojiOne-2.2.7以内版本，最新的svg都是要付费的。使用方法是在文档里用 :短名 来让mkdocs自动匹配并渲染为 标签 ??? note \"举例说明2.2.7与高版本区别\" 如果用的 :短名: 是2.2.7包含的，那么图标能正常显示，否则显示不出来 比如： https://cdn.jsdelivr.net/emojione/assets/svg/1f600.svg 这个是2.2.7就有的，访问这个url可以看到图标 https://cdn.jsdelivr.net/emojione/assets/svg/1f92e.svg 这个是2.2.7之后才有的，需要付费才能获得图标，未付费直接访问会得到报错： ![](./../../img/emoji_denied.png) https://cdn.jsdelivr.net/emojione/assets/3.1/png/64/1f92e.png 这个是png，不属于付费部分，访问这个url可以看到图标 因此推荐的最佳入门实践应当是首选png。 能够接受unicode的emoji图标，就简单了，直接将图标复制粘贴到文本里即可 这2种方法并不冲突，可以在一个markdown文本里混合使用","text_tokens":["里","渲染","1f600","..","需要","可以","/","复制","之后","emojione","都","分为","看","2","cdn","尺寸","方法","有","!","png","是","能","_","unicode","匹配","混合","于","免费","文档","举例说明","3.1","短名","付费","这","才能","让",":","。","以内","更好","部分","希望","足够","denied","一般性","与","已","\"","[","种","只有","正常","获得","emoji","-","直接","并","首选","并且","三方","svg",".","url","高","会","一般","文本","这个","7","markdown","?","属于","选","一个","自动","用","访问","入门","满足","包含","https","note","因此","mkdocs","根据","得到","那么","其中","的","最新","简单","了","冲突","在","版本","否则","jsdelivr","第三方","区别","看到","未","将","64","想","显示","比如","1f92e","最佳","如果","(","应当","，","推荐","到","图库","厂商","接受","assets","即可","要"," ","和","来","]","可","第三","报错","出来","不","使用","net","能够",")","标签","就","图标","实践","才","复制粘贴","库","：","为","需求","说明","粘贴","2.2","举例","img"],"title":"如何获得emoji","title_tokens":["如何","获得","emoji"]},{"location":"syntax/emoji_principle/","text":"本文中主要介绍mkdocs依赖pymdownx.emoji进行匹配、渲染，因此下面的说明均是关于pymdownx.emoji。 pymdownx支持3个主流的emoji厂商：Gemoji（github.com做的）、EmojiOne（第三方的，分为免费版、付费版、战略合作版）、Twemoji（twitter做的），pymdownx官方推荐用EmojiOne，默认也是EmojiOne 有2个关键参数 emoji_index，选择emoji厂商，默认为EmojiOne emoji_generator，选择厂商对应的图片格式，默认为to_png generator有3类 to_png/to_svg : markdown在渲染时候，其中的 :短名: 根据emoji_index(即Gemoji/EmojiOne/Twemoji)被映射为相应的unicode码 unicode码被转为emoji_index对应的图片CDN地址(Gemoji/EmojiOne/Twemoji都有各自的CDN) 渲染成html时候图片地址被写入 标签 to_png_sprite/to_svg_sprite : 暂不了解 to_alt : markdown在渲染时候，其中的 :短名: 根据emoji_index(即Gemoji/EmojiOne/Twemoji)被映射为相应的unicode码 渲染成html时候unicode码被直接写入 标签 !!! note \"\" to_alt效果等同于直接将emoji图标复制到markdown文档中","text_tokens":["渲染","码","版","选择","/","战略","alt","均","emojione","都","分为","2","cdn","复制","进行","有","!","png","等同","复制到","是","_","unicode","匹配","免费","对应","中","文档","twitter","短名","地址","图片格式","付费","。",":","格式","成","）","类","关键","（","\"","个","sprite","emoji","做","直接","三方","svg",".","主流","相应","默认","markdown","用","映射","图片","本文","因此","note","mkdocs","被","根据","写入","github","其中","的","免费版","介绍","在","依赖","即","第三方","index","将","pymdownx","twemoji","了解","(","，","各自","时候","to","暂","推荐","也","厂商","同于"," ","官方","关于","参数","第三","html","不","支持","等同于",")","标签","效果","图标","：","合作","转为","为","generator","主要","gemoji","说明","、","下面","com","3"],"title":"Emoji principle","title_tokens":[" ","principle","emoji"]},{"location":"syntax/emoji_principle/#2","text":"emoji_index，选择emoji厂商，默认为EmojiOne emoji_generator，选择厂商对应的图片格式，默认为to_png","text_tokens":["的","png","，","为","generator","对应","格式","to","图片","图片格式","选择"," ","_","index","emojione","厂商","emoji","默认"],"title":"有2个关键参数","title_tokens":["关键","个","2","参数","有"]},{"location":"syntax/emoji_principle/#generator3","text":"to_png/to_svg : markdown在渲染时候，其中的 :短名: 根据emoji_index(即Gemoji/EmojiOne/Twemoji)被映射为相应的unicode码 unicode码被转为emoji_index对应的图片CDN地址(Gemoji/EmojiOne/Twemoji都有各自的CDN) 渲染成html时候图片地址被写入 标签 to_png_sprite/to_svg_sprite : 暂不了解 to_alt : markdown在渲染时候，其中的 :短名: 根据emoji_index(即Gemoji/EmojiOne/Twemoji)被映射为相应的unicode码 渲染成html时候unicode码被直接写入 标签 !!! note \"\" to_alt效果等同于直接将emoji图标复制到markdown文档中","text_tokens":[":","渲染","码","图片","note","/"," ","被","alt","成","根据","emojione","都","其中","cdn","写入","复制","有","的","png","html","!","等同","复制到","不","在","\"","即","等同于","_","index","sprite","将","emoji","unicode","直接",")","twemoji","svg","标签","对应","效果","中","图标","文档","了解","相应","(","markdown","转为","，","为","各自","gemoji","时候","to","暂","短名","地址","映射","同于"],"title":"generator有3类","title_tokens":["generator","类","3","有"]},{"location":"syntax/emoji_usage/","text":"通过在markdown里使用 :短名: ，可以在渲染出的html里展现emoji图片 依赖模块: pymdownx.emoji 使用步骤: mkdocs.yml里配置: yaml - pymdownx.emoji: emoji_generator: !!python/name:pymdownx.emoji.to_png 建议使用to_png，如果使用to_svg会有部分图片因为未付费导致无法显示 浏览器打开 https://www.emojicopy.com/ (emojione官方推出的emoji查询网站，虽然并非全部emoji，但也是目前找到的相对最全，并且分类清楚，使用方便的emoji查询网站)，将鼠标悬停在图标上方一会，会出现对应的全名，比如 记录下这个全名，比如这里叫做grinning face 点击进入附录里的 emojione全名短名映射表 ，在里面查找对应的短名 在markdown里使用该短名 !!! note \"最省事做法: 直接复制emoji图标\" 无需mkdocs.yml做任何配置，只要是emoji图标(是图标不是图片)，无论是输入法自带的emoji图标，还是 https://www.emojicopy.com/ 上的emoji图标，都可以直接复制粘贴到markdown文档里即可。比如这个笑脸😄就来自我的输入法，可以自行复制到markdown文档里测试。 而且这种方式适用于所有markdown编辑器。","text_tokens":["里","渲染","可以","/","复制","emojione","都","有","!","png","复制到","是","该","_","所有","无论","全部","虽然","点击","方式","于","对应","编辑器","出现","文档","出","face","短名","并非","付费","只要","全名","记录","推出","做法","方便",":","部分","这里","。","上","而且","www","无论是","yml","查询","name","输入","\"","emoji","做","-","直接","鼠标","并且","svg",".","里面","浏览","网站","附录","会","目前","表","还是","这个","markdown","笑脸","进入","映射","https","通过","我","任何","图片","note","mkdocs","下","查找","的","找到","无法","上方","在","依赖","将","适用","建议","未","相对","pymdownx","无需","省事","入法","鼠标悬停","最","显示","比如","分类","如果","(","自行","，","to","grinning","来自","打开","到","也","即可","叫做","测试","步骤"," ","官方","输入法","一会","😄","html","展现","使用方便","emojicopy","使用","不是","自带","清楚","悬停",")","python","就","图标","因为","编辑","这种","复制粘贴","但","yaml","导致","配置","generator","粘贴","com","最全","模块","浏览器"],"title":"Emoji usage","title_tokens":[" ","usage","emoji"]},{"location":"syntax/escape/","text":"推荐依照如下顺序进行转义尝试 1⃣️ 使用转义符号 \\ 2⃣️ 使用 行内代码 或 区块代码 方式 3⃣️ 在行内代码或区块代码里再使用转义符号 \\ 4⃣️ html标签: <code>需要转义的内容</code> 如果上面都行不通，只有最后一招，截图并 插入图片 ??? note \"推荐的截图方式\" 把要转义的文本复制到微信聊天对话输入框里，然后用任意截图工具对着输入框截图，这样截图出来的带有灰色背景，即代码块那种灰色背景（会让人觉得是使用代码块方式在表述）。 ??? warning \"注意上下文\" 相同的符号，会因为上下文环境被mkdocs认为是不同的意思，因此有时会遇到一些符号在有的上下文环境里可以使用或转义，有的就不行，比如跟在列表之后和跟着标题之后是不同上下文环境。 ??? success \"我的案例\" 可以上github查看本文档中转义章节的markdown源文件，其中大量使用了转义","text_tokens":["里","任意","工具","1","需要","可以","/","复制","之后","都","2","着","进行","复制到","有","是","方式","依照","觉得","这样","中","文档","如下","源文件","遇到","一招","带有","让",":","。","上","微信","）","下文","不通","认为","输入","那种","跟着","\"","（","相同","只有","并","对话","意思","标题","会","内容","文本","<","大量","符号","一些","markdown","?","不行","4","用","code","然后","本","代码","或","我","转义","聊天","人","插入","图片","note","因此","被","mkdocs","注意","github","其中","的","了","截图","在","上下","即","把","灰色","warning","跟","列表","查看","比如","表述","如果","顺序","有时","最后","，","案例","行内","推荐","对","区块","章节","尝试","⃣","要","文件"," ","和","️","success","上面","html","出来","使用",">","再","\\","输入框","标签","就","因为","上下文","块","不同","背景","环境","3","行不通"],"title":"Escape","title_tokens":["escape"]},{"location":"syntax/font_line/","text":"不带高亮 依赖模块: pymdownx.critic This is ~~is~~ a test. 效果 This is ~~is~~ a test. 背景高亮 详见 高亮章节横线部分","text_tokens":[":","部分"," ","横线","依赖","~","pymdownx",".","效果","高亮","详见","critic","test","this","a","背景","is","模块","不带","章节"],"title":"3.4. 横线","title_tokens":[" ","横线",".","3.4"]},{"location":"syntax/font_line/#_1","text":"依赖模块: pymdownx.critic This is ~~is~~ a test. 效果 This is ~~is~~ a test.","text_tokens":[":",".","this","a","效果","依赖"," ","is","pymdownx","模块","critic","test","~"],"title":"不带高亮","title_tokens":["高亮","不带"]},{"location":"syntax/font_line/#_2","text":"详见 高亮章节横线部分","text_tokens":["部分","横线","高亮"," ","详见","章节"],"title":"背景高亮","title_tokens":["高亮","背景"]},{"location":"syntax/font_stress/","text":"依赖模块: pymdownx.betterem(smart_enable=all) *text* 或 _text_ 斜体 **text** 或 __text__ 粗体 ***text*** 或 ___text___ 粗斜体 效果 text 斜体 text 粗体 text 粗斜体 !!! warning \"避免冲突\" 这个扩展和markdown.extensions.smartstrong扩展冲突，不能同时载入，前者替代了后者，实现更好的效果。","text_tokens":[":","。","更好"," ","避免","和","text","!","粗体","的","=","了","后者","斜体","冲突","依赖","\"","enable","_","warning","extensions","pymdownx",")","前者",".","smart","___","效果","all","替代","载入","不能","__","这个","(","markdown","smartstrong","，","实现","粗","betterem","同时","*","模块","或","扩展"],"title":"4.1. 歪珠","title_tokens":[" ","4.1","歪珠","."]},{"location":"syntax/font_underline/","text":"不带高亮 依赖模块: pymdownx.caret ^^underline me^^ 效果 ^^underline me^^ 背景高亮 详见 高亮章节下划线部分","text_tokens":[":","部分"," ","下划","依赖","underline","^","pymdownx",".","效果","高亮","caret","详见","下划线","背景","划线","me","模块","不带","章节"],"title":"3.3. 下划线","title_tokens":[".","3.3","下划线"," ","下划","划线"]},{"location":"syntax/font_underline/#_1","text":"依赖模块: pymdownx.caret ^^underline me^^ 效果 ^^underline me^^","text_tokens":[":","underline",".","效果","依赖","caret","^"," ","me","pymdownx","模块"],"title":"不带高亮","title_tokens":["高亮","不带"]},{"location":"syntax/font_underline/#_2","text":"详见 高亮章节下划线部分","text_tokens":["部分","高亮","下划线"," ","下划","划线","详见","章节"],"title":"背景高亮","title_tokens":["高亮","背景"]},{"location":"syntax/font_underline_line/","text":"只有高亮形式,详见 高亮章节下划线+横线部分","text_tokens":["部分","横线","高亮",",","形式","下划线","+"," ","只有","下划","划线","详见","章节"],"title":"3.5. 下划线+横线","title_tokens":["横线",".","3.5","下划线","+"," ","下划","划线"]},{"location":"syntax/font_updown/","text":"上标 依赖模块: pymdownx.caret 10^2^ 效果 10^2^ 针对英文描述第几的上标，可以 1st 这种方式(依赖模块: pymdownx.smartsymbols) 用法 效果 1st 2nd 3rd 1st 2nd 3rd 1^st^ 2^nd^ 3^rd^ 1^st^ 2^nd^ 3^rd^ 下标 依赖模块: pymdownx.tilde H~2~O 效果 H~2~O","text_tokens":[":","上标","1","可以"," ","2","st","的","英文","依赖","rd","10","^","pymdownx","方式",")",".","效果","1st","tilde","caret","这种","针对","o","下标","(","3rd","，","h","用法","smartsymbols","nd","描述","2nd","3","第几","模块","~"],"title":"4.2. 惯例珠","title_tokens":["."," ","4.2","珠","惯例"]},{"location":"syntax/font_updown/#_1","text":"依赖模块: pymdownx.caret 10^2^ 效果 10^2^ 针对英文描述第几的上标，可以 1st 这种方式(依赖模块: pymdownx.smartsymbols) 用法 效果 1st 2nd 3rd 1st 2nd 3rd 1^st^ 2^nd^ 3^rd^ 1^st^ 2^nd^ 3^rd^","text_tokens":[":","上标","1","可以"," ","2","st","的","英文","依赖","rd","10","^","pymdownx","方式",")",".","效果","1st","caret","这种","针对","(","3rd","，","用法","smartsymbols","nd","描述","2nd","3","第几","模块"],"title":"上标","title_tokens":["上标"]},{"location":"syntax/font_updown/#_2","text":"依赖模块: pymdownx.tilde H~2~O 效果 H~2~O","text_tokens":[":","h",".","效果","tilde","依赖"," ","o","2","pymdownx","模块","~"],"title":"下标","title_tokens":["下标"]},{"location":"syntax/footnote/","text":"依赖模块: footnotes 第一步. 插入引用 Lorem ipsum[^1] dolor sit amet, consectetur adipiscing elit.[^2] 第二步. 插入内容 [^1]: Lorem ipsum dolor sit amet, consectetur adipiscing elit. [^2]: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! note \"\" 可以看到，上面脚注1内容是单行方式，脚注2内容是多行方式 效果 Lorem ipsum[^1] dolor sit amet, consectetur adipiscing elit. ^2 [^1]: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! warning \"注意\" 1. 不一定要用[\\^1]，也可以用自定义关键字，比如[\\^mykey]，但这样下面也要改为[\\^mykey]，也可以支持空格，比如[\\^my key]（当然后面也要[\\^my key]: 2. 无论脚注标签写的是什么（即\\[\\^1\\]或者\\[\\^mykey\\]，在展示脚注标签和展示脚注内容时候都是自动用数字从1开始累加标记，而不是自己写的内容） 3. \\[\\^1\\]: 脚注内容无论写在.md中的任何位置，在展示时候都是自动位于文档的最下方，并且会自动添加---这样一个横线","text_tokens":["in","1","---","可以","都","2","二步","!","elit","是","无论","第二","^","semper","方式","第二步","feugiat","这样","中","dolor","文档","massa","自定","而",",","当然","tortor",":","累加","consequat","lorem","sit","）","euismod","关键","下方","[","\"","mykey","（","改为","自定义","并且","关键字",".","或者","开始","会","adipiscing","内容","多行","展示","consectetur","non","purus","后面","一个","自动","quam","用","第一","auctor","任何","footnotes","从","插入","note","注意","的","在","依赖","即","看到","warning","最","ipsum","比如","一定","标记","justo","，","时候","单行","也","引用","一步","nulla","位置","et","nec","curabitur","要"," ","]","和","md","上面","amet","写","横线","数字","不","支持","定义","my","自己","不是","位于","finibus","脚注","\\","空格","效果","标签","什么","key","但","添加","第一步","下面","3","模块"],"title":"Footnote","title_tokens":["footnote"]},{"location":"syntax/headline/","text":"使用 # ，表示1-6级标题。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注意: 一个.md里只能有一个 # ，跟着多个 ## 。如果有多个 # ，则不会自动生产本页目录。 如果有 # ，则使用该标题作为本页正文部分第一行，如果没有#，则为mkdocs.yml里指定的pages名。 个人建议.md从 ## 开始，不要用 # 。","text_tokens":["。",":","里","部分","正文","级","1","从","##","个人","本页"," ","五级","mkdocs","注意","md","yml","有","四级","生产","三级","目录","则","的","pages","######","跟着","####","6","使用","一级","二级","多个","该","建议","自动生产","-","作为","六级",".","标题","开始","不会","指定","如果","表示","没有","，","为","#","不要","#####","一个","第一行","名","自动","只能","用","第一","一行","###"],"title":"Headline","title_tokens":["headline"]},{"location":"syntax/highlight_background/","text":"黄色 2个模块均提供了相似的效果 模块1: pymdownx.mark ==hello world== 效果 ==hello world== 模块2: pymdownx.critic 效果 {==hello world==} 但这2个模块也有区别 : 区别1: pymdownx.mark渲染出的html是 <p><mark>hello world</mark></p> pymdownx.critic渲染出的html是 <p><mark class=\"critic\">hello world</mark></p> 区别2: pymdownx.mark不支持块背景高亮 pymdownx.critic支持块背景高亮 用法: 效果: {== AAA BBB CCC ==} 支持嵌套，详见 黄色区块嵌套高亮代码示例 绿色(下划线) 表示插入文字 依赖模块: pymdownx.critic 效果 Hello, {++my++} world! 支持嵌套，详见 绿色区块嵌套高亮代码示例 红色(横线) 表示删除文字 依赖模块: pymdownx.tidle 效果 {--delete me--} 支持嵌套，详见 红色区块嵌套高亮代码示例 绿色+红色(下划线+横线) 表示替换文字 2种实现方式: 先使用红色(横线)，再使用绿色(下划线) 使用专门的语法，依赖模块pymdownx.tidle 这2种方式效果完全一致，包括实际看到的样式和html都是相同的 Hello, {~~my~>our~~} world! 支持嵌套，详见 绿色+红色区块嵌套高亮代码示例 灰色 表示注解 依赖模块: pymdownx.critic 效果 This is a test{>>What is it a test of?<<}. 注意: 只支持单行用法，不支持区块用法 无法与代码高亮结合，包括行内代码高亮和区块代码高亮","text_tokens":["渲染","1","/","下划","均","hello","2","都","有","!","完全","是","完全一致","样式","+","of","只","方式","绿色","高亮","aaa","critic","出","用法",",","这","一致","替换","~","黄色",":","实际","class","示例","提供","与","=","\"","our","种","语法","相同","个","专门",".","嵌套","<","ccc","?","++","实现","this","a","mark","划线","代码","}","插入","先","注意","的","p","包括","了","无法","it","依赖","灰色","区别","看到","world","pymdownx","delete","what","tidle","结合","详见","(","表示","，","行内","单行","也","is","区块"," ","和","bbb","html","横线","注解","不","支持","my","--","使用","文字",">","删除","相似","再","{",")","效果","但","test","块","下划线","背景","me","红色","模块"],"title":"Highlight background","title_tokens":[" ","highlight","background"]},{"location":"syntax/highlight_background/#_1","text":"2个模块均提供了相似的效果 模块1: pymdownx.mark ==hello world== 效果 ==hello world== 模块2: pymdownx.critic 效果 {==hello world==} 但这2个模块也有区别 : 区别1: pymdownx.mark渲染出的html是 <p><mark>hello world</mark></p> pymdownx.critic渲染出的html是 <p><mark class=\"critic\">hello world</mark></p> 区别2: pymdownx.mark不支持块背景高亮 pymdownx.critic支持块背景高亮 用法: 效果: {== AAA BBB CCC ==} 支持嵌套，详见 黄色区块嵌套高亮代码示例","text_tokens":[":","渲染","黄色","}","1"," ","/","class","均","hello","2","示例","bbb","提供","的","有","html","p","=","了","不","是","\"","支持","个","区别",">","相似","world","pymdownx","{",".","效果","高亮","嵌套","但","详见","aaa","<","critic","ccc","块","，","出","用法","mark","这","背景","也","区块","代码","模块"],"title":"黄色","title_tokens":["黄色"]},{"location":"syntax/highlight_background/#_2","text":"表示插入文字 依赖模块: pymdownx.critic 效果 Hello, {++my++} world! 支持嵌套，详见 绿色区块嵌套高亮代码示例","text_tokens":[":","}","插入"," ","hello","示例","!","依赖","支持","my","文字","world","pymdownx","{",".","绿色","效果","高亮","嵌套","详见","critic","表示","++","，",",","区块","代码","模块"],"title":"绿色(下划线)","title_tokens":["绿色","下划线","划线","下划","(",")"]},{"location":"syntax/highlight_background/#_3","text":"表示删除文字 依赖模块: pymdownx.tidle 效果 {--delete me--} 支持嵌套，详见 红色区块嵌套高亮代码示例","text_tokens":[":","}"," ","示例","依赖","支持","--","文字","删除","pymdownx","delete","{",".","效果","高亮","tidle","嵌套","详见","表示","，","代码","区块","me","红色","模块"],"title":"红色(横线)","title_tokens":["红色","横线","(",")"]},{"location":"syntax/highlight_background/#_4","text":"表示替换文字 2种实现方式: 先使用红色(横线)，再使用绿色(下划线) 使用专门的语法，依赖模块pymdownx.tidle 这2种方式效果完全一致，包括实际看到的样式和html都是相同的 Hello, {~~my~>our~~} world! 支持嵌套，详见 绿色+红色区块嵌套高亮代码示例","text_tokens":[":","}","实际"," ","先","下划","和","都","2","hello","示例","的","包括","html","横线","!","完全","依赖","完全一致","样式","种","使用","语法","是","文字","看到","相同","my",">","+","再","pymdownx","world","专门","{","方式",")","绿色",".","效果","高亮","tidle","嵌套","支持","详见","(","表示","，","实现","代码",",","下划线","这","划线","一致","our","区块","红色","模块","替换","~"],"title":"绿色+红色(下划线+横线)","title_tokens":["横线","绿色","下划线","+","划线","下划","红色","(",")"]},{"location":"syntax/highlight_background/#_5","text":"表示注解 依赖模块: pymdownx.critic 效果 This is a test{>>What is it a test of?<<}. 注意: 只支持单行用法，不支持区块用法 无法与代码高亮结合，包括行内代码高亮和区块代码高亮","text_tokens":[":","}"," ","和","注意","与","包括","注解","不","无法","it","依赖","支持","of",">","只","pymdownx","{",".","效果","高亮","what","结合","<","critic","test","表示","?","，","用法","this","a","单行","行内","is","区块","代码","模块"],"title":"灰色","title_tokens":["灰色"]},{"location":"syntax/highlight_code/","text":"行内代码高亮 依赖模块: pymdownx.inlinehilite 使用shebang可以在一行文本里实现代码高亮 `#!python print \"Hello, world!\"`或`:::python print \"Hello, world!\"` 效果 #!python print \"Hello, world!\" 或 :::python print \"Hello, world!\" !!! warning \"开头不能有空格，如果有空格的话，就会被认为是正文\" text ` #!python print \"Hello, world!\"` 效果 #!python print \"Hello, world!\" ```text ` :::python print \"Hello, world!\"` ``` 效果 ` :::python print \"Hello, world!\"` 区块代码高亮 用法 依赖模块: codehilite 写法1: 3个` ```python text = \"Hello, world!\" print text ``` 效果 text = \"Hello, world!\" print text 写法2: 4个空格+shebang #!/usr/bin/python text = \"Hello, world!\" print text 效果 #!/usr/bin/python text = \"Hello, world!\" print text !!! note \"支持434种格式\" codehilite是基于pygments实现高亮的，支持434种格式，详见 支持代码高亮的语言 若指定了不存在的格式，则等同于text，不做任何高亮渲染 若不想使用高亮，用text，如： ```text text = \"Hello, world!\" print text ``` 效果 text = \"Hello, world!\" print text 参数1. 自动猜测语言 在mkdocs.yml里markdown_extensions部分设置如下 - codehilite(guess_lang=false) 关闭猜测，若不指定语言，则关闭高亮 - codehilite(guess_lang=true) 开启猜测，若不指定语言，则自动猜测 参数2. 显示行号 在mkdocs.yml里markdown_extensions部分设置 - codehilite(linenums=true) 显示行号 - codehilite(linenums=false) 不显示行号 !!! warning \"\" 若codehilite(linenums=true)，4个空格的代码块方式也会被自动加上行号 !!! warning \"指定代码块显示行号\" 因此，如果想全局默认不显示行号，而指定代码块显示行号，可以在mkdocs.yml里指定linenums=false，然后想显示行号的代码块用linenums=\"1\" 参数3. 指定第几行背景高亮 在mkdocs.yml里不用额外设置 ```python hl_lines=\"2 4\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果 text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 参数4. 指定行号从多少开始编号 ```python linenums=\"2\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果 ```python linenums=\"2\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 !!! warning \"强制显式行号\" 当代码块指定了linenums后，即使mkdocs.yml里linenums=false，也会自动显示行号 **因此，如果想全局默认不显示行号，而指定代码块显示行号，可以在mkdocs.yml里指定linenums=false，然后想显示行号的代码块用linenums=\"1\"** 注意：代码块linenums参数不会影响hl_lines，即无论linenums指定从多少行开始编号，hl_lines实际都以行号从1开始编号来找到对应行进行背景高亮渲染，如： ```python linenums=\"2\" hl_lines=\"3\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果 ```python linenums=\"2\" hl_lines=\"3\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2","text_tokens":["里","渲染","pygments","1","codehilite","可以","usr","/","即使","hello","2","加上","都","进行","有","!","等同","额外","是","hl","+","text1","不用","_","无论","行","后","方式","全局","对应","高亮","基于","语言","指定","不能","若","如下","而","false","用法",",","如",":","部分","实际","格式","`","多少","认为","yml","则","=","以","\"","种","个","做","-","几行","写法",".","开启","开始","的话","会","linenums","文本","第","默认","markdown","实现","4","关闭","自动","用","存在","然后","猜测","代码","*","或","任何","从","note","因此","被","mkdocs","显式","注意","text","的","了","找到","在","依赖","text2","即","当","warning","强制","extensions","lang","pymdownx","world","显示","想","不会","inlinehilite","如果","详见","(","true","，","行内","一行","设置","print","区块","也","同于","guess","影响","正文"," ","来","参数","bin","不","行号","支持","不想","使用","等同于","编号","shebang",")","空格","python","效果","就","434","：","开头","lines","块","#","背景","3","模块"],"title":"Highlight code","title_tokens":[" ","highlight","code"]},{"location":"syntax/highlight_code/#_1","text":"依赖模块: pymdownx.inlinehilite 使用shebang可以在一行文本里实现代码高亮 `#!python print \"Hello, world!\"`或`:::python print \"Hello, world!\"` 效果 #!python print \"Hello, world!\" 或 :::python print \"Hello, world!\" !!! warning \"开头不能有空格，如果有空格的话，就会被认为是正文\" text ` #!python print \"Hello, world!\"` 效果 #!python print \"Hello, world!\" ```text ` :::python print \"Hello, world!\"` ``` 效果 ` :::python print \"Hello, world!\"`","text_tokens":[":","里","正文","`","可以"," ","被","hello","text","认为","有","!","在","依赖","\"","是","使用","warning","pymdownx","world","shebang",".","空格","python","效果","高亮","就","的话","会","不能","inlinehilite","文本","开头","如果","，","实现","#",",","一行","print","代码","模块","或"],"title":"行内代码高亮","title_tokens":["高亮","代码","行内"]},{"location":"syntax/highlight_code/#_2","text":"","text_tokens":[],"title":"区块代码高亮","title_tokens":["高亮","代码","区块"]},{"location":"syntax/highlight_code/#_3","text":"依赖模块: codehilite 写法1: 3个` ```python text = \"Hello, world!\" print text ``` 效果 text = \"Hello, world!\" print text 写法2: 4个空格+shebang #!/usr/bin/python text = \"Hello, world!\" print text 效果 #!/usr/bin/python text = \"Hello, world!\" print text !!! note \"支持434种格式\" codehilite是基于pygments实现高亮的，支持434种格式，详见 支持代码高亮的语言 若指定了不存在的格式，则等同于text，不做任何高亮渲染 若不想使用高亮，用text，如： ```text text = \"Hello, world!\" print text ``` 效果 text = \"Hello, world!\" print text","text_tokens":[":","渲染","pygments","格式","1","`","codehilite","usr","note"," ","/","hello","2","bin","text","同于","!","的","等同","则","=","了","不","依赖","\"","支持","+","种","是","等同于","个","不想","使用","做","world","写法","shebang","空格","python","效果","基于","高亮","语言","434","指定","：","若","详见","，","#","实现",",","4","如","用","存在","3","print","代码","模块","任何"],"title":"用法","title_tokens":["用法"]},{"location":"syntax/highlight_code/#1","text":"在mkdocs.yml里markdown_extensions部分设置如下 - codehilite(guess_lang=false) 关闭猜测，若不指定语言，则关闭高亮 - codehilite(guess_lang=true) 开启猜测，若不指定语言，则自动猜测","text_tokens":["里","部分","codehilite"," ","mkdocs","yml","则","=","不","在","_","lang","extensions","-",")",".","高亮","开启","语言","指定","若","如下","(","markdown","false","true","，","关闭","自动","设置","猜测","guess"],"title":"参数1. 自动猜测语言","title_tokens":[".","1","语言","自动"," ","猜测","参数"]},{"location":"syntax/highlight_code/#2","text":"在mkdocs.yml里markdown_extensions部分设置 - codehilite(linenums=true) 显示行号 - codehilite(linenums=false) 不显示行号 !!! warning \"\" 若codehilite(linenums=true)，4个空格的代码块方式也会被自动加上行号 !!! warning \"指定代码块显示行号\" 因此，如果想全局默认不显示行号，而指定代码块显示行号，可以在mkdocs.yml里指定linenums=false，然后想显示行号的代码块用linenums=\"1\"","text_tokens":["里","部分","1","codehilite","可以","因此"," ","mkdocs","被","加上","yml","!","的","=","不","在","行号","\"","_","warning","个","extensions","-","方式",")","全局",".","空格","显示","想","会","指定","linenums","若","如果","默认","(","markdown","true","false","，","块","而","4","自动","用","然后","设置","也","代码"],"title":"参数2. 显示行号","title_tokens":["参数",".","行号","显示"," ","2"]},{"location":"syntax/highlight_code/#3","text":"在mkdocs.yml里不用额外设置 ```python hl_lines=\"2 4\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果 text1 = \"Hello, \" text2 = \"world!\" print text1 + text2","text_tokens":["里","`"," ","mkdocs","hello","2","yml","额外","!","=","在","text2","\"","hl","text1","+","不用","_","world",".","python","效果","lines","4",",","设置","print"],"title":"参数3. 指定第几行背景高亮","title_tokens":[".","高亮","背景"," ","指定","3","参数","第","几行"]},{"location":"syntax/highlight_code/#4","text":"```python linenums=\"2\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果 ```python linenums=\"2\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 !!! warning \"强制显式行号\" 当代码块指定了linenums后，即使mkdocs.yml里linenums=false，也会自动显示行号 **因此，如果想全局默认不显示行号，而指定代码块显示行号，可以在mkdocs.yml里指定linenums=false，然后想显示行号的代码块用linenums=\"1\"** 注意：代码块linenums参数不会影响hl_lines，即无论linenums指定从多少行开始编号，hl_lines实际都以行号从1开始编号来找到对应行进行背景高亮渲染，如： ```python linenums=\"2\" hl_lines=\"3\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果 ```python linenums=\"2\" hl_lines=\"3\" text1 = \"Hello, \" text2 = \"world!\" print text1 + text2","text_tokens":["里","渲染","1","可以","即使","hello","2","都","进行","!","hl","text1","+","_","无论","行","后","全局","对应","高亮","指定","而","false",",","如","实际","`","多少","yml","=","以","\"",".","开始","会","linenums","默认","自动","用","然后","*","代码","从","因此","显式","mkdocs","注意","的","了","找到","text2","在","即","当","warning","强制","world","显示","想","不会","如果","，","也","print","影响"," ","来","参数","不","行号","编号","python","效果","：","lines","块","背景","3"],"title":"参数4. 指定行号从多少开始编号","title_tokens":[".","4","行号","从","多少","开始"," ","指定","参数","编号"]},{"location":"syntax/image_index/","text":"当一个页面里多次调用相同图片时，这种方法更适用: ![alt][索引] [索引]: 图片地址 \"title\" 注意: [索引]: 图片地址 \"title\" 可以写在任意地方，通常习惯于放在markdown本页文档最下方 如 ![alt][test icon] ... [test icon]: /img/test_icon.png \"title\" 效果 鼠标悬停在图标上可以看到\"title\"字样","text_tokens":[":","里","任意","上","title","图片","可以","本页"," ","]","alt","注意","放在","/","页面","字样","习惯于","方法","!","png","写","下方","惯于","在","[","\"","相同","当","多次","适用","_","看到","时","调用","icon","...","悬停","鼠标","更","鼠标悬停","最","地方",".","索引","效果","图标","这种","文档","test","markdown","通常","，","一个","如","地址","习惯","img"],"title":"Image index","title_tokens":[" ","image","index"]},{"location":"syntax/image_inline/","text":"添加图片的形式和链接相似，只需在链接的基础上前方加一个 ! ![alt](图片地址 \"title\") 如 ![hello](./../../img/test_icon.png \"title\") 效果 鼠标悬停在图标上可以看到\"title\"字样","text_tokens":["上","title","需","..","形式","图片","可以","和"," ","alt","]","/","链接","hello","字样","前方","的","!","png","在","[","\"","_","看到","只","相似","icon","悬停",")","鼠标","加","鼠标悬停",".","效果","图标","添加","test","(","，","一个","如","地址","基础","img"],"title":"Image inline","title_tokens":[" ","image","inline"]},{"location":"syntax/link_anchor/","text":"英文叫Permalinks，是toc扩展模块的一个功能 依赖模块: toc 默认值: toc(permalink=false) 笔者推荐值: toc(permalink=true) 参数设置: toc(permalink=true) 点击锚点或者跳转至锚点后会自动在锚点处显示图标或文本，并自动固定在该位置，刷新页面后也会自动回到该位置，效果如下： toc(permalink=false) 看不到锚点处的图标或文本，但跳转至锚点处后自动固定在该位置，刷新页面后也会自动回到该位置 toc(permalink=false)等同于注释掉这个扩展，效果均如下： toc(permalink=自定义名) 可以支持自定义名，比如toc(permalinks=hello)，效果如下：","text_tokens":[":","至","后会","位置","可以"," ","均","固定","hello","参数","页面","注释","的","等同","看不到","=","英文","默认值","参数设置","在","是","依赖","定义","该","等同于","支持","permalinks","自定义","点击","锚点","笔者","跳转","叫",")","处","推荐值","并","后","掉","效果","或者","显示","图标","比如","会","处后","：","不到","但","文本","刷新","如下","自定","默认","(","false","true","这个","，","一个","回到","名","推荐","自动","功能","设置","permalink","也","同于","模块","或","扩展","toc"],"title":"Link anchor","title_tokens":[" ","anchor","link"]},{"location":"syntax/link_auto/","text":"依赖模块: pymdownx.magiclink 当识别到HTML、FTP、Email地址时候会自动转为超链接，如 http://www.example.cpm/ 效果 http://www.example.com/ 经测试，至少支持以下几种自动链接 http://www.example.com/ https://www.example.com/ ftp://www.example.com/ www.example.com user@example.com","text_tokens":[":","http","example","www","cpm","测试"," ","/","几种","user","链接","@","magiclink","email","识别","html","依赖","支持","当","pymdownx",".","效果","ftp","会","超链接","经","至少","转为","以下","，","时候","、","地址","自动","如","到","com","模块","https"],"title":"Link auto","title_tokens":[" ","link","auto"]},{"location":"syntax/link_normal/","text":"行内式 [example](http://www.example.com/ \"title\") 效果 example 鼠标悬停在链接上可以看到\"title\"字样 参考式 当一个页面里多次调用相同链接时，这种方法更适用: [example][索引] ... [索引]: http://www.example.com/ \"title\" 注意: [索引]: http://www.example.com/ \"title\" 可以写在任意地方，通常习惯于放在markdown本页文档最下方 效果 example 鼠标悬停在链接上可以看到\"title\"字样","text_tokens":[":","里","任意","上","title","example","http","www","可以","本页"," ","]","/","注意","放在","链接","参考","页面","字样","习惯于","方法","写","下方","惯于","在","[","式","\"","相同","当","看到","多次","适用","悬停","调用","时","...","鼠标",")","鼠标悬停","更","最",".","地方","效果","索引","这种","文档","(","通常","markdown","，","行内","一个","com","习惯"],"title":"Link normal","title_tokens":[" ","normal","link"]},{"location":"syntax/link_normal/#_1","text":"[example](http://www.example.com/ \"title\") 效果 example 鼠标悬停在链接上可以看到\"title\"字样","text_tokens":[":","上","title","http","example","www","可以","/","]"," ","链接","字样","在","[","\"","看到","悬停","鼠标","鼠标悬停",")",".","效果","(","com"],"title":"行内式","title_tokens":["式","行内"]},{"location":"syntax/link_normal/#_2","text":"当一个页面里多次调用相同链接时，这种方法更适用: [example][索引] ... [索引]: http://www.example.com/ \"title\" 注意: [索引]: http://www.example.com/ \"title\" 可以写在任意地方，通常习惯于放在markdown本页文档最下方 效果 example 鼠标悬停在链接上可以看到\"title\"字样","text_tokens":[":","里","任意","上","title","example","http","www","可以","本页"," ","]","/","注意","放在","链接","页面","字样","习惯于","方法","写","下方","惯于","在","[","\"","相同","当","多次","适用","看到","时","调用","...","悬停","鼠标","更","鼠标悬停","最",".","地方","索引","效果","这种","文档","markdown","通常","，","一个","com","习惯"],"title":"参考式","title_tokens":["式","参考"]},{"location":"syntax/list_noseq/","text":"使用 * 、 + 、或 - 标记无序列表，下面仅以 - 作为示例， - 第一项 - 第二项 - 第三项 注: 标记后面最少有一个 空格 或 制表符 。若不在引用区块中，必须和前方段落之间存在空行。 效果 第一项 第二项 第三项","text_tokens":[":","。","第二项","最少"," ","和","三项","示例","第三","有","前方","不","必须","在","+","使用","列表","第二","之间","-","段落","作为","第一项","空格","效果","中","第三项","若","制表","二项","标记","注","，","后面","制表符","一个","一项","、","下面","区块","第一","存在","仅以","空行","无序","引用","*","或"],"title":"List noseq","title_tokens":[" ","noseq","list"]},{"location":"syntax/list_seq/","text":"有序列表的标记方式是将上述的符号换成数字,并辅以 . 1. 第一项 2. 第二项 3. 第三项 效果 第一项 第二项 第三项","text_tokens":["第二项","1"," ","三项","2","第三","有","的","数字","是","上述","将","列表","辅以","第二","序列表","并","方式","第一项",".","效果","序列","第三项","二项","符号","标记","换成",",","一项","第一","3"],"title":"List seq","title_tokens":[" ","list","seq"]},{"location":"syntax/list_task/","text":"依赖模块: pymdownx.tasklist 用法: - [ ] 或 - [x] ，其中 [ ] 表示不打勾， [x] 表示打勾， - 可以用 + 或 * 替代 - [x] Lorem ipsum dolor sit amet, consectetur adipiscing elit - [x] Nulla lobortis egestas semper - [x] Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est - [ ] Vestibulum convallis sit amet nisi a tincidunt - [x] In hac habitasse platea dictumst - [x] In scelerisque nibh non dolor mollis congue sed et metus - [x] Sed egestas felis quis elit dapibus, ac aliquet turpis mattis - [ ] Praesent sed risus massa - [x] Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque - [ ] Nulla vel eros venenatis, imperdiet enim id, faucibus nisi 效果 [x] Lorem ipsum dolor sit amet, consectetur adipiscing elit [x] Nulla lobortis egestas semper [x] Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est [ ] Vestibulum convallis sit amet nisi a tincidunt [x] In hac habitasse platea dictumst [x] In scelerisque nibh non dolor mollis congue sed et metus [x] Sed egestas felis quis elit dapibus, ac aliquet turpis mattis [ ] Praesent sed risus massa [x] Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque [ ] Nulla vel eros venenatis, imperdiet enim id, faucibus nisi","text_tokens":["in","sed","metus","ligula","可以","lobortis","elit","打勾","at","+","tasklist","vestibulum","efficitur","semper","feugiat","dolor","massa","mattis","aliquet","用法",",","imperdiet","erat","praesent","faucibus","congue",":","scelerisque","egestas","lorem","sit","iaculis","euismod","nibh","nisi","[","aenean","-","felis",".","est","ullamcorper","替代","quis","adipiscing","consectetur","non","a","用","*","或","id","pharetra","其中","habitasse","ac","donec","依赖","risus","pymdownx","ipsum","venenatis","dapibus","platea","表示","dictumst","，","mollis","nulla","et","curabitur"," ","]","amet","pretium","不","convallis","x","hac","效果","vel","turpis","enim","tincidunt","模块","eros"],"title":"List task","title_tokens":[" ","task","list"]},{"location":"syntax/main/","text":"由于语法众多，因此将 大部分语法 汇总在下面表格里，便于一览。 但该表并未涵盖全部语法(如某些特殊符号) ，因此详情请翻看语法的具体章节。 符号 用途 # 标题 空行 段落 > 引用 [^sth] 脚注 !!! 注解 ??? 折叠注解 \\ 转义 * 列表 + 列表 - 列表 *[x] 任务列表 +[x] 任务列表 -[x] 任务列表 --- 分割线 :shortname: emoji ` 行内代码 ```语言 代码块,带高亮 TAB 代码块 #! 代码高亮 ::: 代码高亮 *sth* 斜体 _sth_ 斜体 **sth** 粗体 __sth__ 粗体 ***sth*** 粗斜体 ___sth___ 粗斜体 \\^sth\\^ 上标 \\~sth\\~ 下标 \\^\\^sth\\^\\^ 文字下划线 \\~\\~sth\\~\\~ 文字中横线 {++sth++} 文字下划线,绿色背景高亮 {--sth--} 文字中横线,红色背景高亮 {\\~\\~false\\~>true\\~\\~} 文字下划线接文字横线,绿接红背景高亮 {>>sth<<} 表示注解,灰色背景高亮 \\=\\=sth\\=\\= 黄色背景高亮 {\\=\\=sth\\=\\=} 黄色背景高亮 \\$sth$ 行内式数学公式 \\(sth)\\ 行内式数学公式 \\$\\$...$$ 区块式数学公式 \\begin{}...\\end{} 区块式数学公式 [text](url \"title\") 行内式链接 [text][index],文档最后[index]: url \"title\" 参考式链接 符合要求的URL 自动链接 ![alt](url \"title\") 行内式图片 ![alt][index],文档最后[index]: url \"title\" 参考式图片","text_tokens":["里","详情","---","下划","alt","参考","!","粗体","一览","+","要求","_","全部","^","绿色","高亮","中","语言","文档","false","数学公式",",","如","sth","空行","~","。","部分",":","黄色","begin","`","用途","涵盖","链接","表格","=","[","\"","语法","接","emoji","-","符合要求","end","标题","url","下标","<","符号","?","该表","++","割线","并未","众多","大部分","自动","划线","代码","*","由于","折叠","大部","分割线","}","转义","title","图片","因此","特殊","任务","text","红","的","翻看","在","斜体","式","灰色","将","index","列表","段落","分割","便于","最后","(","true","表示","，","行内","粗","shortname","引用","区块","章节","具体","上标"," ","]","横线","数学","注解","公式","--","文字",">","x","...","{","tab","符合",")","脚注","\\","___","带高亮","绿接","但","特殊符号","__","汇总","块","详情请","#","$","某些","下面","下划线","背景","红色"],"title":"Main","title_tokens":["main"]},{"location":"syntax/math_js/","text":"先在docs里创建js目录，并在js目录中放置extra.js： window.MathJax = { tex2jax: { inlineMath: [ [\"\\\\(\",\"\\\\)\"] ], displayMath: [ [\"\\\\[\",\"\\\\]\"] ] }, TeX: { TagSide: \"right\", TagIndent: \".8em\", MultLineWidth: \"85%\", equationNumbers: { autoNumber: \"AMS\", }, unicode: { fonts: \"STIXGeneral,'Arial Unicode MS'\" } }, displayAlign: \"left\", showProcessingMessages: false, messageStyle: \"none\" }; 然后在mkdocs.yml里添加如下内容，用于导入js extra_javascript: - 'js/extra.js' - 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'","text_tokens":["mml","里","showprocessingmessages","0","/","ams","displaymath","arial","_","unicode","docs","创建","config",";","中","如下","false","inlinemath","libs",",",":","js","tex","cloudflare","yml","放置","目录","=","2.7","[","\"","fonts","-","并","ajax","用于",".","tagside","内容","autonumber","stixgeneral","'","?","然后","javascript","https","window","}","none","先","mkdocs","extra","tagindent","在","8em","(","，","messagestyle","tex2jax","right","displayalign"," ","]","85%","导入","ms","chtml","multlinewidth","{","mathjax",")","\\","left","：","添加","equationnumbers","com","am","cdnjs"],"title":"Math js","title_tokens":[" ","math","js"]},{"location":"syntax/math_main/","text":"用于TeX数学公式的展示，使用之前要先在docs/里创建javascripts目录，并在目录中放置extra.js 依赖模块: pymdownx.arithmatex","text_tokens":[":","里","要","先","/"," ","js","tex","extra","的","放置","数学","目录","之前","公式","在","依赖","使用","pymdownx","并","docs","创建","用于",".","中","展示","，","数学公式","javascripts","arithmatex","模块"],"title":"Math main","title_tokens":[" ","main","math"]},{"location":"syntax/math_usage/","text":"行内写法有2种: $...$ 和 \\(...\\) 区块写法有3种: $$...$$ , \\[...\\] , 和 \\begin{}...\\end{} 具体用法详见: https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference http://www.andy-roberts.net/writing/latex/mathematics_1 http://www.andy-roberts.net/writing/latex/mathematics_2 此处仅举个例子(因为begin end方式我还不够了解)： $$ p(x|y) = \\frac{p(y|x)p(x)}{p(y)} $$ 效果 $$ p(x|y) = \\frac{p(y|x)p(x)}{p(y)} $$ $p(x|y) = \\frac{p(y|x)p(x)}{p(y)}$ 效果 $p(x|y) = \\frac{p(y|x)p(x)}{p(y)}$","text_tokens":[":","}","具体","tutorial","我","and","http","www","1","quick"," ","和","]","/","andy","|","2","roberts","有","p","=","stackexchange","[","种","meta","basic","_","个","latex","questions","net","x","...","-","{","写法",")","mathjax","\\","方式",".","end","效果","mathematics","因为","不够","：","详见","y","了解","(","例子","还","math","用法","仅举","行内","$",",","writing","frac","此处","com","5020","3","区块","reference","https","begin"],"title":"Math usage","title_tokens":[" ","usage","math"]},{"location":"syntax/meta/","text":"依赖模块：meta mkdocs支持(实际是python markdown支持)的元信息内容，会被自动转为对应的html，目前支持以下4种meta title: Lorem ipsum dolor sit amet description: Nullam urna elit, malesuada eget finibus ut, ac tortor. path: path/to/file source: file.js 注意: 要写在markdown文档的最上方 写完后要加一个空行 会被自动翻译成 <head> <meta name=\"description\" content=\"Nullam urna elit, malesuada eget finibus ut, ac tortor.\"> <title>Lorem ipsum dolor sit amet</title> </head> 以及<body>中某个位置会看到<a href=\"/path/to/file/file.js\" title=\"file.js\" class=\"md-source-file\"> 其中path和source的效果:","text_tokens":["nullam","/","翻译","urna","elit","是","path","对应","malesuada","中","dolor","文档","元",",","空行","tortor",":","实际","lorem","sit","class","js","name","=","信息内容","\"","种","-","某个",".","会","以及","目前","内容","<","markdown","a","一个","4","自动","title","要加","mkdocs","被","注意","其中","ac","的","file","content","上方","在","依赖","body","看到","译成","最","ipsum","完后","(","以下","，","to","ut","eget","source","位置","要"," ","和","md","head","amet","href","html","写","支持","meta",">",")","finibus","python","效果","翻译成","：","description","转为","信息","模块"],"title":"Meta","title_tokens":["meta"]},{"location":"syntax/nest_green_code/","text":"效果 {++ #!python print \"Hello, world!\" ++} {++ #!python print \"Hello, world!\" ++} {++ print \"Hello, world!\" ++}","text_tokens":["!","++","}","#","效果","python",",","\""," ","print","hello","world","{"],"title":"Nest green code","title_tokens":["nest","code"," ","green"]},{"location":"syntax/nest_greenred_code/","text":"效果 {~~ #!python print \"Hello, world!\" ~> #!python print \"Hello, our world!\" ~~} {~~ print \"Hello, my world!\" ~> print \"Hello, our world!\" ~~}","text_tokens":["!","}","#","效果","python",",","\"","our","my"," ",">","print","hello","world","{","~"],"title":"Nest greenred code","title_tokens":["nest","greenred"," ","code"]},{"location":"syntax/nest_list_code/","text":"以下3种效果相同: 一. 不缩进，无空行 - list1 ```python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 二. 缩进，无空行 - list1 ```python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 三. 缩进，有空行 - list1 ```python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果均如下 list1 python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 注意: 不能无缩进却有空行，如下面这样是有问题的，可以自行测试: - list1 ```python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ```","text_tokens":[":","`","测试","可以"," ","注意","均","hello","二","有","!","的","=","不","text2","是","\"","种","相同","无","text1","+","却","world","-","三","问题",".","效果","python","一","这样","不能","缩进","如下","以下","自行","，",",","如","下面","list1","空行","3","print"],"title":"Nest list code","title_tokens":["nest","code","list"," "]},{"location":"syntax/nest_list_list/","text":"- aaa - bbb 效果 aaa bbb","text_tokens":["效果"," ","aaa","-","bbb"],"title":"Nest list list","title_tokens":["nest","list"," "]},{"location":"syntax/nest_list_list_quote/","text":"- aaa - bbb > ccc 效果 aaa bbb ccc","text_tokens":["效果"," ",">","aaa","-","bbb","ccc"],"title":"Nest list list quote","title_tokens":["nest","quote","list"," "]},{"location":"syntax/nest_main/","text":"几乎每种具有行内、区块的功能模块都能自身及相互之间多层嵌套，本文无法一一阐述，因此仅举几个例子说明","text_tokens":["几个","及","自身","本文","因此","具有","都","相互之间","的","无法","相互","功能模块","能","之间","一一","多层","每种","阐述","嵌套","例子","，","几乎","仅举","行内","说明","、","功能","区块","模块"],"title":"Nest main","title_tokens":["nest","main"," "]},{"location":"syntax/nest_note_code/","text":"依赖模块: pymdownx.superfences !!! note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. ```python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果 !!! note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2","text_tokens":[":","in","nulla","et","consequat","nec","lorem","`","curabitur","sit","note"," ","hello","amet","!","elit","euismod","=","superfences","text2","依赖","\"","text1","+","pymdownx","world","semper","finibus",".","feugiat","ipsum","python","效果","dolor","adipiscing","massa","consectetur","justo","non","purus",",","quam","auctor","print","模块","tortor"],"title":"Nest note code","title_tokens":["nest","code"," ","note"]},{"location":"syntax/nest_note_list_quote/","text":"!!! note \"test\" - aaa > bbb 效果 !!! note \"test\" - aaa > bbb","text_tokens":["!","效果","\"","note"," ",">","aaa","-","bbb","test"],"title":"Nest note list quote","title_tokens":["nest","note"," ","quote","list"]},{"location":"syntax/nest_note_note/","text":"!!! note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. 效果 !!! note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","text_tokens":["in","nulla","et","consequat","nec","lorem","curabitur","sit","note"," ","amet","!","elit","euismod","warning","semper","finibus",".","feugiat","ipsum","效果","dolor","adipiscing","massa","consectetur","justo","non","purus",",","quam","auctor","tortor"],"title":"Nest note note","title_tokens":["nest"," ","note"]},{"location":"syntax/nest_quote_code/","text":"> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod > nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor > massa, nec semper lorem quam in massa. > ```go import \"fmt\" func main() { fmt.Println(\"Hello, world\") } ``` 效果 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. go import \"fmt\" func main() { fmt.Println(\"Hello, world\") } 可以看出，用>时候，要每行的>内容缩进对齐，不过，如果是一个代码块的话，只需要第一个>即可 但要注意, 上面这种方法不能有空行，如果有空行就会被认为终止，比如： > ```go import \"fmt\" func main() { fmt.Println(\"Hello, world\") fmt.Println(\"last\") } ``` 要解决这个问题，就要在空行之后的新行再用>表示未中断，比如： > ```go import \"fmt\" func main() { fmt.Println(\"Hello, world\") > fmt.Println(\"last\") } ``` ```go import \"fmt\" func main() { fmt.Println(\"Hello, world\") fmt.Println(\"last\") } ```","text_tokens":["in","解决","需要","可以","之后","hello","方法","有","elit","是","println","不过","只","semper","feugiat","dolor","不能","缩进","massa",",","fmt","空行","tortor","import","consequat","lorem","`","sit","认为","euismod","\"","func","看出",".","的话","会","adipiscing","内容","第一个","这个","consectetur","non","purus","一个","quam","用","第一","auctor","代码","}","被","注意","的","在","last","未","world","问题","ipsum","go","比如","如果","(","表示","justo","，","时候","nulla","et","即可","nec","每行","curabitur","要"," ","新行","上面","amet","中断",">","再","{",")","finibus","main","对齐","效果","就","终止","这种","：","但","就要","块"],"title":"Nest quote code","title_tokens":["nest","quote","code"," "]},{"location":"syntax/nest_quote_quote/","text":"> 区块引用 >> 嵌套引用 效果 区块引用 嵌套引用","text_tokens":["效果"," ","嵌套",">","引用","区块"],"title":"Nest quote quote","title_tokens":["nest","quote"," "]},{"location":"syntax/nest_quote_quote_code/","text":"> aaa >> bbb >>> ```python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2 ``` 效果 aaa bbb python text1 = \"Hello, \" text2 = \"world!\" print text1 + text2","text_tokens":["!","=","python","效果","`",",","\"","text2","text1","+"," ",">","hello","print","world","aaa","bbb"],"title":"Nest quote quote code","title_tokens":["nest","quote","code"," "]},{"location":"syntax/nest_red_code/","text":"效果 {-- #!python print \"Hello, world!\" --} {-- #!python print \"Hello, world!\" --} {-- print \"Hello, world!\" --}","text_tokens":["!","}","#","效果","python",",","\"","--"," ","print","hello","world","{"],"title":"Nest red code","title_tokens":["nest","red","code"," "]},{"location":"syntax/nest_yellow_code/","text":"效果 {== #!python print \"Hello, world!\" ==} {== #!python print \"Hello, world!\" ==} {== print \"Hello, world!\" ==}","text_tokens":["!","}","#","=","效果","python",",","\""," ","print","hello","world","{"],"title":"Nest yellow code","title_tokens":["nest","yellow","code"," "]},{"location":"syntax/note_details/","text":"把!!!改成???，注意此时标题不能为空，否则样式有问题 适用场景: 折叠特别适用于FAQ，即标题里写问题，内容里写答案 依赖模块: pymdownx.details ??? note \"标题\" 内容 效果 ??? note \"标题\" 内容 注意: 折叠中的内容在折叠未打开时候通过ctrl-f是搜索不出来的，但可以通过页面上方的Search栏里搜到","text_tokens":[":","场景","faq","里","note","可以"," ","注意","搜索","页面","有","!","的","此时","写","出来","上方","不","改成","在","样式","答案","依赖","否则","把","即","\"","适用","是","未","特别","pymdownx","-","于","问题","details",".","效果","标题","中","搜到","不能","但","内容","为空","f","?","，","时候","ctrl","search","打开","栏里","模块","通过","折叠"],"title":"Note details","title_tokens":[" ","details","note"]},{"location":"syntax/note_empty-title/","text":"!!! note \"\" 内容 效果 !!! note \"\" 内容","text_tokens":["!","效果","\"","note"," ","内容"],"title":"Note empty title","title_tokens":[" ","empty","title","note"]},{"location":"syntax/note_full/","text":"!!! note \"标题\" 内容 效果 !!! note \"标题\" 内容","text_tokens":["!","效果","标题","\"","note"," ","内容"],"title":"Note full","title_tokens":[" ","full","note"]},{"location":"syntax/note_main/","text":"写注解使用，依赖模块: admonition 支持多种样式，如带有标题、无标题、空标题，还支持折叠式(常用于FAQ) 支持多种颜色风格，包括警告提示、错误提示、成功提示等11种风格","text_tokens":[":","faq","折叠式","admonition"," ","包括","写","注解","提示","11","依赖","支持","样式","种","使用","于",")","颜色","风格","错误","标题","警告","空","等","(","还","，","常用","无标题","如","、","多种","成功","带有","模块","折叠"],"title":"Note main","title_tokens":[" ","main","note"]},{"location":"syntax/note_nest/","text":"注解标题和内容支持多种样式 例1. 标题里使用斜体 !!! note \"*标题e*\" 内容 !!! note \" 标题 \" 内容 例2. 内容里使用h1-h6 !!! note \"标题\" # h1 ## h2 ### h3 注解嵌套代码块 详见 注解嵌套代码块 章节 注解嵌套注解 详见 注解嵌套注解 章节","text_tokens":["里","1","##","h2","note","和"," ","2","h1","!","注解","斜体","支持","样式","\"","使用","-","例",".","h3","标题","嵌套","内容","e","详见","块","h6","#","代码","多种","*","###","章节"],"title":"Note nest","title_tokens":[" ","nest","note"]},{"location":"syntax/note_nest/#_1","text":"例1. 标题里使用斜体 !!! note \"*标题e*\" 内容 !!! note \" 标题 \" 内容 例2. 内容里使用h1-h6 !!! note \"标题\" # h1 ## h2 ### h3","text_tokens":["里","1","##","h2","note"," ","2","h1","!","斜体","\"","使用","-","例",".","h3","标题","内容","e","h6","#","*","###"],"title":"注解标题和内容支持多种样式","title_tokens":["注解","标题","支持","样式","和","多种","内容"]},{"location":"syntax/note_nest/#_2","text":"详见 注解嵌套代码块 章节","text_tokens":["注解","章节"," ","嵌套","详见","代码","块"],"title":"注解嵌套代码块","title_tokens":["代码","嵌套","注解","块"]},{"location":"syntax/note_nest/#_3","text":"详见 注解嵌套注解 章节","text_tokens":["注解"," ","嵌套","详见","章节"],"title":"注解嵌套注解","title_tokens":["嵌套","注解"]},{"location":"syntax/note_none-title/","text":"!!! note 内容 效果 !!! note 内容 注意: 无标题时类型首字母会被大写，如上面note被大写成Note","text_tokens":[":","note"," ","被","注意","类型","上面","!","大写","写成","大","首字母","首字","时","效果","标题","会","内容","字母","，","无标题","如"],"title":"Note none title","title_tokens":[" ","none","title","note"]},{"location":"syntax/note_none-type/","text":"无类型，则默认为note 注意这个时候标题必须写英文，并且首字母会被自动转成大写: !!! title 内容 相当于 !!! note \"Title\" 内容 效果 !!! title 内容","text_tokens":[":","title","note"," ","被","相当","注意","类型","成","大写","!","写","则","英文","必须","\"","无","相当于","首字母","首字","并且","效果","标题","会","转","内容","字母","这个","默认","，","为","时候","当于","自动"],"title":"Note none type","title_tokens":[" ","none","type","note"]},{"location":"syntax/note_style/","text":"有11种样式，每一种样式都支持多种关键字，比如note可以用seealso替代，summary可以用tldr替代 !!! note \"note, seealso\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! summary \"summary, tldr\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! info \"info, todo\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! tip \"tip, hint, important\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! success \"success, check, done\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! question \"question, help, faq\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! warning \"warning, caution, attention\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! failure \"failure, fail, missing\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! danger \"danger, error\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! bug \"bug\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! quote \"quote, cite\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. 效果 !!! note \"note, seealso\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! summary \"summary, tldr\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! info \"info, todo\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! tip \"tip, hint, important\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! success \"success, check, done\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor !!! question \"question, help, faq\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! warning \"warning, caution, attention\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! failure \"failure, fail, missing\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! danger \"danger, error\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! bug \"bug\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. !!! quote \"quote, cite\" Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","text_tokens":["faq","in","nulla","et","consequat","nec","lorem","important","curabitur","sit","note","可以"," ","cite","都","每","todo","success","amet","有","!","question","bug","elit","euismod","关键","11","样式","支持","\"","种","help","quote","warning","attention","hint","error","info","summary","semper","finibus","关键字",".","feugiat","ipsum","效果","fail","done","比如","替代","dolor","adipiscing","massa","consectetur","tldr","missing","，","non","justo","seealso","purus","tip","failure",",","用","quam","多种","check","auctor","caution","一种","tortor","danger"],"title":"Note style","title_tokens":[" ","style","note"]},{"location":"syntax/paragraph/","text":"一个段落表示一个语法块，每个语法块之间要有空行，若想在段内强制换行的方式是使用 两个以上 空格加上回车。 建议: 如果写一个语法，效果和想象的不一样，比如挤在一行内，或者没有缩进，则多1、2个换行试试","text_tokens":["。",":","1","想象","若想","要"," ","和","回车","加上","2","挤","每个","换行","有","的","内","写","则","多","不","一样","在","是","语法","使用","个","建议","段","强制","之间","段落","试试","方式","以上","空格","效果","或者","比如","如果","缩进","块","表示","没有","，","一个","、","两个","一行","空行"],"title":"Paragraph","title_tokens":["paragraph"]},{"location":"syntax/quote/","text":"在段落的每行或者只在第一行使用符号 > 还可使用多个 嵌套引用 ，如： > 区块引用 效果： 区块引用","text_tokens":["每行"," ","可","的","在","多个","使用",">","只","段落","效果","或者","嵌套","：","符号","还","，","第一行","如","第一","一行","引用","区块"],"title":"Quote","title_tokens":["quote"]},{"location":"syntax/symbol/","text":"依赖模块: pymdownx.smartsymbols 用法 效果 (tm) (tm) (c) (c) (r) (r) c/o c/o +/- +/- --> --> <-- <-- <--> <--> =/= =/= 1/4 3/5 1/4 3/5 1st 2nd 3rd 1st 2nd 3rd","text_tokens":[":","1"," ","/","c","=","r","依赖","--","+",">","pymdownx","tm","-",")",".","效果","1st","o","<","(","3rd","用法","smartsymbols","4","5","2nd","3","模块"],"title":"Symbol","title_tokens":["symbol"]},{"location":"syntax/table/","text":"示例 | 字段1 | 字段2 | 字段3 | | :-- | :--: | --: | | A1 | B1 | C1 | | A2 | B2 | C2 | 效果 字段1 字段2 字段3 A1 B1 C1 A2 B2 C2 详解 至少由3行组成 第1行：字段名 text | 字段1 | 字段2 | 字段3 | 第2行：\b设置对齐 text | :-- | :--: | --: | 分别表示为左对齐，居中对齐，又对齐。另外，也可以不设置对齐，即不写冒号，但这样不好维护，因此建议都设置对齐 第3行开始：正文 text | 内容1 | 内容2 | 内容3 | !!! warning \"空格不可忽略\" text |字段1|字段2|字段3| 这样是有问题的，空格1个，也可以多个，但不能不写 !!! note \"最左边和最右边的|可省略\" text | 字段1 | 字段2 | 字段3 | 也可以写成这样 ```text 字段1 | 字段2 | 字段3 ``` 不仅是第1行，每一行都可以这么省略","text_tokens":["1","b2","可以","都","2","有","!","是","a2","多个","不能不","行","忽略","这样","这么","不能","左边",":","。","省略","`","示例","\"","个","b1","由","开始","c2","内容","a1","第","不仅","c1","又","note","因此","左","组成","text","不好","的","居中","字段","维护","即","warning","建议","右边","\b","问题","最","字段名","至少","表示","，","一行","设置","也","正文"," ","和","|","可","每","分别","写","不","--","另外","写成","冒号","对齐","不可","空格","效果","：","但","为","详解","3"],"title":"Table","title_tokens":["table"]},{"location":"syntax/table/#_1","text":"| 字段1 | 字段2 | 字段3 | | :-- | :--: | --: | | A1 | B1 | C1 | | A2 | B2 | C2 | 效果 字段1 字段2 字段3 A1 B1 C1 A2 B2 C2","text_tokens":[":","字段","效果","1","c1","a2","--","b2"," ","b1","|","2","3","c2","a1"],"title":"示例","title_tokens":["示例"]},{"location":"syntax/table/#_2","text":"至少由3行组成 第1行：字段名 text | 字段1 | 字段2 | 字段3 | 第2行：\b设置对齐 text | :-- | :--: | --: | 分别表示为左对齐，居中对齐，又对齐。另外，也可以不设置对齐，即不写冒号，但这样不好维护，因此建议都设置对齐 第3行开始：正文 text | 内容1 | 内容2 | 内容3 | !!! warning \"空格不可忽略\" text |字段1|字段2|字段3| 这样是有问题的，空格1个，也可以多个，但不能不写 !!! note \"最左边和最右边的|可省略\" text | 字段1 | 字段2 | 字段3 | 也可以写成这样 ```text 字段1 | 字段2 | 字段3 ``` 不仅是第1行，每一行都可以这么省略","text_tokens":[":","。","省略","又","正文","1","`","可以","因此"," ","note","和","左","组成","|","2","都","text","可","每","不好","分别","!","有","写","居中","字段","维护","的","不","是","\"","--","另外","即","多个","写成","个","冒号","建议","warning","\b","不能不","行","右边","忽略","对齐","不可","问题","空格","最","由","这样","开始","字段名","这么","：","但","不能","至少","内容","第","表示","为","，","不仅","一行","设置","3","也","左边"],"title":"详解","title_tokens":["详解"]},{"location":"things/algorithm/","text":"HashMap 概念 用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。 put方法原理 调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。 get方法 首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找 初始化长度 初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。 高并发下的HashMap Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap. 什么是ConcurrentHashMap？ ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。 put和get原理 get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash 红黑树 （数据结构） 二叉树的特性 1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树 红黑树特性 节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。 调整红黑树的两种方法（变色、旋转） AES算法（对称加密算法） MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。 三个基本概念（密钥、填充、模式） 密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。 在java中的具体实现 注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。 AES算法的底层原理 一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey） 字节替代 subByte 十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11] 行移位 shiftRows 如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节 列混淆MixColumns 输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列 加 论密钥(add round key) 128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。 不同工作模式在加密流程中有什么不同？ 所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度 MD5 可以从任意长度的明文字符串生成128位的哈希值 验签过程 1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制 MD5底层原理 分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c Base64 排序 冒泡算法和优化","text_tokens":["异或","知道","get","缺少","175","二块","sign","1","拆分","i","一个个","进行","feedback","二个","怎么","三步","不断","完全","是","多个","优势","任一","分成","_","第二","32","匹配","过去","对比","第四个","二叉","第四行","d","扩容","0x76543210","创造者","出现","cipher","128","4x4","当前","1234","计算器","分段","aes","一股","h","几乎","大小","遇到","张图","这","只要","容量","水线","字符","使得","hash","多少","第一位","指针","论","put","干涉","java8","一直","经过","电码本","很多","参数值","0xfedcba98","=","进制","（","[","现象","相当于","只有","主干","-","意思","用于","z","结构","由","开始","j","限制","会","其它","验证","本身","这个","大打折扣","没有","密码","实现","a","初始值","4","函数","映射","第一","有限","pkcs5padding","代码","包含","通过","树","之所以","101110001110101110","aes256","旋转","代表","持有","概念","一列","加盐","即","总","当","将","8","nopadding","旧","取代","round","加","最","缺点","md5","resize","64","传输","难免","segment","根","完后","签名","表示","内部","数","流程","读写","时候","shiftrows","次数","一共","位置","盒","演变","坏人","mj"," ","为了","几种","每","决定","上面","发送","加入","结果","理过","尾端","参与","归纳","mixcolumns","几位","两次","因为","完整","大于","反馈","分组","完成","y","码本","有利","田字","直到","第一行","过程","信息","哈希","填充","并发","幂","两位","复杂度","所","任意","用到","计算","/","交替","第二行","都","255","最高","体现","c","n","结束","subtitution","ecb","假设","因子","addroundkey","既","思想","大","15","说","10","^","整个","最终","求余","语言","左子","sha256","如下","非线性","m16","ecb2","加解密","好","当于","两个","修补","左右","增长","如何","同时","让","且","替换","模式","aes192","之一","达到","0x01234567","累加","带上","size","原来","acount","例如","阈值","31","成","链接","负载","安全性","数倍","防止","amout","输入","必须","阶段","数值","私密","除了","可能性","个","差别","之间","时","调用","顺着","codebook","得出","规则","加轮","互不干涉",".","12","工作","ctr","或者","subbyte","高","降低","一次","对象","底层","表","数据结构","加密","默认","7","16","操作","后面","属于","输出","中当","5","四种","量值","电码","3029737","一把","起来","新","java","一组","或","第四","任何","subbytes","}","16x16","十六","192bit","add","平台","被","得到","那么","金额","iso126padding","列","环","一等","独立","第三行","基本概念","安全","排列成","这些","index","子","loadfactor","ki","两件","两种","有利于","以上","右子","就是","比如","流水","三种","空","校验","可逆","篡改","释放","等份","counter","锁","依次","生成","对","一行","也","变化","整数倍","1001","黑色","连续","组是","键值","具体","00","如图","即可","双方","相当","官方","|","所以","outputfeedback","ade876ishdfakhdj","混淆","循环","攻击","常量","不","initial","但是","红黑树","等同于","使用","二级","当新","头",">","另外","长度","原文","处理","四行",")","发生变化","不变","获取","请求","二进制","排序","book","&","性能","key","第一步","粒度","矩阵","重新","块","不同","带","#","主要","关联","k","一股脑","二行","链表","越来越","两倍","调整","整段","3","成一","s","一位","一致性","外","electronoc","解决","需要","不如","是非","收集","-------------------------","iv","均","2","元素","额外","final","多","等于","赋值","冒泡","+","要求","aes128","所有","只","大家","行","指向","例","创建","定位","拆","发生","较差","entry","超过","线程","分布","验签","向","从根","主体","变成","而","对称","接插","常用","g",",","一致","越来","记录","移位","显然","无误","一起",":","数目","数组","上","并行计算","实际","同一个","集合","完整性","体位","）","512","共","与","ofb","某种","\"","相同","密钥","一段","二分","密文","做","攻击者","运算","按照","支付","假定","作为","补全","次子","流水线","四步","第一个","第","相应","<","hashcode","中有","一个","少于","keyexpentions","名","vector","只能","concurrenthashmap","最大","有些","普通","补足","值","存储","表面","原始","遍历","不止","增加","下图","从","ff","插入","左","下","根据","线性","查找","写入","注意","同样","向量","前","所用","一样","冲突","在","最好","典型","轮","保证","近似","走到","mi","种子","很","而是","9","(","左移","二维","组","搞笑","cfb","加工","铭文","剩余","尝试","0.75","原本","折扣","节点","要","步骤","]","单","value","为什么","解密","参数","创造","刚好","第三","capacity","事情","cbc","不是","w","再","block","泄漏","bit","处理过程","fix","实践","这种","null","后续","次","5b","轮数","换成","第三个","说明","封装","不足","插法","下面","64bit","个个","可能","electronic","表达","三行","第二块","接收","分散","字","主","均匀分布","并行","0","可以","图中","右","之后","分为","打折扣","利于","方法","hashmap","有","等同","难免会","算器","命名","那个","？","优点","rehash","引入","找","首先","利用","initialization","后","四个","技术","十进制","方式","绿色","算法","对应","中","这样","是因为","不能","摘要","m","原","整数","有点","产生","是否","有个","出","256","1111","字符串","第二个","约定","呢","chainning","0x89abcdef","情况","加密算法","。","十六进制","~","这里","单次","黄色","原理","同一","互不","宏观","字节","重入","更高","认为","位","提供","五种","”","具体位置","则","前会","11","值补","许多","原先","修改","打折","叶子","直接","并","zegment","abcd","三方","一轮","平时","替代","m15","高度","e","条件","覆盖","账户","相加","二叉树","三个","随之","变色","路径","孩子","用","有点像","二进制位","其余","128bit","*","由于","扩展","直接插入","又","真正","b","业务","数量","相关","排列","采用","每个","13","的","47","作用","了","上锁","简单","无法","next","把","第三方","代替","田","随机","beauty","m0","问题","448","》","拼接","小于","14","数据","子树","如果","均匀","base64","最后","复杂","box","特性","，","平衡","到","当中","设置","替换成","同于","效率","一步","影响","取决","依据","叫做","rounds","和","“","来","可","matrix","优化","基本","分别","全为","支持","6","它","x","m1","{","明文","\\","......","目标","初始","什么","就","末尾","细节","chaining","二位","：","初始化","源代码","length","f","加密器","160","列成","为","192","取决于","各种","给定","、","阻塞","份","相乘","向下","除去","加锁","红色","统计","生变"],"title":"Algorithm","title_tokens":["algorithm"]},{"location":"things/algorithm/#hashmap","text":"","text_tokens":[],"title":"HashMap","title_tokens":["hashmap"]},{"location":"things/algorithm/#_1","text":"用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。","text_tokens":["。","分散","键值","数组","get","叫做","集合"," ","和","value","）","都","put","每","元素","hashmap","的","方法","在","是","（","这些","主干","-",")","用于","最","初始","就是","中","entry","key","null","这个","(","，","常用","初始值","一个",",","对","也","存储"],"title":"概念","title_tokens":["概念"]},{"location":"things/algorithm/#put","text":"调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。","text_tokens":["1","0","可以","2","元素","hashmap","难免会","多","是","大","后","指向","对应","创造者","entry","出现","超过","变成","接插","遇到",",","越来","。","数组","size","指针","put","认为","java8","”","=","\"","现象","可能性","时","调用","-","假定","得出","直接",".","对象","会","hashcode","中当","一个","通过","直接插入","不止","插入","被","下","查找","采用","的","冲突","next","当","index","8","beauty","难免","最后","(","，","到","位置","即可","节点"," ","“","创造","每","但是","红黑树","当新","头","它","长度",")","&","key","：","为","链表","插法","越来越","可能"],"title":"put方法原理","title_tokens":["put","方法","原理"]},{"location":"things/algorithm/#get","text":"首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找","text_tokens":["位置","上","size","hash","1","同一个","需要","节点"," ","同一","根据","得到","hashmap","的","有","=","输入","多个","index","头","找","首先","做","匹配","顺着","-",")",".","entry","一次","&","key","这个","(","hashcode","，","时候","一个",",","链表","映射","可能","到","向下"],"title":"get方法","title_tokens":["get","方法"]},{"location":"things/algorithm/#_2","text":"初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。","text_tokens":[":","。","101110001110101110","取决","size","hash","1","计算","-------------------------"," ","下","2","所以","同于","hashmap","的","与","全为","等同","=","输入","进制","是","结果","等同于","index","15","长度","做","1001","运算","-","后",")","例","十进制","以上",".","算法","二进制","初始","book","对应","几位","就是","&","这种","key","初始化","其它","9","均匀","length","最后","本身","(","hashcode","16","情况","为","，","后面","取决于",",","函数","1111","两个","只要","增长","哈希","3029737","3","二进制位","幂","值","或"],"title":"初始化长度","title_tokens":["初始","初始化","长度"]},{"location":"things/algorithm/#hashmap_1","text":"Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap.","text_tokens":["解决","需要","1","计算","是非","2","进行","hashmap","方法","那个","因子","是","？","rehash","后","创建","扩容","发生","出现","线程","当前","如下","是否","容量","如何","情况",":","达到","。","数组","size","hash","原来","负载","=","做","规则",".","会","条件","默认","随之","concurrenthashmap","有限","新","*","下","的","环","了","在","安全","index","loadfactor","两件","resize","(","，","时候","也","变化","0.75","要"," ","为什么","capacity","事情","使用",">","长度",")","发生变化","什么","因为","：","f","链表","两倍","可能","并发","幂","生变"],"title":"高并发下的HashMap","title_tokens":["的","高","下","并发","hashmap"]},{"location":"things/algorithm/#concurrenthashmap","text":"ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。","text_tokens":["。","影响","又","hash","需要","同一个"," ","相当","互不","同一","持有","都","写入","更高","采用","每个","的","怎么","独立","并发","了","上锁","是","安全","？","优势","二级","相当于","它","之间","保证","技术","zegment","就是","降低","segment","线程","表","粒度","分段","，","操作","实现","读写","当于","搞笑","一个","锁","阻塞","concurrenthashmap","如何","一把","同时","让","效率"],"title":"什么是ConcurrentHashMap？","title_tokens":["concurrenthashmap","？","什么","是"]},{"location":"things/algorithm/#putget","text":"get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash","text_tokens":["get","均匀分布","计算","1","方法","元素","进行","结束","+","所有","定位","中","entry","超过","分布","是否",",","数组","累加","上","size","hash","原理","阈值","体位","重入","put","具体位置","则","输入","修改","做","时","运算",".","或者","一次","对象","覆盖","没有","实现","中有","一个","concurrenthashmap","起来","值","通过","遍历","插入","数量","得到","的","了","在","把","总","将","segment","如果","均匀","，","释放","锁","对","到","次数","尝试","具体","位置"," ","为了","可","每","不是","再","获取","两次","大于","key","重新","说明","过程","3","加锁","统计"],"title":"put和get原理","title_tokens":["put","get","和","原理"]},{"location":"things/algorithm/#_3","text":"","text_tokens":[],"title":"红黑树  （数据结构）","title_tokens":["结构","（","红黑树"," ","数据","）","数据结构"]},{"location":"things/algorithm/#_4","text":"1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树","text_tokens":["解决","1","右","均","2","打折扣","方法","结束","等于","是","？","所有","思想","找","10","利用","二叉","例","从根","左子","变成","如下","几乎","左右","如何","11","相同","二分","打折",".","或者","开始","高度","大打折扣","二叉树","4","5","孩子","最大","值","由于","树","插入","左","线性","查找","13","的","了","8","右子","走到","缺点","根","小于","子树","9","，","平衡","依次","也","次数","折扣","节点"," ","分别","不","6","红黑树","它","排序","就","性能","大于","这种","：","为","、","3"],"title":"二叉树的特性","title_tokens":["的","特性","二叉树","二叉"]},{"location":"things/algorithm/#_5","text":"节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。","text_tokens":["数目","。","从","节点"," ","都","每个","有","的","是","相同","任一","所有","子","叶子",")","或者","根","null","空","不能","(","两个","路径","到","红色","包含","黑色","连续"],"title":"红黑树特性","title_tokens":["特性","红黑树"]},{"location":"things/algorithm/#_6","text":"","text_tokens":[],"title":"调整红黑树的两种方法（变色、旋转）","title_tokens":["的","变色","、","（","旋转","红黑树","调整","）","两种","方法"]},{"location":"things/algorithm/#aes","text":"MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。","text_tokens":["。","一致性","完整性","和","被","进行","的","作用","不","是","私密","保证","泄漏","md5","算法","完整","sha256","摘要","校验","加密","对称","可逆","，","属于","主要","对","一致","信息","加密算法"],"title":"AES算法（对称加密算法）","title_tokens":["算法","（","）","加密","aes","对称","加密算法"]},{"location":"things/algorithm/#_7","text":"密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。","text_tokens":["成一","缺少","二块","需要","拆分","1","计算","2","最高","体现","一个个","进行","c","feedback","算器","ecb","等于","是","？","要求","分成","aes128","思想","说","第二","大家","后","方式","例","d","拆","算法","整个","最终","中","语言","cipher","128","主体","计算器","aes","整数","一股","有个","g","256",",","且","一起","aes192","。",":","字符","模式","加密算法","上","实际","字节","成","）","链接","安全性","数倍","位","经过","提供","五种","ofb","电码本","则","必须","某种","（","许多","相同","只有","密钥","一段","个","差别","密文","做","时","之间","codebook","并","补全","工作","ctr","平时","其它","e","加密","相应","这个","默认","16","7","密码","输出","a","中有","一个","少于","4","5","用","电码","有些","128bit","pkcs5padding","补足","值","任何","}","aes256","192bit","从","b","数量","注意","同样","采用","每个","iso126padding","的","独立","了","最好","安全","在","典型","把","这些","8","nopadding","近似","随机","问题","就是","拼接","而是","三种","如果","最后","复杂","(","，","数","时候","counter","cfb","生成","对","铭文","也","整数倍"," ","几种","解密","outputfeedback","不","加入","支持","结果","但是","6","cbc","使用","不是","理过","长度","处理","{","block",")","明文","\\","尾端","处理过程","就","什么","末尾","细节","book","性能","chaining","：","反馈","分组","码本","加密器","块","不同","轮数","192","为","#","一股脑","不足","、","过程","64bit","个个","整段","可能","electronic","填充","3","第二块"],"title":"三个基本概念（密钥、填充、模式）","title_tokens":["概念","三个","基本概念","、","（","密钥","填充","）","基本","模式"]},{"location":"things/algorithm/#java","text":"注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。","text_tokens":["。","上","原本","外","真正","注意","字节","解密","都","数倍","的","额外","除了","使用","不是","密钥","nopadding","时","调用","长度","并","方式","明文","用于","算法","种子","就是","会","而是","：","key","其它","如果","aes","整数","16","块","，","加解密","好","封装","生成","填充","整数倍","一组","表面"],"title":"在java中的具体实现","title_tokens":["的","具体","实现","在","中","java"]},{"location":"things/algorithm/#aes_1","text":"一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey）","text_tokens":["需要","1","0","255","有","n","final","？","addroundkey","aes128","10","行","四个","最终","对应","如下","aes",",","两个","移位","aes192","。","十六进制","~","多少","字节","成","）","论","位","经过","很多","阶段","进制","（","只有","密钥","密文","加轮","12","由","一次","加密","三个","一个","普通","subbytes","十六","aes256","ff","列","的","把","轮","代替","round","》","而是","14","(","表示","，","shiftrows","也","具体","00","rounds","步骤"," ","可","混淆","刚好","initial","不是","长度","处理",")","明文","mixcolumns","初始","key","：","次","不同","轮数","各种","除去"],"title":"AES算法的底层原理","title_tokens":["的","算法","原理","底层","aes"]},{"location":"things/algorithm/#subbyte","text":"十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11]","text_tokens":["。","数组","s","盒","16x16","十六","依据","步骤","例如"," ","被","]","字节","b","两位","都","2","排列","那么","每","位","的","常量","subtitution","=","11","在","是","[","另外","进制","排列成","把","处理",")","明文","就是","中","替代","二位","第一个","4x4","(","块","box","列成","，","换成","二维","大小","a","5b","输出","一个",",","5","第一","替换成","值","替换","通过","十六进制"],"title":"字节替代 subByte","title_tokens":[" ","subbyte","字节","替代"]},{"location":"things/algorithm/#shiftrows","text":"如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节","text_tokens":["如图"," ","第二行","字节","第三","循环","第三行","第二","四行","第四行","不变","：","左移","三个","二行","第一行","一个","两个","第一","一行","三行","第四"],"title":"行移位 shiftRows","title_tokens":["行","移位"," ","shiftrows"]},{"location":"things/algorithm/#mixcolumns","text":"输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列","text_tokens":["数组","要","和"," ","得到","每","matrix","列","的","一列","常量","输入","做",")","明文","对应","fix","二位","矩阵","(","，","输出","一个","修补","相乘"],"title":"列混淆MixColumns","title_tokens":["混淆","列","mixcolumns"]},{"location":"things/algorithm/#add-round-key","text":"128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。","text_tokens":["异或","175","用到","1","计算","0","i","都","2","元素","等同","赋值","是","+","所有","15","32","10","对应","最终","中","4x4","aes","而",",","。","数组","31","字节","）","一直","与","输入","[","（","密钥","做","-","用于","一轮","由","j","一次","加密","第","16","输出","a","一个","4","keyexpentions","用","128bit","*","代码","值","存储","扩展","}","b","被","同样","排列","的","47","了","排列成","轮","(","，","生成","到","当中","同于","位置"," ","]","来","和","每","原始","等同于","长度","w","处理","{",")","......","就","初始","源代码","后续","完成","矩阵","160","列成","不同","为","直到","k"],"title":"加 论密钥(add round key)","title_tokens":["round","加","add"," ","密钥","key","论","(",")"]},{"location":"things/algorithm/#_8","text":"所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度","text_tokens":["复杂度","异或","所","electronoc","1","并行","计算","不如","iv","都","2","体现","利于","ecb","完全","是","优点","所有","引入","initialization","只","较差","这样","cipher","变成","aes","有点","出","ecb2",",","chainning","让","显然","模式","。",":","上","并行计算","宏观","互不","成","防止","安全性","更高","干涉","经过","与","前会","相同","差别","密文","之间","做","codebook","作为","互不干涉",".","工作","会","第一个","加密","操作","一个","vector","有点像","第一","值","增加","同样","向量","前","的","概念","独立","简单","了","作用","加盐","一样","在","安全","无法","即","有利于","最","缺点","md5","(","复杂","内部","，","流程"," ","和","每","不","cbc","处理","block",")","明文","参与","初始","book","性能","：","初始化","后续","有利","加密器","块","关联"],"title":"不同工作模式在加密流程中有什么不同？","title_tokens":["不同","流程","工作","中有","在","什么","？","加密","模式"]},{"location":"things/algorithm/#md5","text":"可以从任意长度的明文字符串生成128位的哈希值","text_tokens":["的","明文","字符","任意","从","字符串","生成","可以","128","哈希","长度","位","值"],"title":"MD5","title_tokens":["md5"]},{"location":"things/algorithm/#_9","text":"1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制","text_tokens":["接收","知道","sign","1","需要","收集","2","三步","是","？","既","_","32","只","利用","过去","后","对比","算法","是因为","128","1234","字符串","两个","约定","同时","如何","无误","十六进制","。","这里","字符",":","带上","上","hash","acount","成","位","参数值","则","=","amout","数值","进制","除了","相同","密钥","时","攻击者","支付","按照","做","直接","规则","abcd","三方",".","限制","验证","账户","本身","一个","4","名","5","只能","最大","起来","*","值","通过","之所以","又","十六","从","平台","业务","相关","金额","的","了","在","把","第三方","md5","就是","比如","拼接","传输","如果","签名","，","篡改","时候","生成","到","也","双方","坏人"," ","和","来","参数","所以","ade876ishdfakhdj","第三","基本","攻击","发送","不","原文","请求","目标","参与","二进制","因为","key","带","不同","给定","可能","信息","哈希","3"],"title":"验签过程","title_tokens":["过程","验签"]},{"location":"things/algorithm/#md5_1","text":"分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c","text_tokens":["所","字","一位","主","s","用到","1","计算","需要","0","图中","/","交替","之后","可以","都","分为","i","2","方法","进行","有","n","c","二个","不断","假设","命名","等于","？","是","+","分成","32","首先","第二","^","后","四个","第四个","d","绿色","0x76543210","求余","这样","中","向","128","如下","m","非线性","整数","原","产生","m16","g","h",",","张图","第二个","这","呢","记录","让","0x89abcdef","水线","十六进制","。","0x01234567","使得","~","单次","之一","黄色","第一位","多少","512","）","共","数倍","位","经过","0xfedcba98","”","=","进制","（","值补","原先","按照","-","意思","abcd","z",".","次子","由","流水线","四步","一次","会","m15","第一个","相加","<","16","三个","a","初始值","一个","4","函数","5","四种","用","第一","量值","其余","新","*","一组","值","包含","第四","真正","十六","下图","b","代表","线性","得到","每个","所用","的","一等","简单","了","在","把","子","田","ki","旧","取代","m0","448","最","md5","mi","就是","64","拼接","流水","很","完后","如果","最后","(","复杂","左移","，","流程","等份","组","加工","对","到","设置","剩余","整数倍","也","次数","组是","一步","一共","位置","演变","mj"," ","单","“","官方","和","|","每","决定","上面","第三","循环","常量","不","结果","原文","使用","x","m1","长度","处理","再",")","bit","归纳","二进制","初始","就","实践","&","：","分组","第一步","y","次","f","田字","不同","为","第三个","、","下面","份","填充","信息","哈希","表达","3","红色"],"title":"MD5底层原理","title_tokens":["原理","md5","底层"]},{"location":"things/algorithm/#base64","text":"","text_tokens":[],"title":"Base64","title_tokens":["base64"]},{"location":"things/algorithm/#_10","text":"","text_tokens":[],"title":"排序","title_tokens":["排序"]},{"location":"things/algorithm/#_11","text":"","text_tokens":[],"title":"冒泡算法和优化","title_tokens":["和","冒泡","优化","算法"]},{"location":"things/cutline/","text":"分割线使用三个或以上 * ，也可以使用 - 和 _ ，下面仅以 - 作为示例 --- 效果","text_tokens":["分割线","---","可以"," ","和","示例","使用","_","-","作为","以上","分割","效果","，","三个","割线","下面","仅以","也","*","或"],"title":"Cutline","title_tokens":["cutline"]},{"location":"things/main/","text":"由于语法众多，因此将 大部分语法 汇总在下面表格里，便于一览。 但该表并未涵盖全部语法(如某些特殊符号) ，因此详情请翻看语法的具体章节。 符号 用途 # 标题 空行 段落 > 引用 [^sth] 脚注 !!! 注解 ??? 折叠注解 \\ 转义 * 列表 + 列表 - 列表 *[x] 任务列表 +[x] 任务列表 -[x] 任务列表 --- 分割线 :shortname: emoji ` 行内代码 ```语言 代码块,带高亮 TAB 代码块 #! 代码高亮 ::: 代码高亮 *sth* 斜体 _sth_ 斜体 **sth** 粗体 __sth__ 粗体 ***sth*** 粗斜体 ___sth___ 粗斜体 \\^sth\\^ 上标 \\~sth\\~ 下标 \\^\\^sth\\^\\^ 文字下划线 \\~\\~sth\\~\\~ 文字中横线 {++sth++} 文字下划线,绿色背景高亮 {--sth--} 文字中横线,红色背景高亮 {\\~\\~false\\~>true\\~\\~} 文字下划线接文字横线,绿接红背景高亮 {>>sth<<} 表示注解,灰色背景高亮 \\=\\=sth\\=\\= 黄色背景高亮 {\\=\\=sth\\=\\=} 黄色背景高亮 \\$sth$ 行内式数学公式 \\(sth)\\ 行内式数学公式 \\$\\$...$$ 区块式数学公式 \\begin{}...\\end{} 区块式数学公式 [text](url \"title\") 行内式链接 [text][index],文档最后[index]: url \"title\" 参考式链接 符合要求的URL 自动链接 ![alt](url \"title\") 行内式图片 ![alt][index],文档最后[index]: url \"title\" 参考式图片","text_tokens":["里","详情","---","下划","alt","参考","!","粗体","一览","+","要求","_","全部","^","绿色","高亮","中","语言","文档","false","数学公式",",","如","sth","空行","~","。","部分",":","黄色","begin","`","用途","涵盖","链接","表格","=","[","\"","语法","接","emoji","-","符合要求","end","标题","url","下标","<","符号","?","该表","++","割线","并未","众多","大部分","自动","划线","代码","*","由于","折叠","大部","分割线","}","转义","title","图片","因此","特殊","任务","text","红","的","翻看","在","斜体","式","灰色","将","index","列表","段落","分割","便于","最后","(","true","表示","，","行内","粗","shortname","引用","区块","章节","具体","上标"," ","]","横线","数学","注解","公式","--","文字",">","x","...","{","tab","符合",")","脚注","\\","___","带高亮","绿接","但","特殊符号","__","汇总","块","详情请","#","$","某些","下面","下划线","背景","红色"],"title":"Main","title_tokens":["main"]},{"location":"things/things/","text":"this is interesting things dadadada dididididi","text_tokens":["this","dididididi","interesting","dadadada"," ","things","is"],"title":"Things","title_tokens":["things"]},{"location":"things/things/#dadadada","text":"","text_tokens":[],"title":"dadadada","title_tokens":["dadadada"]},{"location":"things/things/#dididididi","text":"","text_tokens":[],"title":"dididididi","title_tokens":["dididididi"]}]}