{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to LuisDocs 本模块介绍 词 一盏离愁孤单伫立在窗口，我在门后假装你人还没走。 旧地如重游，月圆更寂寞。 夜半清醒的烛火不忍苛责我。 一壶漂泊 浪迹天涯难入喉 你走之后 酒暖回忆思念瘦 水向东流 时间怎么偷 花开就一次成熟我却错过 -jay chou 2. 曲3 本模块说明 一路向北 听爸爸的话 本模块声明 hi hello","text_tokens":["回忆","词","月","假装","chou","的","烛火","喉","水","后","3","的话","一盏","说明","思念","人","离愁","走","听","错过","hi","本","向东","2","如","你","还","浪迹","伫立","就","我","之后","旧地","清醒","。","难入","却","更","苛责","jay","不忍","瘦","酒暖","向东流","welcome","浪迹天涯","luisdocs","介绍","孤单","窗口","hello","门","，","."," ","一次","夜半","曲","重游","to","-","漂泊","成熟","声明","怎么","圆","寂寞","没","模块","偷","花开","一壶","爸爸","东流","在","时间","天涯","一路","向北"],"title":"介绍","title_tokens":["介绍"]},{"location":"#welcome-to-luisdocs","text":"","text_tokens":[],"title":"Welcome to LuisDocs","title_tokens":["welcome"," ","luisdocs","to"]},{"location":"#_1","text":"词 一盏离愁孤单伫立在窗口，我在门后假装你人还没走。 旧地如重游，月圆更寂寞。 夜半清醒的烛火不忍苛责我。 一壶漂泊 浪迹天涯难入喉 你走之后 酒暖回忆思念瘦 水向东流 时间怎么偷 花开就一次成熟我却错过 -jay chou 2. 曲3","text_tokens":["回忆","瘦","词","月","酒暖","假装","向东流","浪迹天涯","-","向东","chou","漂泊","2","孤单","的","如","成熟","窗口","你",".","烛火","怎么","喉","圆","还","寂寞","没","水","后","浪迹","伫立","偷","花开","就","3","一壶","我","之后","门","，","旧地","清醒","一盏"," ","一次","。","在","难入","夜半","人","更","思念","东流","时间","却","天涯","曲","离愁","走","苛责","错过","jay","不忍","重游"],"title":"本模块介绍","title_tokens":["本","介绍","模块"]},{"location":"#_2","text":"一路向北 听爸爸的话","text_tokens":["一路","听","的话","向北","爸爸"," "],"title":"本模块说明","title_tokens":["本","说明","模块"]},{"location":"#_3","text":"hi hello","text_tokens":["hi","hello"," "],"title":"本模块声明","title_tokens":["本","声明","模块"]},{"location":"algorithm/","text":"HashMap 概念 用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。 put方法原理 调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。 get方法 首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找 初始化长度 初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。 高并发下的HashMap Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap. 什么是ConcurrentHashMap？ ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。 put和get原理 get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash 红黑树 （数据结构） 二叉树的特性 1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树 红黑树特性 节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。 调整红黑树的两种方法（变色、旋转） AES算法（对称加密算法） MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。 三个基本概念（密钥、填充、模式） 密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。 在java中的具体实现 注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。 AES算法的底层原理 一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey） 字节替代 subByte 十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11] 行移位 shiftRows 如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节 列混淆MixColumns 输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列 加 论密钥(add round key) 128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。 不同工作模式在加密流程中有什么不同？ 所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度 MD5 可以从任意长度的明文字符串生成128位的哈希值 验签过程 1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制 MD5底层原理 分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c Base64 排序 冒泡算法和优化","text_tokens":["192bit","fix","下","两个","篡改","abcd","现象","这些","粒度","主","整数","解密","越来","接插","依次","sign","一组","原始","给定","负载","数倍","金额","重新","第一","概念","并行","链表","1","实践","细节","基本","缺点","有利","归纳","最高","位","w","换成","m16","累加","null","统计","各种","处理过程","0x76543210","第四行","有些","两次","额外","插入","get","并","之所以","一步","左移","有个","并发","subbytes","份","假设","键值","s","高度","处理","替代","因子","二叉树","盒","双方","右子","黄色","aes192","黑色","最","思想","同时","之后","00","中有","代替","目标","不止","发生变化","路径","只要","作用","知道","第三方","128bit","final","第三","定位","完整","默认","为","16x16","校验","随之","mj","保证","二块","数","新","几种","提供","四行","成一","n","既","本身","等于","真正","创造者","表","大于","分成","来","打折","增加","这个","次子","复杂","ade876ishdfakhdj","相乘","第一位","具体","左右","算法","有利于","<","两位","四种","vector","shiftrows","所","变化","m0","+","不断","大","组是","效率","resize","呢","绿色","直接","源代码","例","无法","方式","不","安全性","java","-","封装","/","进行","认为","数据结构","折扣","了","实际","、","上面","一等","&","|","同一","分段","或","高","尾端","32","一把","对","之间","只","组","缺少","不同","：","四步","优势","第","nopadding","被","代码","为了","调整","使用","字","第一个","得出","遇到","aes","量值","图中","不如","初始化","9","其它","典型","密文","带上","0x01234567","的","整数倍","数目","带","31","变色","下图","参数","块","取决","防止","设置","length","子","hashcode","后","达到","红黑树","事情","数值","超过","相当","必须","铭文","i","理过","mixcolumns","收集","树","cbc","底层","泄漏","演变","是非","技术","一共","向","情况","block",">","均","x","两种","私密","10","ecb2","原理","如果","函数","流程","只能","过程","一致性","原本","开始","175","平台","好","......","扩容","两件","256","0x89abcdef","”","步骤","找","根","多个","较差","加密","(","三种","7","例如","接收","\\","实现","完后","更高","。","计算","线性","平时","不足","字符","某种","位置","amout","beauty","加入","赋值","为什么","很","内部","环","如何","大家","可","\"","它","单","水线","到","流水线","size","锁","如图","addroundkey","#","当前","最大","过去","攻击","均匀分布","把","g","除了","个","优化","box","第三行","再","性能","要求","矩阵","表达","一位","成","subbyte","三个"," ","ctr","出","value","等同于","叫做","从","什么","一轮","当","结束","大小","[","_","作为","二进制","取决于","分布","子树","一段","后面","任一","总","-------------------------","64","第四","中","复杂度","index","next","让","initial","常量","结果","求余","越来越","第一步","输入","当于","值","特性","流水","13","顺着","=","原先","密码","修补","后续","1111","有限","0.75","孩子","那么","简单","loadfactor","映射","加解密","利用","最终","替换","获取","比如","concurrenthashmap","0","512","方法","指向","右","当新","可能性","5","由于","行","计算器","即","做","几位","属于","依据","进制","直到","遍历","许多","14","除去","m1","刚好","根据","互不干涉","拆分","k","整个","3","二维","md5","matrix","有点像","假定","排列","ki","输出",",","变成","参数值","重入","摘要","体现","次","h","aes128","明文","e","时","且","有","旧","包含","下面","关联","值补","最后","阶段","任意","）","尝试","2","64bit","~","另外","剩余","田","持有","整段","这","条件","cfb","表示","具体位置","数量","常用","那个","得到","有点","十六进制","采用","运算","是否","拼接","加","生成","账户","指针","从根","就","这里","5b","链接","对称","插法","反馈","基本概念","4x4","1001","electronoc","近似","几乎",")","替换成","java8","普通","哈希","独立","二级","起来","互不","subtitution","可能","数组","两倍","论","非线性","记录","128","经过","阈值","请求","一样","用","名","少于","codebook","ofb","约定","传输","节点","就是","也","混淆","0xfedcba98","发送","不能","第四个","b","加密算法","，","等同","一个","说",".","一次","前","]","完成","47","原来","操作","二个","存储","显然","共","用于","很多","round","官方","则","add","11","3029737","意思","优点","8","sha256","f","capacity","全为","将","对象","小于","完全","用到","（","创造","任何","bit","旋转","分组","所用","怎么","田字","需要","y","坏人","干涉","无误","覆盖","可以","随机","元素","修改","以上","排列成","rounds","同一个","和","多","a","j","主干","电码","等份","iv","12","同样","同于","相关","规则","列","二行","所以","iso126padding","左子","引入","这种","chaining","“","加锁","加轮","如下","完整性","加盐","按照","代表","首先","末尾","原文","二进制位","语言","一行","集合","hash","相应","叶子","连续","一致","即可","调用","红色","利于","第三个","拆","put","16","容量","pkcs5padding","所有","第一行","攻击者","验证","说明","一股","头","循环","长度","张图","c","参与","三方","取代","移位","相当于","m","走到","验签","二位","四个","^","数据","electronic","注意","命名","4","分别","安全","轮","通过","*","阻塞","决定","zegment","时候","第二行","是因为","segment","不变","字符串","难免","分散","解决","出现","结构","book","是","搞笑","产生","对比","aes256","最好","平衡","表面","chainning","key","算器","轮数","而是","列成","这样","会","要","都","生变","中当","可逆","信息","ff","keyexpentions","当中","读写","外","{","原","但是","左","一起","192","影响","查找","扩展","码本","101110001110101110","三步","mi","单次","只有","密钥","？","幂","交替","均匀","第二个","排序","加工","之一","次数",":","m15","字节","而","一个个","增长","entry","创建","工作","feedback","主体","宏观","上","向量","支付","6","加密器","}","每","其余","每个","差别","255","由","异或","并行计算","又","初始值","降低","因为","冲突","与","业务","限制","种子","使得","三行","第二","ecb","z","线程","1234","初始","空","十六","initialization","多少","问题","hashmap","模式","》","写入","匹配","五种","outputfeedback","大打折扣","上锁","分为","个个","acount","或者","电码本","相同","直接插入","打折扣","填充","counter","rehash","一直","没有","冒泡","体位","签名","一股脑","十进制","二叉","二分","补全","主要","第二块","d","补足","448","cipher","在","不是","发生","释放","前会","向下","相加","15","160","难免会","base64","对应","一列","支持"],"title":"算法","title_tokens":["算法"]},{"location":"algorithm/#hashmap","text":"","text_tokens":[],"title":"HashMap","title_tokens":["hashmap"]},{"location":"algorithm/#_1","text":"用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。","text_tokens":["数组","这些","get","-","方法","中","）","的","键值","（","分散","常用","就是","也","集合","entry","是","(","这个","对","每","key","put","最","元素","，","初始值","一个"," ","。","在","和","存储","都","value","null",",","用于","主干","叫做",")","初始","hashmap"],"title":"概念","title_tokens":["概念"]},{"location":"algorithm/#put","text":"调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。","text_tokens":["遇到","下","现象","0","越来","接插","指向","当新","可能性","“","的","链表","hashcode","1","后","红黑树","即可","调用","超过","put","头","假定","长度",",","变成","时","插入","最后","通过","2","”","难免","出现","是","采用","(","指针","key","插法","。","不止","会","中当",")","java8","为","位置","beauty","但是","查找","可能","数组","\"","它","到","size","创造者","节点","entry","每","，","一个","."," ","冲突","大","当","直接","hashmap","8","-","认为","index","对象","直接插入","next","创造","&","越来越","得出","可以","=","元素","：","多","被","难免会","对应"],"title":"put方法原理","title_tokens":["原理","方法","put"]},{"location":"algorithm/#get","text":"首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找","text_tokens":["可能","-","匹配","到","做","size","的","时候","首先","index","&","找","得到","根据","同一","多个","hash","链表","输入","entry","hashcode","1","节点","需要","上","(","这个","key","顺着","=","，","一个"," ","一次",".","头","同一个",",","向下",")","位置","映射","有","hashmap"],"title":"get方法","title_tokens":["get","方法"]},{"location":"algorithm/#_2","text":"初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。","text_tokens":["3029737","下","例","101110001110101110","两个","二进制","取决于","所以","后面","这种","-","-------------------------","最后","幂","初始化","9","其它","hash","做","均匀","size","几位","2","进制","的","全为","index","同于","本身","二进制位","结果","&",":","取决","book","是","增长","length","或","hashcode","1","值","运算","后","输入","(","十进制","就是","3","key","16","=","，","以上","等同","算法"," ",".","。","1001","计算","只要","情况","长度","与",",","1111","等同于",")","15","函数","初始","为","哈希","对应","hashmap"],"title":"初始化长度","title_tokens":["初始化","长度","初始"]},{"location":"algorithm/#hashmap_1","text":"Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap.","text_tokens":["规则","下","concurrenthashmap","方法","做","如下","的","负载","链表","hash","达到","1","后","事情","容量","是非","情况","长度",">","安全","*","并发","扩容","2","两件","时候","条件","解决","那个","出现","是","因子","是否","(","。","发生变化","计算","会","要","生变",")","默认","随之","为什么","可能","环","数组","两倍","如何","新","？","幂","size","当前",":","也","创建","，","."," ","原来","因为","变化","什么","线程","resize","hashmap","f","capacity","进行","index","了","rehash","需要","=","：","在","发生","有限","0.75","loadfactor","使用"],"title":"高并发下的HashMap","title_tokens":["的","下","并发","高","hashmap"]},{"location":"algorithm/#concurrenthashmap","text":"ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。","text_tokens":["互不","影响","保证","粒度","concurrenthashmap","如何","它","？","写入","安全","阻塞","上锁","并发","锁","zegment","的","了","segment","持有","让","怎么","表","同一","就是","是","hash","搞笑","采用","当于","分段","需要","相当","一把","每个","之间","同时","又","实现","，","一个","技术"," ","降低","更高","。","优势","同一个","操作","都","读写","相当于","线程","效率","独立","二级"],"title":"什么是ConcurrentHashMap？","title_tokens":["concurrenthashmap","什么","是","？"]},{"location":"algorithm/#putget","text":"get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash","text_tokens":["获取","concurrenthashmap","方法","加锁","做","的","遍历","重新","hash","1","超过","3","put","所有","说明","累加",",","统计","重入","原理","如果","时","两次","过程","插入","get","通过","尝试","segment","具体位置","数量","得到","运算","是否","key","实现","中有","计算","定位","位置","起来","数组","可","到","均匀","size","阈值","锁","次数","entry","大于","均匀分布","上","把","每","再","具体","，","一个"," ",".","一次","+","则","结束","分布","总","中","进行","或者","将","对象","了","输入","没有","值","体位","对","覆盖","元素","修改","在","不是","释放","为了"],"title":"put和get原理","title_tokens":["和","get","put","原理"]},{"location":"algorithm/#_3","text":"","text_tokens":[],"title":"红黑树  （数据结构）","title_tokens":["红黑树","数据结构","数据","（","结构"," ","）"]},{"location":"algorithm/#_4","text":"1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树","text_tokens":["利用","左子","这种","方法","右","依次","5","由于","9","如下","的","1","红黑树","缺点","3","树","所有","均","变成","10","走到","插入","开始","4","分别","2","找","解决","根","高度","是","二叉树","右子","平衡","从根","就","思想","几乎","线性","为","左","查找","如何","它","？","排序","次数","等于","最大","节点","也","大于","打折","6","性能","左右","，","."," ","结束","11","例","子树","8","不","大打折扣","或者","折扣","小于","相同","了","打折扣","、","值","13","二叉","二分","：","孩子"],"title":"二叉树的特性","title_tokens":["特性","二叉","的","二叉树"]},{"location":"algorithm/#_5","text":"节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。","text_tokens":["两个","包含","任一","到","的","或者","数目","相同","根","节点","是","子","叶子","连续","(","红色","不能","每个","黑色","所有"," ","。","路径","都","null",")","从","空","有"],"title":"红黑树特性","title_tokens":["特性","红黑树"]},{"location":"algorithm/#_6","text":"","text_tokens":[],"title":"调整红黑树的两种方法（变色、旋转）","title_tokens":["红黑树","的","变色","两种","（","、","调整","方法","旋转","）"]},{"location":"algorithm/#aes","text":"MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。","text_tokens":["保证","一致性","不","sha256","属于","完整性","的","进行","是","一致","加密","对","加密算法","主要","md5","对称","，","泄漏","算法","。","作用","和","可逆","信息","摘要","被","私密","完整","校验"],"title":"AES算法（对称加密算法）","title_tokens":["aes","加密","（","加密算法","对称","算法","）"]},{"location":"algorithm/#_7","text":"密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。","text_tokens":["aes","192bit","最终","这些","iso126padding","整数","解密","5","chaining","典型","其它","计算器","密文","做","的","整数倍","数倍","许多","末尾","块","语言","相应","后","1","细节","拆分","整个","拆","必须","铭文","3","最高","理过","16","cbc","位","pkcs5padding","一股","长度","block","输出",",","c","处理过程","体现","aes128","明文","如果","e","时","且","有些","过程","electronic","注意","并","最后","4","安全","有个","）","64bit","2","时候","256","整段","cfb","数量","book","处理","是","采用","拼接","aes256","加密","生成","最好","(","就","aes192","三种","轮数","7","思想","链接","\\","算器","而是","反馈","中有","。","计算","近似","128bit","平时",")","不足","独立","默认","字符","{","为","某种","但是","一起","192","加入","码本","可能","大家","二块","只有","数","密钥","？","几种","提供","成一","经过","用","#","等于","少于","codebook",":","ofb","字节","就是","一个个","也","工作","feedback","分成","主体","上","把","g","这个","加密器","个","}","6","性能","每个","复杂","要求","b","加密算法","差别","成","，","一个","说"," ","算法","ctr","第二","ecb","从","什么","则","问题","例","8","模式","一段","不","安全性","方式","outputfeedback","五种","中","个个","进行","电码本","了","相同","实际","填充","、","任何","（","结果","分组","counter","尾端","值","需要","一股脑","对","之间","补全","缺少","随机","第二块","d","补足","不同","：","密码","cipher","在","不是","a","nopadding","电码","使用","128","同样","支持"],"title":"三个基本概念（密钥、填充、模式）","title_tokens":["基本","填充","（","、","模式","概念","密钥","三个","基本概念","）"]},{"location":"algorithm/#java","text":"注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。","text_tokens":["aes","注意","解密","原本","封装","密钥","整数","方式","并","好","其它","一组","的","整数倍","数倍","填充","真正","块","字节","就是","上","调用","表面","生成","除了","key","16","，","算法","：","而是","。","不是","会","长度","都","用于","种子","nopadding","明文","如果","时","使用","外","加解密","额外"],"title":"在java中的具体实现","title_tokens":["的","java","具体","实现","中","在"]},{"location":"algorithm/#aes_1","text":"一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey）","text_tokens":["aes","列","最终","两个","0","行","加轮","密文","进制","如下","的","14","除去","刚好","1","mixcolumns","位","长度",",","各种","次","移位","10","明文","aes128","有","四个","阶段","轮","）","subbytes","~","步骤","表示","十六进制","处理","加密","aes256","(","aes192","key","轮数","而是","00","代替","。","ff",")","final","普通","论","可","只有","密钥","？","经过","n","addroundkey","字节","也","混淆","把","255","由","成","具体","，","一个","三个"," ","一次","shiftrows","round","很多","初始","十六","多少","》","initial","（","需要","不同","：","rounds","不是","12","对应"],"title":"AES算法的底层原理","title_tokens":["aes","的","底层","原理","算法"]},{"location":"algorithm/#subbyte","text":"十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11]","text_tokens":["subtitution","替换","数组","5","中","通过","依据","2","进制","的","另外","[","步骤","常量","第一","s","块","字节","大小","就是","处理","替代","是","十六进制","盒","值","把","(","每","box","b","二维","5b","=","例如","位","，","排列成","一个","列成","换成"," ","4x4","。","在","]","两位","排列","都","输出",",","a","那么","被","替换成",")","明文","十六","第一个","16x16","11","二位"],"title":"字节替代 subByte","title_tokens":["字节","subbyte"," ","替代"]},{"location":"algorithm/#shiftrows","text":"如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节","text_tokens":["两个","二行","第四","四行","左移","如图","第二行","不变","第一","字节","一行","第三行","第一行","一个","："," ","三个","循环","三行","第二","第三","第四行"],"title":"行移位 shiftRows","title_tokens":[" ","shiftrows","行","移位"]},{"location":"algorithm/#mixcolumns","text":"输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列","text_tokens":["fix","列","数组","做","的","常量","得到","输入","(","每","矩阵","相乘","matrix","，","一个"," ","和","要","修补","输出",")","明文","对应","一列","二位"],"title":"列混淆MixColumns","title_tokens":["混淆","列","mixcolumns"]},{"location":"algorithm/#add-round-key","text":"128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。","text_tokens":["aes","最终","0","做","原始","的","直到","31","1","k","i","16","w","所有","排列","长度","输出",",","10","175","4","轮","......","*","）","2","是","处理","加密","生成","(","就","列成","4x4","。","计算","都","128bit","keyexpentions","当中",")","为","{","位置","赋值","扩展","数组","密钥","到","用","字节","而","来","}","每","b","异或","由","矩阵","，","等同","一个"," ","一次","]","完成","47","与","存储","用于","+","等同于","一轮","初始","[","源代码","-","中","了","用到","（","一直","输入","值","32","元素","排列成","不同","同样","和","第","后续","a","j","被","代码","15","160","对应","同于"],"title":"加 论密钥(add round key)","title_tokens":["加","(","论","round","key",")","密钥","add"," "]},{"location":"algorithm/#_8","text":"所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度","text_tokens":["aes","引入","不如","即","初始化","密文","做","加盐","的","第一","并行","概念","块","互不干涉","防止","1","利于","有利","缺点","cbc","md5","所有","有点像","block",",","变成","参与","体现","ecb2","明文","流程","关联","安全","2","有点","较差","book","处理","是","加密","(","chainning","最","更高","。","这样","计算","作用","会","electronoc","都",")","独立","互不","内部","经过","一样","codebook",":","工作","向量","宏观","上","增加","加密器","每","性能","差别","并行计算","异或","复杂","成","，","一个","有利于"," ",".","前","出","操作","与","vector","所","显然","ecb","初始","initialization","作为","优点","无法","模式","不","安全性","复杂度","完全","相同","了","让","值","干涉","之间","只","：","cipher","在","和","后续","前会","简单","iv","第一个","同样"],"title":"不同工作模式在加密流程中有什么不同？","title_tokens":["加密","模式","什么","？","不同","流程","中有","工作","在"]},{"location":"algorithm/#md5","text":"可以从任意长度的明文字符串生成128位的哈希值","text_tokens":["值","长度","的","生成","可以","从","明文","字符串","位","哈希","字符","128","任意"],"title":"MD5","title_tokens":["md5"]},{"location":"algorithm/#_9","text":"1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制","text_tokens":["相关","规则","利用","两个","篡改","abcd","所以","比如","5","sign","带上","做","给定","进制","的","按照","带","金额","原文","参数","hash","1","后","数值","基本","3","收集","位","md5","攻击者","验证","参与","参数值","三方","如果","时","只能","平台","之所以","4","*","通过","2","时候","是因为","字符串","十六进制","是","双方","账户","拼接","对比","生成","这里","key","同时","接收","目标","无误","。","知道","第三方","信息","第三","amout","字符","哈希","起来","三步","可能","如何","密钥","？","到","请求","既","本身","名","最大",":","约定","传输","就是","也","过去","攻击","来","支付","把","除了","上","发送","ade876ishdfakhdj","成","又","，","一个","算法","."," ","因为","限制","业务","从","1234","则","十六","_","直接","二进制","不","acount","相同","了","值","需要","32","签名","坏人","只","=","不同","在","和","128"],"title":"验签过程","title_tokens":["验签","过程"]},{"location":"algorithm/#md5_1","text":"分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c","text_tokens":["abcd","主","0","512","量值","整数","方法","图中","5","“","一组","0x01234567","进制","如下","的","按照","代表","首先","数倍","原文","整数倍","下图","第一","m1","设置","子","1","后","实践","常量","第三个","红色","归纳","i","3","演变","16","位","md5","一共","向","m16","循环","长度","ki",",","张图","c","取代","次","x","0x76543210","h","如果","m","函数","流程","有","四个","旧","包含","^","下面","命名","值补","最后","4","一步","左移","*","）","决定","份","2","~","假设","剩余","0x89abcdef","田","”","这","s","得到","十六进制","处理","是","产生","拼接","(","黄色","就","最","之后","完后","这样","。","计算","会","都","信息","线性",")","第三","哈希","为","位置","原","mj","很","mi","单次","非线性","记录","新","？","单","水线","到","经过","交替","第二个","流水线","加工","n","之一","次数","用","等于","真正","m15","就是","也","分成","0xfedcba98","把","其余","次子","g","每","第四个","再","b","复杂","每个","由","表达","一位","第一位","，","初始值","一个","三个","."," ","一次","四种","二个","<","所","共","使得","+","不断","官方","第二","m0","z","组是","初始","十六","呢","绿色","多少","意思","二进制","不","-","64","f","第四","中","/","分为","进行","了","用到","填充","（","让","上面","、","结果","bit","求余","分组","所用","&","|","田字","一等","第一步","值","流水","需要","y","32","对","组","可以","=","原先","d","不同","：","448","四步","在","和","a","等份","简单","相加","使用","字","128","第一个"],"title":"MD5底层原理","title_tokens":["底层","md5","原理"]},{"location":"algorithm/#base64","text":"","text_tokens":[],"title":"Base64","title_tokens":["base64"]},{"location":"algorithm/#_10","text":"","text_tokens":[],"title":"排序","title_tokens":["排序"]},{"location":"algorithm/#_11","text":"","text_tokens":[],"title":"冒泡算法和优化","title_tokens":["算法","和","优化","冒泡"]},{"location":"basic/","text":"'this is about me page'","text_tokens":["me","page","this","is","'","about"," "],"title":"Basic","title_tokens":["basic"]},{"location":"basicDataType/","text":"二进制简介 假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为： 00000000 00000000 00000000 00000101 5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。 负数的二进制(补码=反码+1) -5在计算机中如何表示？ 在计算机中负数以其正值的补码形式表达 比如 00000000 00000000 00000000 00000101 是 5的 原码。 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。 11111111 11111111 11111111 11111010 是 00000000 00000000 00000000 00000101 的反码。 补码：反码加1称为补码。 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。 11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011 -5在计算机中表示为：11111111 11111111 11111111 11111011 进制间转换 十进制转二进制 转二进制就除2把余数都标在右侧 最下面的余数放在最左面 例20的二进制 20...0 20除2商10余0 10...0 10除2商5余0 5....1 5除2商2余1 2....0 2除2商1余0 .....1 --------->0000 10100 十六进制转二进制 0x12--->0001 0010 0x1234-->0001 0010 0011 0100 二进制转十六进制 0001 0010 0011 0100-->0x1234 基本数据类型占的位数 bit: 1 bit位 = 1 二进制数据 byte: 1 byte = 8 bit位 （-128 ~ 127） 字母: 1 字母 = 1 byte = 8 bit(位) short: 16位 char: Unicode字符，16bit位 int: 32bit位，比如int 类型占用4个字节，32位 long: 64bit位 float: 32bit位 double: 64bit位 string: 汉字：1 汉字 = 2 byte = 16 bit 《《***这里不是很准确，当编码不同的时候，1个汉字所占的字节数也会有所不同，有些编码是占 2个字节，有些则不是，可能是 3个或者 4个***》》 与运算&0XFF &作为位运算 （还可以作为逻辑运算符） 操作数的二进制形式，同为1结果才是1，其它则为0，操作数可以是二进制八进制十六进制 0xff的十进制是255，八位二进制11111111,一个数&上它应该是不变的，但是 系统监测到byte作为int类型向控制台输出的时候，会自动将byte的内存空间高位补1扩充到32位。&0xff即是取了低八位，尽管十进制数不同但是保持了二进制补码的一致 例： 0x1234 十六进制 0001 0010 0011 0100 二进制 0xff---->1111 1111 左侧补0---->0000 0000 1111 1111 运算结果取低八位 0000 0000 0011 0100 有符号整数，正数要去除一个符号位，负数不用 计算机用位（bit）来作为基础单位 byte它的范围是-127~128,用8个bit可表示 1（2^8）~2^8-1 1111 1111 short,同char char，它的范围是0~2^15所以只能用16个bit,即两个byte int,他的范围是-2^-31~2^31-1 long double 8byte 64bit 取值-(2^64)~2^63 float 4byte 32bit byte类型的-127，其计算机存储的补码是10000001（8位），将其作为int类型向控制台输出的时候，jvm作了一个补位的处理，因为int类型是32位，所以补位后的补码就是1111111111111111111111111 10000001（32位），这个32位二进制补码表示的也是-127.虽然byte->int（八位扩展到32位），计算机背后存储的二进制补码由10000001（8位）转化成了1111111111111111111111111 10000001（32位）很显然这两个补码表示的十进制数字依然是相同的。 移位运算 <<:左移运算符，num << 1,相当于num乘以2 >>:右移运算符，num >> 1,相当于num除以2 >>>:无符号右移，忽略符号位，空位都以0补齐! 位异或运算符 位异或运算符为^，其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为 0 或同时为 1）时，结果为 0；如果对应的二进制位不相同，结果则为 1。 11^7=12 (化成二进制然后计算)","text_tokens":["先","规则","----","两个","比如","所以","除","同为","0","整数","5","float","原码","即","其它","右侧","unicode","进制","补零","的","31","依然","二进制位","....","编码","11111011","扩充","左侧","对齐","高位","1","一致","后","相当","基本","3","取低","16","不过","算机","占用","位","乘以","取","换成","正值","向","空位","低","4byte",">","输出",",","参与","处理","移位","10","相当于","有所不同","如果","时","有些","!","有","只能","^","数据","除以","byte","下面","有所","转换成","<","商","4","控制","前面","《","其","）","也就是说","*","取值","2","64bit","作数","~","假设","时候","系统","不变","这","表示","11111010","占","同","得到","十六进制","；","是","填","形式","余","位数","我们","取反","计算机","加","32bit","(","运算","基础","称为","加上","数字","就","这里","最","转化","同时","7","空间","单位","。","计算","知道","要","会","都","补位","然后","long","0xff","这个",")","不足","为","字符","原","char","但是","补齐","16bit","很","扩展","准确","可能","如何","还","可","63","10000001","数","它","内存","忽略","？","新","到","一","补","正数","八进制","用位","用","...","保持","低位",":","应该","字节","就是","也","才","左面","符号","虽然","double","来","就是说","把","string","以","个","数据类型","0011","上","不用","他","00000000","255","0001","控制台","表达",".....","间","作","由","，","异或","一个","简介"," ","0000","0100","逻辑","jvm","---","因为","操作","与",".","所","存储","显然","转","+","二制","--","一堆","则","算符","10100","十六","11111111","当","101","补码","节数","八位","作为","11","类型","例","无","0x1234","二进制","00000101","监测","8","去除","8byte","标在","范围","所得","》","-","反码","内存空间","64","左移","不","背后","尽管","中","short","余数","或者","转换","将","自动","了","相同","int","（","bit","&","结果","1111111111111111111111111","或","当于","32","字母","转化成","字节数","十进制","操作数","可以","=","127","不同","：","放在","num","---------","右移","在","不是","运算符","化成","1111","那么","值为","负数","0010","按位","0x12","15","12","汉字","128","20","对应"],"title":"基础数据类型","title_tokens":["数据类型","数据","类型","基础"]},{"location":"basicDataType/#_1","text":"假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为： 00000000 00000000 00000000 00000101 5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。","text_tokens":["类型","00000101","所以","0","转换成","数","它","5","4","前面","中","）","一","的","假设","转换","了","int","（","表示","字节","是","填","我们","计算机","32","00000000","不过","算机","占用","位","，","："," ","换成","。","在","计算","知道","那么","值为","二制","一堆","为","101","有"],"title":"二进制简介","title_tokens":["二进制","简介","进制"]},{"location":"basicDataType/#1","text":"-5在计算机中如何表示？ 在计算机中负数以其正值的补码形式表达 比如 00000000 00000000 00000000 00000101 是 5的 原码。 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。 11111111 11111111 11111111 11111010 是 00000000 00000000 00000000 00000101 的反码。 补码：反码加1称为补码。 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。 11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011 -5在计算机中表示为：11111111 11111111 11111111 11111011","text_tokens":["先","二进制","比如","00000101","如何","数","所得","-","反码","5","？","新","原码","其","中","也就是说","进制","的","将","表示","11111011","11111010","得到","就是","是","形式","取反","1","计算机","加","就是说","以","称为","加上","00000000","表达","=","算机","，","：","一个","正值"," ","。","在","计算","要","然后","+","负数","按位","为","11111111","补码","原"],"title":"负数的二进制(补码=反码+1)","title_tokens":["1","进制","的","(","二进制","+","负数",")","=","反码","补码"]},{"location":"basicDataType/#_2","text":"十进制转二进制 转二进制就除2把余数都标在右侧 最下面的余数放在最左面 例20的二进制 20...0 20除2商10余0 10...0 10除2商5余0 5....1 5除2商2余1 2....0 2除2商1余0 .....1 --------->0000 10100 十六进制转二进制 0x12--->0001 0010 0x1234-->0001 0010 0011 0100 二进制转十六进制 0001 0010 0011 0100-->0x1234","text_tokens":["例","0x1234","二进制","除","下面","0","标在","商","5","右侧","2","进制","的","余数","...","....","十六进制","余","左面","1","把","0011","十进制","就","0001","最",".....","放在","0100"," ","---------","0000","---","都",">","转","0010","0x12","10","--","10100","十六","20"],"title":"进制间转换","title_tokens":["进制","间","转换"]},{"location":"basicDataType/#_3","text":"bit: 1 bit位 = 1 二进制数据 byte: 1 byte = 8 bit位 （-128 ~ 127） 字母: 1 字母 = 1 byte = 8 bit(位) short: 16位 char: Unicode字符，16bit位 int: 32bit位，比如int 类型占用4个字节，32位 long: 64bit位 float: 32bit位 double: 64bit位 string: 汉字：1 汉字 = 2 byte = 16 bit 《《***这里不是很准确，当编码不同的时候，1个汉字所占的字节数也会有所不同，有些编码是占 2个字节，有些则不是，可能是 3个或者 4个***》》","text_tokens":["16bit","类型","很","准确","可能","二进制","数据","比如","byte","8","有所","》","-","float","4","《","）","short","unicode","*","64bit","进制","2","~","的","时候","有些","或者","int","（","编码","bit",":","占","字节","也","32bit","是","1","double","32","字母","(","个","string","字节数","3","这里","=","16","位","占用","127","，","不同","："," ","不是","会","所","long",")","有所不同","则","字符","汉字","128","当","节数","char"],"title":"基本数据类型占的位数","title_tokens":["类型","的","基本","数据类型","数据","占","位数"]},{"location":"basicDataType/#0xff","text":"&作为位运算 （还可以作为逻辑运算符） 操作数的二进制形式，同为1结果才是1，其它则为0，操作数可以是二进制八进制十六进制 0xff的十进制是255，八位二进制11111111,一个数&上它应该是不变的，但是 系统监测到byte作为int类型向控制台输出的时候，会自动将byte的内存空间高位补1扩充到32位。&0xff即是取了低八位，尽管十进制数不同但是保持了二进制补码的一致 例： 0x1234 十六进制 0001 0010 0011 0100 二进制 0xff---->1111 1111 左侧补0---->0000 0000 1111 1111 运算结果取低八位 0000 0000 0011 0100 有符号整数，正数要去除一个符号位，负数不用 计算机用位（bit）来作为基础单位 byte它的范围是-127~128,用8个bit可表示 1（2^8）~2^8-1 1111 1111 short,同char char，它的范围是0~2^15所以只能用16个bit,即两个byte int,他的范围是-2^-31~2^31-1 long double 8byte 64bit 取值-(2^64)~2^63 float 4byte 32bit byte类型的-127，其计算机存储的补码是10000001（8位），将其作为int类型向控制台输出的时候，jvm作了一个补位的处理，因为int类型是32位，所以补位后的补码就是1111111111111111111111111 10000001（32位），这个32位二进制补码表示的也是-127.虽然byte->int（八位扩展到32位），计算机背后存储的二进制补码由10000001（8位）转化成了1111111111111111111111111 10000001（32位）很显然这两个补码表示的十进制数字依然是相同的。","text_tokens":["----","两个","同为","所以","0","整数","float","即","其它","进制","的","31","依然","扩充","左侧","高位","1","一致","后","取低","16","位","算机","取","向","低","4byte",">","输出",",","有","只能","^","byte","控制","取值","其","）","2","64bit","作数","时候","~","系统","不变","这","表示","同","十六进制","还","形式","是","32bit","基础","处理","运算","计算机","(","数字","转化","空间","单位","。","计算","补位","会","要","long","0xff",")","为","但是","char","很","扩展","可","63","数","它","内存","到","补","正数","八进制","用位","用","保持","应该","就是","也","才","符号","虽然","double","来","上","这个","不用","个","0011","10000001","他","jvm","255","控制台","0001","作","由","，","一个","0100"," ","0000",".","逻辑","因为","操作","存储","显然","则","算符","十六","11111111","八位","补码","作为","类型","例","0x1234","二进制","监测","8byte","8","去除","范围","-","内存空间","64","背后","尽管","short","将","自动","了","相同","int","（","结果","&","bit","1111111111111111111111111","32","转化成","十进制","操作数","可以","127","不同","：","运算符","化成","1111","负数","0010","15","128"],"title":"与运算&amp;0XFF","title_tokens":["运算","与","amp","0xff","&",";"]},{"location":"basicDataType/#_4","text":"<<:左移运算符，num << 1,相当于num乘以2 >>:右移运算符，num >> 1,相当于num除以2 >>>:无符号右移，忽略符号位，空位都以0补齐!","text_tokens":["无","除以","!","0","忽略","左移","2",":","符号","当于","1","运算","相当","以","位","，","乘以"," ","<","右移","空位","运算符","都",">",",","相当于","算符","num","补齐"],"title":"移位运算","title_tokens":["运算","移位"]},{"location":"basicDataType/#_5","text":"位异或运算符为^，其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为 0 或同时为 1）时，结果为 0；如果对应的二进制位不相同，结果则为 1。 11^7=12 (化成二进制然后计算)","text_tokens":["规则","^","二进制","0","不","其","）","进制","补零","的","相同","二进制位","（","低位","结果","；","是","或","高位","对齐","1","运算","(","数字","异或","7","=","位","同时","，","："," ","。","计算","运算符","化成","然后","参与",")","如果","则","算符","不足","为","时","12","对应","11"],"title":"位异或运算符","title_tokens":["运算","运算符","异或","位","算符"]},{"location":"better/","text":"性能优化 性能优化 内存优化 什么是内存泄漏？ 原因 影响？ 工具-leakcanary 代码优化 使用lint检查取出无效代码 代码规范优化 UI优化（布局优化和绘制优化） 布局优化 速度优化（线程优化和网络优化） 线程优化 使用线程池 网络优化 图片： 加载Loading优化 电量优化 启动优化 冷启动 暖启动 热启动 启动页优化 分析性能的工具 APK瘦身 APK构成初探 优化方案 内存优化 内存泄漏是常客 什么是内存泄漏？ 内存不在GC的掌控范围内 对一些对象有有限的周期声明，希望要做的事完成了，它会被垃圾回收器回收掉，但是有一些对这个对象的引用还存在，导致无法被回收，占用内存，持续累加，内存很快被耗尽OOM. 如一个activity的onDestroy被调用，但是如果有一个后台线程持有这个activity的引用，该activity占用的内存就不能被回收。 原因 错误使用单例-context(ApplicationContext) handler 在handler中设置ui元素 解决方案： 1. activity关闭的时候移除所有的消息和runable 2. 采用静态内部类+弱引用 thread 非静态内部类或者匿名类创建线程会隐式引用activity,线程run方法不执行完，线程是不会销毁的，所引用的activity也不会销毁。 解决方案： 线程内部使用弱引用/加个tag,activity销毁时修改tag值，不继续执行线程中的操作 AsyncTask 在AsyncTask中进行耗时操作，完成后，更新ui，有时会在耗时操作还没结束，activity就退出了，但是引用还被AsyncTask持有，无法释放导致内存泄漏。 解决方法：在ondestroy的时候，调用AsyncTask.cancel() 5. 资源未关闭BroadcastReceiver、注册后记得取消注册。 6. 动画资源未释放，无限循环动画 影响？ oom 工具-leakcanary java的GC内存回收机制是什么？ 答：对象在没有任何引用的时候才会被回收 GC回收机制的原理是什么？/可以作为GC Root引用点是啥？ 答：1.java栈中引用的对象2.方法静态引用的对象3.方法常量引用的对象4.Native中JNI引用的对象5.Thread-活着的线程。 内存泄漏原因？ 答:代码存在泄漏，内存无法释放/图片加载消耗大量内存，系统给应用分配内存即为应用能占用内存的最大值。 Android Profiler 测量应用性能 代码优化 使用lint检查取出无效代码 检测未使用的资源 点击菜单栏 Analyze -> Run Inspection by Name -> unused resources -> Moudule ‘app’ -> OK 检测无效代码 步骤：点击菜单栏 Analyze -> Run Inspection by Name -> unused declaration -> Moudule ‘app’ -> OK 代码规范优化 避免创建不必要的对象，越少的对象意味着越少的GC操作 1. 字符串拼接优先使用stringBuilder或stringBuffer,而不是+号连接，+会创建多余的对象，拼接的字符串越长，+号连接符的性能越低 2. 当一个方法返回值为string通常要判断string的作用，如果明确知道该方法返回的string再进行拼接可以考虑返回一个stringBuuffer对象来替代，将一个对象的引用返回，而返回string则是创建了一个短生命周期的临时对象。 静态优于抽象 如果只是想调用来完成某项功能，可设置成静态的，不用专门调用这个方法而创建对象 对常量使用static final修饰 去除淡黄色警告 节制的使用service,可考虑使用intentServie代替service 不适用静态变量保存核心数据 android的进程并不是安全的，被kill掉后，app不会重新开始启动，android系统会创建一个新的Apllication对象然后启动上次用户离开时的activity,造成这个app从来没有退出的假象，静态变量数据由于进程被杀死而被初始化。 轮询操作优化 大概思路：当用户打开这个页面的时候初始化TimerTask对象，每个一分钟请求一次服务器拉取订单信息并更新UI，当用户离开页面的时候清除TimerTask对象，即取消轮训请求操作 UI优化（布局优化和绘制优化） 每秒60帧，相当于每帧需要在大概16毫秒内完成渲染，否则就会卡顿 ui线程做耗时操作 Layout过于复杂，无法在16ms内完成渲染 同一时间动画执行的次数过多，CPU GPU负荷过重 View频繁的触发measure layout 内存频繁出发gc,stoptheword onDraw方法不需要创建新的对象 onDraw方法不需要执行耗时操作循环 无用的资源和逻辑导致加载和执行缓慢） Analyze->Run Inspection by Name… –>unused resource Analyze->Inspect Code anr 通过瞬时测试和压力测试更容易出发上面问题 如何来定位？ 1. 系统设置-开发者选项-调试GPU过度绘制，红色区域过度绘制，层级/relativelayout和linealayout 2. 布局优化 include优化-重用公共布局 viewstub优化-仅在需要时才加载布局性能比VISISBLE好 merge优化-可以删减多余的层级，优化ui，但是无法预览 减少重叠，背景图,selector normal改成透明 速度优化（线程优化和网络优化） ANR Activity 5s触摸或者键盘输入事件无响应，broadcastReceiver 10s, service 20s 线程优化 以上出现的anr多数由于线程阻塞引起的，可通过以下方法解决 * Asytask * HandlerThread * ThreadPool * intentService * 使用线程池 直接创建Thread实现Runable的弊端，大量线程的创建和销毁很容易导致gc频繁的执行，发生内存抖动从而造成界面卡顿 为什么使用线程池？ 1. 重用线程 2. 控制最大并发数量 3. 对线程进行一定的管理 例子： Rxjava，rxandroid 网络优化 图片： 图片优化使用webP格式，大幅节省流量，相对于jpg节省25~35%，对于png节省80% Bitmap优化 使用Android Matrix对图片缩放。 如何在不使用 缩略图，不压缩，优化，使用android bitmapRigionDecode显示指定区域。 Glide加载优化 之前看到豆瓣的开源接口，思路很好，接口返回图片的数据有三种，高清大图、正常图片、缩略图，处于wifi用高清大图，4g或3g用正常，弱网条件下加载缩略图 网络请求处理： 对服务端返回的数据合理的缓存 下载采用断点续传 刷新数据尽可能采用局部刷新 加载Loading优化 一种就是从A页面跳转到B页面时的加载loading,loading的时候页面是纯白色，加载完数据才显示内容页面 在某个页面操作某种逻辑，局部loading(帧动画或者补间动画)，建议在销毁弹窗时，销毁动画。 电量优化 重视程度低，音乐和视频耗电最大 网络请求前先判断网络的状态 网络请求最好进行批量处理，避免频繁间隔的网络请求 有wifi和移动网络优先使用wifi,请求wifi的耗电量远比移动耗电量低 启动优化 冷启动 耗时最长的，第一次启动app或者杀死进程第一次启动，主要包括application creat和activity的creat，因此在两个类的oncreat方法中做的事情越多，冷启动消耗的时间越长 暖启动 当应用中的Activity被销毁，但在内存中常驻时，启动方式就变成暖启动，减少了对象的初始化、布局加载等工作，启动时间更短，系统依然会展现闪屏页，直到第一个activity页面呈现 热启动 用户使用返回键退出应用，然后又马上重新启动应用 1. 白屏 2. 闪屏页倒计时进行一些预加载 3. 主线程中涉及到的sp操作尽量在非ui线程执行 4. application创建过程尽量少的进行耗时操作 5. 减少布局的层次 启动页优化 启动时间优化，从Application的onCreat()方法开始到MainActivity的onCreat()执行结束 延迟初始化 后台任务 启动界面预加载 * intentService分担部分初始化工作 bugly\\推送，热修复等。。。 启动页白屏处理 为什么会出现？ zygote在启动一个APP时，会创建一个新的进程去运行这个app,创建进程是需要时间的，创建完成之前，界面是假死状态，系统根据你的manifest文件设置的主题颜色来展示一个白屏或者黑屏，称为preview window，即预览窗口 实际就是activity默认主题的android:windowBackground为白色或者黑色决定的 APP启动--previewWindow--启动页 解决办法有透明主题 添加一个有背景的style样式 ，然后闪屏页引用该theme主题，在该页面将window的背景图片设置为空 分析性能的工具 Systrace 进行埋点，使用门槛搞点，需要输入命令 原理：在一些关键链路中插入label,通过label的开始和结束时间来确定某个核心过程的执行时间，framwork层和java从都插入了label信息，亦可以自定义label 系统版本越高，Framwork中添加的系统可用label就越多 使用注意事项： 1. 手动缩小范围 2. sdk/plaform-tools/systrace目录下执行命令 3. 执行结束后会生成一个trace.html文件 自定义label 在开始和结束的地方加上自定义label,抓一遍trace，分析问题 如何分析非debug app debug和非debug性能差别很大，为了支持debug,系统开启了一些列功能，并且关闭掉了某些重要优化 ，要想分析app真实的运行情况必须要在非debug的APP中启动systrace功能。 通过反射调用sdk中一个@hide的函数 traceView 运行时开销很严重，trace会收集程序运行时所有方法的耗时情况 可以埋点 Profiler APK瘦身 APK构成初探 将apk包拖到android studio中就可以看到包结构了。 lib 主要存储各cpu架构的so库 classes.dex java文件编译生成的字节码文件 res 资源文件 AndroidManifest.xml 配置文件 META-INFO 相关签名信息 resource.arsc 资源文件映射表 优化方案 使用minifyEnable混淆代码 android { buildTypes { release { minifyEnabled true } } } proguard-rules.pro中编写混淆规则 使用ShrinkResources移除无用资源 android { buildTypes { release { minifyEnabled true shrinkResources true } } } shrinkResource必须与minifyResource同时开启才有效。 注意：采用该方法其实无用的资源并没有被移除掉，而是被体积更小的占位符替代了 删除项目中未使用到的资源文件 通过androidstudio提供的lint工具，analyze-run inspection by name然后输入unused resource查找未使用的资源文件，然后删除。 删除项目中未使用的代码 analyze-run inspection by name然后输入unused declearation 找到无用代码对其删除 通过反射引用的方法或者类，lint识别不了，也会给检查出来，删除的时候通过反射引用的方法或者类千万不能删除 对图片进行压缩 将Png图片换成体积更小的jpg格式。 使用tinypng或者upng对图片进行压缩 使用vector矢量图 将图片转化成webP格式(要求最低的api是18)转换后jpg节省35%。png 80% 使用shape代替图片 使用Resource Configs进行语言配置 Android应用本身是支持国际化的，但国内的项目好多都是在国内使用，不需要国际化，这时候可以对相关的String进行减法操作，使其只包含特定的语言（例如中文） android { defaultConfig { ... //语言资源，只支持中文 resConfigs \"zh-rCN\" } } so库操作，在引入第三方sdk难免要引入对应的so库，一般给到的so库分好多架构（armeabi, armeabi-v7a, x86等等） Android系统 目前支持以下七种不同的CPU架构： ARMv5 ARMv7 x86 MIPS ARMv8 MIPS64 x86_64 所有的架构设备x86,x8664,armeabi-v7a,arm64-v8a都支持armeabi架构的.so文件，所以可以根据自己的业务需求选择使用armeabi或者armeabi-v7a 微信、qq、网易云音乐等都只保留了armeabi-v7a android { defaultConfig { ndk { abiFilters 'armeabi','armeabi-v7a' } } }","text_tokens":["下","两个","假象","检测","view","生命","同一时","搞点","保留","连接符","开发者","规范","使","程度","七种","大值","分担","重新","重要","一些","内容","第一","注意事项","瞬时","arsc","符","开销","tag","轮询","地方","1","inspect","broadcastreceiver","返回","leakcanary","引起","连接","换成","尽可能","中未","累加","analyze","特定","因此","机制","jni","抓","流量","缩小","android","threadpool","20s","插入","app","局部","越少","minifyenabled","并","修复","其","并发","豆瓣","程序运行","abifilters","减法","如","tinypng","选择","stringbuuffer","编译","v8a","替代","处理","linealayout","x86","称为","加上","黄色","未","关闭","inspection","黑色","同时","大量","倒计","渲染","代替","删减","国际","作用","知道","第三方","千万","只是","无效","final","第三","include","定位","某项","某些","默认","为","微信","体积","好多","hide","清除","杀死","网络","暖","事项","毫秒","新","rxandroid","配置","提供","armeabi","透明","合理","更新","自定义","stringbuilder","trace","页","分配","本身","...","出来","zygote","表","才","层次","目录","来","每秒","string","分析","这个","png","x8664","国际化","构成","服务","复杂","器","意味着","window","层级","逻辑","vector","所","+","调试","库分","等","bugly","静态","直接","glide","定义","以下","各","无","armv5","无法","java","不","方式","原因","-","/","功能","unused","进行","大图","页面","了","实际","、","上面","但","界面","同一","或","云","ok","就会","性能比","背景","改成","小","对","只","拖到","图片","创建对象","不同","：","啥","键盘输入","动画","菜单","希望","分钟","被","代码","ndk","为了","越长","使用","bitmap","第一个","警告","除掉","适用","延迟","亦","取消","耗电","资源","activity","高清","framwork","初始化","预览","帧","webp","触发","务器","的","容易","api","白屏","减少","oncreat","中文","重视","style","抽象","一分钟","设置","于","debug","androidstudio","后","时才","事情","相当","一般","音乐","必须","收集","泄漏","布局","颜色","推送","低","情况","刷新",">","mips64","如果","原理","函数","倒计时","service","频繁","pro","启动","活着","内","重叠","loading","过程","anr","池","开始","viewstub","好","lint","它会","打开","–","creat","去","指定","步骤","sp","设备","耗尽","相对","单例","v7a","常驻","profiler","static","qq","resources","(","oom","修饰","三种","例如","\\","实现","一遍","4g","检查","。","…","从来","apk","点击","耗电量","minifyresource","rules","远比","字符","某种","意味","该","很","为什么","弱网","内部","类","有时","错误","’","可","如何","@","\"","armv8","arm64","到","移动","后台任务","mips","asynctask","明确","root","呈现","最大","最大值","开启","优化","性能","工具","再","studio","要求","否则","成","周期"," ","同一时间","最低","解决方案","之前","从","什么","结束","当","_","假死","常客","作为","后台","持续","垃圾","64","服务器","隐式","中","越低","so","链路","ondraw","重用","包","转换","常量","越","进程","声明","保存","用户","manifest","name","info","输入","文件","当于","值","项目","抖动","selector","电量","一时","60","节制","‘","等等","掌控","有限","回收","矢量图","导致","映射","resconfigs","退出","无用","code","矢量","traceview","优于","消耗","方法","5","即","由于","做","不会","直到","meta","依然","热启动","涉及","闪屏","略图","根据","找到","添加","仅","计时","编写","res","开源","多数","3","previewwindow","过重","merge","matrix","by","速度","native","应用","apllication","label","目前",",","变成","wifi","为空","冷启动","时","码","一定","测试","有","网易","包含","relativelayout","gc","展示","移除","菜单栏","这时候","能比","）","一分","过于","2","~","预","层","系统","持有","你","条件","引用","handlerthread","解决办法","数量","25","applicationcontext","变量","lib","还","采用","核心","大幅","拼接","正常","生成","就","非","命令","转化","区域","plaform","visisble","upng","更","专门","windowbackground","大概",")","点","5s","一时间","弹窗","订单","35%","方案","preview","断点续传","最长","测量","尽可","不了","格式","可能","这时","内存","layout","asytask","moudule","10s","缓慢","部分","请求","用","ui","stoptheword","run","就是","也","淡黄","混淆","公共","纯白色","消息","每帧","不能","b","继续","application","不必要","其实","'","，","一个",".","生命周期","一次","true","完成","瘦身","操作","存储","批量","jpg","必要","下载","有效","则","状态","shrinkresources","键盘","服务端","栈中","过多","去除","判断","范围","完","造成","执行命令","优先","measure","重新启动","架构","将","对象","（","任何","classes","自己","接口","没","需要","转化成","关键","短","ondestroy","可以","选项","尽量少","绘制","元素","修改","以上","库","耗时","纯白","和","多","视频","a","任务","处于","补间","看到","注册","避免","相关","列","键","规则","办法","节省","缩放","handler","加个","所以","shape","引入","配置文件","timertask","某个","defaultconfig","zh","返回值","并且","匿名","事件","tools","语言","包拖到","给","销毁","真实","调用","红色","压缩","严重","断点","掉","16","占用","间隔","响应","所有","反射","版本","背景图片","循环","上次","context","一种","declaration","跳转","热","三方","相当于","国内","bitmaprigiondecode","黑屏","门槛","离开","无限","确定","数据","管理","包括","注意","需求","proguard","记得","4","控制","安全","通过","想","阻塞","*","缓存","决定","时候","加载","弊端","很大","背景图","过度","开发","删除","字符串","html","缩略","难免","解决","出现","结构","是","多余","cancel","自定","systrace","最好","shrinkresource","例子","执行","对于","rxjava","而是","可用","要","会","都","然后","信息","intentservice","程中","占位","16ms","分配内存","建议","configs","{","thread","卡顿","theme","埋点","但是","影响","3g","查找","手动","minifyenable","展现","cpu","dex","程序","？","弱","xml","androidmanifest","次数","80%","窗口",":","sdk","而","能","字节","工作","创建","前先","运行","6","继续执行","不用","负荷","临时","}","每个","差别","rcn","代码优化","又","思路","与","业务","移","淡黄色","触摸","很快","马上","--","考虑","线程","压力","初始","normal","从而","问题","主线","不必","release","declearation","gpu","是从","缩略图","或者","轮训","kill","通常","intentservie","出发","识别","armv7","buildtypes","没有","签名","事","第一次","runable","答","stringbuffer","取出","mainactivity","显示","主要","在","时间","不是","初探","拉取","发生","尽量","存在","释放","化成","白色","18","越高","号","主题","样式","对应","resource","支持"],"title":"APP整体优化","title_tokens":["app","优化","整体"]},{"location":"better/#_1","text":"性能优化 内存优化 什么是内存泄漏？ 原因 影响？ 工具-leakcanary 代码优化 使用lint检查取出无效代码 代码规范优化 UI优化（布局优化和绘制优化） 布局优化 速度优化（线程优化和网络优化） 线程优化 使用线程池 网络优化 图片： 加载Loading优化 电量优化 启动优化 冷启动 暖启动 热启动 启动页优化 分析性能的工具 APK瘦身 APK构成初探 优化方案","text_tokens":["影响","loading","池","网络","原因","内存","-","？","暖","lint","规范","）","的","加载","页","热启动","（","ui","是","优化","分析","电量","性能","工具","构成","取出","图片","代码优化","绘制","leakcanary","泄漏","布局","："," ","速度","检查","瘦身","和","初探","apk","无效","代码","什么","线程","冷启动","使用","方案","启动"],"title":"性能优化","title_tokens":["性能","优化"]},{"location":"better/#_2","text":"内存泄漏是常客","text_tokens":["常客","内存","泄漏","是"],"title":"内存优化","title_tokens":["内存","优化"]},{"location":"better/#_3","text":"内存不在GC的掌控范围内 对一些对象有有限的周期声明，希望要做的事完成了，它会被垃圾回收器回收掉，但是有一些对这个对象的引用还存在，导致无法被回收，占用内存，持续累加，内存很快被耗尽OOM. 如一个activity的onDestroy被调用，但是如果有一个后台线程持有这个activity的引用，该activity占用的内存就不能被回收。","text_tokens":["该","内","后台","持续","无法","gc","不","范围","垃圾","内存","activity","它会","做","的","如","对象","了","持有","一些","耗尽","引用","声明","还","调用","这个","oom","对","事","不能","就","ondestroy","器","掉","占用","，","一个","周期"," ",".","。","在","完成","要","掌控","累加","存在","希望","有限","回收","导致","被","很快","如果","线程","但是","有"],"title":"什么是内存泄漏？","title_tokens":["什么","内存","泄漏","？","是"]},{"location":"better/#_4","text":"错误使用单例-context(ApplicationContext) handler 在handler中设置ui元素 解决方案： 1. activity关闭的时候移除所有的消息和runable 2. 采用静态内部类+弱引用 thread 非静态内部类或者匿名类创建线程会隐式引用activity,线程run方法不执行完，线程是不会销毁的，所引用的activity也不会销毁。 解决方案： 线程内部使用弱引用/加个tag,activity销毁时修改tag值，不继续执行线程中的操作 AsyncTask 在AsyncTask中进行耗时操作，完成后，更新ui，有时会在耗时操作还没结束，activity就退出了，但是引用还被AsyncTask持有，无法释放导致内存泄漏。 解决方法：在ondestroy的时候，调用AsyncTask.cancel() 5. 资源未关闭BroadcastReceiver、注册后记得取消注册。 6. 动画资源未释放，无限循环动画","text_tokens":["handler","加个","取消","资源","activity","方法","5","不会","的","匿名","tag","设置","1","销毁","后","调用","broadcastreceiver","泄漏","所有","循环",",","context","时","无限","移除","记得","2","时候","持有","引用","单例","解决","applicationcontext","还","采用","是","cancel","(","就","非","执行","关闭","未","。","会",")","thread","方案","但是","内部","类","有时","错误","内存","弱","更新","asynctask","ui","run","也","创建","消息","6","继续执行","继续","，"," ",".","完成","操作","解决方案","所","+","线程","结束","静态","无法","不","完","-","隐式","中","/","进行","或者","了","、","没","值","runable","ondestroy","元素","修改","：","耗时","在","和","动画","释放","导致","被","注册","使用","退出"],"title":"原因","title_tokens":["原因"]},{"location":"better/#_5","text":"oom","text_tokens":["oom"],"title":"影响？","title_tokens":["影响","？"]},{"location":"better/#-leakcanary","text":"java的GC内存回收机制是什么？ 答：对象在没有任何引用的时候才会被回收 GC回收机制的原理是什么？/可以作为GC Root引用点是啥？ 答：1.java栈中引用的对象2.方法静态引用的对象3.方法常量引用的对象4.Native中JNI引用的对象5.Thread-活着的线程。 内存泄漏原因？ 答:代码存在泄漏，内存无法释放/图片加载消耗大量内存，系统给应用分配内存即为应用能占用内存的最大值。 Android Profiler 测量应用性能","text_tokens":["活着","栈中","android","测量","无法","gc","java","消耗","原因","内存","方法","？","5","-","4","即","中","/","2","的","时候","加载","对象","大值","系统","分配","root","任何","常量","引用","最大",":","最大值","能","profiler","是","才","没有","给","1","性能","答","作为","3","可以","thread","图片","占用","泄漏","，","大量","："," ",".","native","。","在","啥","应用","会","存在","释放","回收","被","点","代码","分配内存","什么","原理","线程","jni","为","静态","机制"],"title":"工具-leakcanary","title_tokens":["-","工具","leakcanary"]},{"location":"better/#_6","text":"","text_tokens":[],"title":"代码优化","title_tokens":["代码优化","优化","代码"]},{"location":"better/#lint","text":"检测未使用的资源 点击菜单栏 Analyze -> Run Inspection by Name -> unused resources -> Moudule ‘app’ -> OK 检测无效代码 步骤：点击菜单栏 Analyze -> Run Inspection by Name -> unused declaration -> Moudule ‘app’ -> OK","text_tokens":["检测","app","’","资源","-","moudule","菜单栏","unused","的","步骤","run","name","resources","ok","未","inspection","by","："," ","‘","菜单",">","无效","declaration","点击","代码","analyze","使用"],"title":"使用lint检查取出无效代码","title_tokens":["无效","取出","代码","使用","lint","检查"]},{"location":"better/#_7","text":"避免创建不必要的对象，越少的对象意味着越少的GC操作 1. 字符串拼接优先使用stringBuilder或stringBuffer,而不是+号连接，+会创建多余的对象，拼接的字符串越长，+号连接符的性能越低 2. 当一个方法返回值为string通常要判断string的作用，如果明确知道该方法返回的string再进行拼接可以考虑返回一个stringBuuffer对象来替代，将一个对象的引用返回，而返回string则是创建了一个短生命周期的临时对象。 静态优于抽象 如果只是想调用来完成某项功能，可设置成静态的，不用专门调用这个方法而创建对象 对常量使用static final修饰 去除淡黄色警告 节制的使用service,可考虑使用intentServie代替service 不适用静态变量保存核心数据 android的进程并不是安全的，被kill掉后，app不会重新开始启动，android系统会创建一个新的Apllication对象然后启动上次用户离开时的activity,造成这个app从来没有退出的假象，静态变量数据由于进程被杀死而被初始化。 轮询操作优化 大概思路：当用户打开这个页面的时候初始化TimerTask对象，每个一分钟请求一次服务器拉取订单信息并更新UI，当用户离开页面的时候清除TimerTask对象，即取消轮训请求操作","text_tokens":["优于","适用","假象","取消","生命","activity","方法","连接符","由于","初始化","即","timertask","不会","务器","的","返回值","重新","抽象","一分钟","设置","轮询","1","后","调用","掉","返回","连接","apllication","上次",",","如果","时","service","启动","android","离开","数据","app","gc","开始","越少","并","安全","想","一分","2","时候","打开","系统","stringbuuffer","字符串","引用","变量","替代","是","多余","static","核心","拼接","修饰","黄色","代替","。","作用","知道","会","要","从来","然后","信息","只是","专门","大概","final","某项","字符","为","订单","意味","该","清除","可","杀死","新","更新","stringbuilder","请求","明确","ui","而","创建","淡黄","来","string","优化","这个","不用","临时","性能","再","每个","服务","意味着","不必要","成","，","一个","周期","."," ","生命周期","思路","完成","一次","操作","淡黄色","+","必要","考虑","则","初始","当","静态","不必","去除","判断","不","造成","优先","服务器","越低","功能","进行","将","对象","页面","了","轮训","常量","kill","进程","通常","intentservie","保存","用户","或","没有","对","短","stringbuffer","可以","创建对象","：","节制","不是","拉取","分钟","被","号","越长","使用","避免","退出","警告"],"title":"代码规范优化","title_tokens":["规范","优化","代码"]},{"location":"better/#ui","text":"每秒60帧，相当于每帧需要在大概16毫秒内完成渲染，否则就会卡顿 ui线程做耗时操作 Layout过于复杂，无法在16ms内完成渲染 同一时间动画执行的次数过多，CPU GPU负荷过重 View频繁的触发measure layout 内存频繁出发gc,stoptheword onDraw方法不需要创建新的对象 onDraw方法不需要执行耗时操作循环 无用的资源和逻辑导致加载和执行缓慢） Analyze->Run Inspection by Name… –>unused resource Analyze->Inspect Code anr 通过瞬时测试和压力测试更容易出发上面问题 如何来定位？ 1. 系统设置-开发者选项-调试GPU过度绘制，红色区域过度绘制，层级/relativelayout和linealayout 2.","text_tokens":["code","view","同一时","资源","方法","开发者","帧","做","触发","容易","的","瞬时","设置","inspect","1","相当","红色","16","过重","by","循环",">",",","相当于","analyze","频繁","测试","内","anr","relativelayout","gc","）","过于","通过","2","加载","–","系统","过度","开发","linealayout","执行","inspection","区域","渲染","…","更","大概","16ms","一时间","定位","卡顿","cpu","如何","内存","毫秒","layout","新","？","缓慢","次数","ui","stoptheword","run","创建","来","每秒","每帧","负荷","复杂","否则","，","同一时间"," ",".","层级","逻辑","完成","操作","调试","线程","压力","问题","gpu","过多","无法","不","-","measure","/","ondraw","unused","对象","上面","同一","出发","name","当于","就会","需要","一时","选项","绘制","60","耗时","在","时间","和","动画","导致","resource","无用"],"title":"UI优化（布局优化和绘制优化）","title_tokens":["和","优化","（","ui","绘制","布局","）"]},{"location":"better/#_8","text":"include优化-重用公共布局 viewstub优化-仅在需要时才加载布局性能比VISISBLE好 merge优化-可以删减多余的层级，优化ui，但是无法预览 减少重叠，背景图,selector normal改成透明","text_tokens":["重叠","无法","-","viewstub","好","预览","透明","能比","重用","的","加载","减少","背景图","ui","仅","多余","背景","公共","需要","时才","性能比","优化","改成","selector","性能","可以","merge","，","布局","层级"," ","删减","在","visisble",",","include","normal","但是"],"title":"布局优化","title_tokens":["布局","优化"]},{"location":"better/#_9","text":"ANR Activity 5s触摸或者键盘输入事件无响应，broadcastReceiver 10s, service 20s","text_tokens":["10s","或者","无","20s","触摸",",","anr","broadcastreceiver","5s","activity","事件","响应","，","service"," ","键盘","输入","键盘输入"],"title":"速度优化（线程优化和网络优化）","title_tokens":["和","优化","（","网络","线程","速度","）"]},{"location":"better/#_10","text":"以上出现的anr多数由于线程阻塞引起的，可通过以下方法解决 * Asytask * HandlerThread * ThreadPool * intentService *","text_tokens":["以下","threadpool","anr","可","方法","asytask","由于","通过","*","阻塞","的","handlerthread","解决","出现","多数","以上","引起","，"," ","intentservice","线程"],"title":"线程优化","title_tokens":["线程","优化"]},{"location":"better/#_11","text":"直接创建Thread实现Runable的弊端，大量线程的创建和销毁很容易导致gc频繁的执行，发生内存抖动从而造成界面卡顿 为什么使用线程池？ 1. 重用线程 2. 控制最大并发数量 3. 对线程进行一定的管理 例子： Rxjava，rxandroid","text_tokens":["为什么","很","管理","池","gc","卡顿","内存","？","rxandroid","造成","控制","并发","重用","2","容易","的","进行","弊端","最大","界面","数量","一定","创建","1","销毁","抖动","对","例子","runable","3","执行","实现","，","大量","："," ",".","rxjava","和","发生","导致","什么","线程","使用","thread","直接","频繁","从而"],"title":"使用线程池","title_tokens":["池","线程","使用"]},{"location":"better/#_12","text":"","text_tokens":[],"title":"网络优化","title_tokens":["网络","优化"]},{"location":"better/#_13","text":"图片优化使用webP格式，大幅节省流量，相对于jpg节省25~35%，对于png节省80% Bitmap优化 使用Android Matrix对图片缩放。 如何在不使用 缩略图，不压缩，优化，使用android bitmapRigionDecode显示指定区域。 Glide加载优化 之前看到豆瓣的开源接口，思路很好，接口返回图片的数据有三种，高清大图、正常图片、缩略图，处于wifi用高清大图，4g或3g用正常，弱网条件下加载缩略图 网络请求处理： 对服务端返回的数据合理的缓存 下载采用断点续传 刷新数据尽可能采用局部刷新","text_tokens":["下","节省","缩放","高清","webp","的","略图","于","压缩","开源","断点","返回","matrix","尽可能","刷新","wifi","有","bitmaprigiondecode","流量","android","数据","局部","好","缓存","豆瓣","~","加载","指定","条件","相对","缩略","25","处理","大幅","采用","正常","三种","对于","区域","4g","。","35%","断点续传","很","3g","尽可","弱网","格式","可能","如何","网络","合理","请求","80%","用","png","优化","服务","，","思路"," ","之前","jpg","下载","glide","服务端","不","缩略图","大图","、","接口","或","对","图片","显示","：","在","处于","看到","使用","bitmap"],"title":"图片：","title_tokens":["：","图片"]},{"location":"better/#loading","text":"一种就是从A页面跳转到B页面时的加载loading,loading的时候页面是纯白色，加载完数据才显示内容页面 在某个页面操作某种逻辑，局部loading(帧动画或者补间动画)，建议在销毁弹窗时，销毁动画。","text_tokens":["loading","数据","局部","完","是从","到","帧","某个","的","时候","加载","或者","页面","内容","是","才","纯白色","销毁","(","就","b","显示","，"," ","逻辑","纯白","在","。","操作","动画",",","一种","a","跳转","白色",")","补间","弹窗","时","建议","某种"],"title":"加载Loading优化","title_tokens":["loading","优化","加载"]},{"location":"better/#_14","text":"重视程度低，音乐和视频耗电最大 网络请求前先判断网络的状态 网络请求最好进行批量处理，避免频繁间隔的网络请求 有wifi和移动网络优先使用wifi,请求wifi的耗电量远比移动耗电量低","text_tokens":["耗电","判断","网络","优先","移动","程度","请求","的","进行","最大","重视","处理","前先","最好","音乐","电量","间隔","，"," ","低","和","视频","批量",",","耗电量","wifi","状态","远比","频繁","使用","避免","有"],"title":"电量优化","title_tokens":["电量","优化"]},{"location":"better/#_15","text":"","text_tokens":[],"title":"启动优化","title_tokens":["优化","启动"]},{"location":"better/#_16","text":"耗时最长的，第一次启动app或者杀死进程第一次启动，主要包括application creat和activity的creat，因此在两个类的oncreat方法中做的事情越多，冷启动消耗的时间越长","text_tokens":["最长","两个","app","包括","杀死","类","消耗","activity","方法","中","做","的","或者","creat","oncreat","越","第一","进程","事情","第一次","主要","application","，","耗时","一次"," ","在","时间","和","多","越长","冷启动","因此","启动"],"title":"冷启动","title_tokens":["冷启动","启动"]},{"location":"better/#_17","text":"当应用中的Activity被销毁，但在内存中常驻时，启动方式就变成暖启动，减少了对象的初始化、布局加载等工作，启动时间更短，系统依然会展现闪屏页，直到第一个activity页面呈现","text_tokens":["展现","方式","暖","activity","内存","初始化","中","的","直到","加载","对象","页","减少","了","系统","依然","、","闪屏","第一","页面","但","呈现","常驻","工作","销毁","短","就","，","布局","一个","在","应用","时间","更","会","变成","被","时","当","初始","等","第一个","启动"],"title":"暖启动","title_tokens":["暖","启动"]},{"location":"better/#_18","text":"用户使用返回键退出应用，然后又马上重新启动应用 1. 白屏 2. 闪屏页倒计时进行一些预加载 3. 主线程中涉及到的sp操作尽量在非ui线程执行 4. application创建过程尽量少的进行耗时操作 5. 减少布局的层次","text_tokens":["键","过程","5","4","到","重新启动","2","进行","的","预","白屏","加载","页","减少","涉及","重新","闪屏","一些","sp","ui","用户","创建","层次","1","计时","3","非","执行","尽量少","返回","application","又","，","倒计","布局","."," ","耗时","在","应用","操作","尽量","然后","程中","马上","主线","线程","使用","倒计时","退出","启动"],"title":"热启动","title_tokens":["热启动","启动"]},{"location":"better/#_19","text":"启动时间优化，从Application的onCreat()方法开始到MainActivity的onCreat()执行结束 延迟初始化 后台任务 启动界面预加载 * intentService分担部分初始化工作 bugly\\推送，热修复等。。。 启动页白屏处理 为什么会出现？ zygote在启动一个APP时，会创建一个新的进程去运行这个app,创建进程是需要时间的，创建完成之前，界面是假死状态，系统根据你的manifest文件设置的主题颜色来展示一个白屏或者黑屏，称为preview window，即预览窗口 实际就是activity默认主题的android:windowBackground为白色或者黑色决定的 APP启动--previewWindow--启动页 解决办法有透明主题 添加一个有背景的style样式 ，然后闪屏页引用该theme主题，在该页面将window的背景图片设置为空","text_tokens":["办法","延迟","activity","方法","初始化","即","预览","的","白屏","oncreat","分担","闪屏","根据","style","添加","设置","previewwindow","颜色","推送","背景图片",",","热","为空","时","有","黑屏","启动","android","app","展示","开始","修复","*","决定","预","加载","去","系统","你","背景图","解决办法","引用","解决","出现","处理","是","(","称为","执行","黑色","\\","。","会","intentservice","然后","windowbackground",")","默认","为","theme","preview","为什么","该","？","新","到","透明","部分","后台任务","页","窗口","zygote",":","就是","工作","创建","来","运行","优化","这个","application","，","一个","window"," ","完成","之前","--","从","什么","状态","初始","结束","bugly","等","假死","后台","或者","将","页面","实际","界面","进程","manifest","文件","背景","需要","mainactivity","图片","在","时间","任务","白色","主题","样式"],"title":"启动页优化","title_tokens":["页","优化","启动"]},{"location":"better/#_20","text":"Systrace 进行埋点，使用门槛搞点，需要输入命令 原理：在一些关键链路中插入label,通过label的开始和结束时间来确定某个核心过程的执行时间，framwork层和java从都插入了label信息，亦可以自定义label 系统版本越高，Framwork中添加的系统可用label就越多 使用注意事项： 1. 手动缩小范围 2. sdk/plaform-tools/systrace目录下执行命令 3. 执行结束后会生成一个trace.html文件 自定义label 在开始和结束的地方加上自定义label,抓一遍trace，分析问题 如何分析非debug app debug和非debug性能差别很大，为了支持debug,系统开启了一些列功能，并且关闭掉了某些重要优化 ，要想分析app真实的运行情况必须要在非debug的APP中启动systrace功能。 通过反射调用sdk中一个@hide的函数 traceView 运行时开销很严重，trace会收集程序运行时所有方法的耗时情况 可以埋点 Profiler","text_tokens":["列","下","traceview","亦","搞点","方法","framwork","某个","的","并且","重要","一些","注意事项","tools","开销","添加","debug","地方","1","后","真实","调用","严重","必须","3","掉","收集","所有","反射","版本","label","情况",",","原理","函数","时","抓","启动","缩小","门槛","过程","确定","插入","app","注意","开始","通过","想","2","程序运行","很大","层","系统","html","profiler","核心","自定","systrace","生成","加上","就","非","执行","关闭","命令","一遍","可用","plaform","。","会","要","都","信息","某些","埋点","很","hide","手动","如何","事项","@","程序","自定义","trace","sdk","开启","目录","来","运行","分析","优化","性能","差别","，","一个"," ",".","从","结束","问题","定义","java","范围","-","执行命令","中","/","链路","功能","进行","了","越","输入","文件","需要","关键","可以","：","耗时","在","时间","和","多","越高","为了","使用","支持"],"title":"分析性能的工具","title_tokens":["性能","的","分析","工具"]},{"location":"better/#apk","text":"","text_tokens":[],"title":"APK瘦身","title_tokens":["瘦身","apk"]},{"location":"better/#apk_1","text":"将apk包拖到android studio中就可以看到包结构了。 lib 主要存储各cpu架构的so库 classes.dex java文件编译生成的字节码文件 res 资源文件 AndroidManifest.xml 配置文件 META-INFO 相关签名信息 resource.arsc 资源文件映射表","text_tokens":["相关","android","各","cpu","dex","java","资源","-","xml","配置","配置文件","androidmanifest","so","中","包","架构","的","meta","将","了","classes","编译","arsc","表","结构","lib","字节","info","包拖到","文件","生成","签名","res","studio","就","拖到","可以","主要","库"," ",".","。","存储","apk","信息","看到","码","映射","resource"],"title":"APK构成初探","title_tokens":["初探","构成","apk"]},{"location":"better/#_21","text":"使用minifyEnable混淆代码 android { buildTypes { release { minifyEnabled true } } } proguard-rules.pro中编写混淆规则 使用ShrinkResources移除无用资源 android { buildTypes { release { minifyEnabled true shrinkResources true } } } shrinkResource必须与minifyResource同时开启才有效。 注意：采用该方法其实无用的资源并没有被移除掉，而是被体积更小的占位符替代了 删除项目中未使用到的资源文件 通过androidstudio提供的lint工具，analyze-run inspection by name然后输入unused resource查找未使用的资源文件，然后删除。 删除项目中未使用的代码 analyze-run inspection by name然后输入unused declearation 找到无用代码对其删除 通过反射引用的方法或者类，lint识别不了，也会给检查出来，删除的时候通过反射引用的方法或者类千万不能删除 对图片进行压缩 将Png图片换成体积更小的jpg格式。 使用tinypng或者upng对图片进行压缩 使用vector矢量图 将图片转化成webP格式(要求最低的api是18)转换后jpg节省35%。png 80% 使用shape代替图片 使用Resource Configs进行语言配置 Android应用本身是支持国际化的，但国内的项目好多都是在国内使用，不需要国际化，这时候可以对相关的String进行减法操作，使其只包含特定的语言（例如中文） android { defaultConfig { ... //语言资源，只支持中文 resConfigs \"zh-rCN\" } } so库操作，在引入第三方sdk难免要引入对应的so库，一般给到的so库分好多架构（armeabi, armeabi-v7a, x86等等） Android系统 目前支持以下七种不同的CPU架构： ARMv5 ARMv7 x86 MIPS ARMv8 MIPS64 x86_64 所有的架构设备x86,x8664,armeabi-v7a,arm64-v8a都支持armeabi架构的.so文件，所以可以根据自己的业务需求选择使用armeabi或者armeabi-v7a 微信、qq、网易云音乐等都只保留了armeabi-v7a android { defaultConfig { ndk { abiFilters 'armeabi','armeabi-v7a' } } }","text_tokens":["相关","规则","矢量","除掉","节省","所以","shape","引入","资源","方法","webp","使","defaultconfig","zh","的","api","七种","符","中文","语言","找到","根据","androidstudio","给","后","编写","一般","压缩","音乐","必须","所有","by","反射","换成","中未","应用","目前",",","三方","mips64","analyze","特定","国内","pro","android","网易","包含","需求","注意","proguard","minifyenabled","移除","并","lint","这时候","其","通过","）","abifilters","时候","减法","tinypng","选择","系统","设备","删除","引用","难免","v7a","v8a","采用","替代","是","x86","qq","(","shrinkresource","未","inspection","转化","同时","例如","而是","代替","。","检查","国际","upng","更","会","千万","都","然后","占位","第三方","要","minifyresource",")","第三","微信","rules","configs","{","体积","35%","该","好多","查找","不了","格式","minifyenable","cpu","类","这时","\"","armv8","arm64","armeabi","提供","配置","到","80%","本身","mips","...","出来","sdk","run","开启","也","才","混淆","x8664","png","string","}","不能","国际化","工具","要求","rcn","'","其实","，","."," ","true","最低","操作","与","vector","移","业务","jpg","有效","shrinkresources","库分","等","_","release","以下","declearation","armv5","不","-","64","so","中","/","架构","unused","进行","或者","将","转换","了","（","、","但","自己","name","识别","armv7","buildtypes","没有","项目","文件","输入","云","需要","小","转化成","对","只","图片","可以","库","不同","：","在","等等","化成","矢量图","被","代码","18","ndk","使用","保留","resconfigs","对应","resource","无用","支持"],"title":"优化方案","title_tokens":["方案","优化"]},{"location":"contact/","text":"'hey guys! this is contact me page'","text_tokens":["me","page","this","hey","'","is"," ","!","guys","contact"],"title":"Contact","title_tokens":["contact"]},{"location":"designParttern/","text":"云收银APP阅读文档 SplashActicity 1.initUmeng+initSunmiBlePrint 2.延时3s一个handler来决定接下来进入哪个页面（括号里面是条件）  进入GuidActivity(判断sp版本号跟配置文件版本号是否一致，进入登陆页面时保存版本号)  进入MainActivity(通过logintoken判断是否进入MainActivity)  进入LoginAcitivity(else进入LoginActivity) 3.开启日志上传Service GuidActivity  一个很简单滑动的轮播图外加一个进入LoginActivity的按钮 LoginActivity  自定义EditText(主要功能有：清除图标，EditText抖动动画)  重置密码  登陆（包含获取公钥接口+登陆接口）   1.对于登陆参数pwd字段的加密（RSA(pwd,publicKey)）   2.自定义Toast(YellowToastUtils密码错误顶部显示一段黄色背景提示)   3.使用Linerlayout+RelativeLayout framlayout+权重布局法  4.","text_tokens":["里面","edittext","获取","handler","图","else","splashacticity","配置文件","图标","权重","linerlayout","的","参数","滑动","收银","跟","1","一致","guidactivity","3","布局","版本","阅读",",","时","service","有","toast","包含","app","relativelayout","顶部","4","）","决定","通过","2","pwd","sp"," ","条件","是","括号","是否","自定","加密","(","黄色","对于",")","按钮","重置","framlayout","很","清除","3s","错误","哪个","配置","外加","initsunmibleprint","自定义","公钥","上传","开启","来","延时","，","一个","."," ","yellowtoastutils","+","接下","字段","rsa","publickey","定义","判断","一段","下来","功能","loginacitivity","页面","日志","登陆","（","initumeng","进入","保存","接口","接下来","云","文件","轮播","背景","抖动","mainactivity","版本号","显示","主要","：","密码","法","动画","logintoken","提示","简单","使用","loginactivity","文档"],"title":"**云收银APP阅读文档**","title_tokens":["阅读","app","收银","云","文档","*"]},{"location":"designParttern/#app","text":"SplashActicity 1.initUmeng+initSunmiBlePrint 2.延时3s一个handler来决定接下来进入哪个页面（括号里面是条件）  进入GuidActivity(判断sp版本号跟配置文件版本号是否一致，进入登陆页面时保存版本号)  进入MainActivity(通过logintoken判断是否进入MainActivity)  进入LoginAcitivity(else进入LoginActivity) 3.开启日志上传Service GuidActivity  一个很简单滑动的轮播图外加一个进入LoginActivity的按钮 LoginActivity  自定义EditText(主要功能有：清除图标，EditText抖动动画)  重置密码  登陆（包含获取公钥接口+登陆接口）   1.对于登陆参数pwd字段的加密（RSA(pwd,publicKey)）   2.自定义Toast(YellowToastUtils密码错误顶部显示一段黄色背景提示)   3.使用Linerlayout+RelativeLayout framlayout+权重布局法  4.","text_tokens":["里面","edittext","获取","handler","图","else","splashacticity","配置文件","图标","权重","linerlayout","的","参数","滑动","跟","1","一致","guidactivity","3","布局","版本",",","时","service","有","toast","包含","relativelayout","顶部","4","）","决定","通过","2","pwd","sp"," ","条件","是","括号","是否","自定","加密","(","黄色","对于",")","按钮","重置","framlayout","很","清除","3s","错误","哪个","配置","外加","initsunmibleprint","自定义","公钥","上传","开启","来","延时","，","一个","."," ","yellowtoastutils","+","接下","字段","rsa","publickey","定义","判断","一段","下来","功能","loginacitivity","页面","日志","登陆","（","initumeng","进入","保存","接口","接下来","文件","轮播","背景","抖动","mainactivity","版本号","显示","主要","：","密码","法","动画","logintoken","提示","简单","使用","loginactivity"],"title":"云收银APP阅读文档","title_tokens":["阅读","app","收银","云","文档"]},{"location":"fourcomponent/","text":"四大组件及生命周期 Activity 生命周期 经典题目：A->B 问A和B的生命周期变化？然后从B返回A，问A和B的生命周期变化？ A(onPause) B(onCreat) B(onStart) B(onResume) A(onStop) 从B返回A B(onPause) A(onRestart) A(onStart) A(onResume) B(onStop) B(onDestroy) 主要知识点：掌握两组对应关系 onStart-onResume onPause-onStop 启动模式 1. standard 标准的栈结构 2. singleTop 在栈顶可复用 3. singleInstance 全局复用，一个独立的栈中，有坑 ActivityA,ActivityB(singleInstance),ActivityC A中启动B,B中启动C 此时按理在任务栈中的顺序从上到下是CBA 按理在C中按返回键应该回到B中，此时却回到了A中。 方法在B中定义全局变量returnActivityB,然后在A的onstart方法中判断全局变量returnActivityB，如果为true则跳转到B 4. singleTask 同栈的复用，顶出栈 经典题目：各个模式的使用场景 数据传递 1. intent 2. startActivityForResult 事件分发 Service service中能否进行耗时操作及如何 和activity通信 1. 生命周期 1. startService * call to startService * onCreat * onStartCommand() * Service running * onDestroy * Service Shut Down 2. bindService * call to bindService * onCreat * onBind * Client are bind to Service * onUnbind * onDestroy * Service shut down 启动模式 1. startService 2. bindService 使用方法 第一步在Manifest中注册 第二步启动startService/bindService 第三步解绑unBindService 第四步暂停stopService Activity和Service通信","text_tokens":["键","能否","知识点","are","生命","activity","方法","onstop","场景","的","oncreat","第一","事件","复用","onresume","standard","顶","onstartcommand","1","第三步","及","unbindservice","3","上到","返回","第四步","二步",">","singletask",",","跳转","c","第二步","如果","栈","activityb","service","有","启动","数据","onrestart","此时","4","一步","*","2","通信","回到","bind","结构","变量","是","singletop","(","cba","知识","顺序","。","全局","却","然后","onbind",")","第三","解绑","组件","独立","为","按理","三步","如何","可","onpause","题目","shut","？","到","running","应该","掌握","stopservice","从上到下","b","activityc","，","一个","周期"," ","生命周期",".","true","标准","操作","暂停","变化","第二","从","则","全局变量","出栈","startactivityforresult","returnactivityb","栈中","定义","模式","判断","to","-","activitya","同栈","client","第四","onstart","中","/","call","关系","各个","进行","坑","了","onunbind","down","manifest","第一步","singleinstance","分发","四大","按","传递","startservice","ondestroy","bindservice","intent","主要","：","耗时","四步","在","和","问","两组","a","任务","注册","使用","经典","对应"],"title":"四大组件","title_tokens":["组件","四大"]},{"location":"fourcomponent/#_1","text":"","text_tokens":[],"title":"四大组件及生命周期","title_tokens":["及","四大","生命","组件","周期","生命周期"]},{"location":"fourcomponent/#activity","text":"生命周期 经典题目：A->B 问A和B的生命周期变化？然后从B返回A，问A和B的生命周期变化？ A(onPause) B(onCreat) B(onStart) B(onResume) A(onStop) 从B返回A B(onPause) A(onRestart) A(onStart) A(onResume) B(onStop) B(onDestroy) 主要知识点：掌握两组对应关系 onStart-onResume onPause-onStop 启动模式 1. standard 标准的栈结构 2. singleTop 在栈顶可复用 3. singleInstance 全局复用，一个独立的栈中，有坑 ActivityA,ActivityB(singleInstance),ActivityC A中启动B,B中启动C 此时按理在任务栈中的顺序从上到下是CBA 按理在C中按返回键应该回到B中，此时却回到了A中。 方法在B中定义全局变量returnActivityB,然后在A的onstart方法中判断全局变量returnActivityB，如果为true则跳转到B 4. singleTask 同栈的复用，顶出栈 经典题目：各个模式的使用场景 数据传递 1. intent 2. startActivityForResult 事件分发","text_tokens":["键","知识点","生命","方法","onstop","场景","的","oncreat","事件","复用","onresume","standard","顶","1","3","上到","返回",">","singletask",",","跳转","c","如果","栈","activityb","有","启动","数据","onrestart","此时","4","2","回到","结构","变量","是","singletop","(","cba","知识","顺序","。","全局","却","然后",")","独立","为","按理","可","onpause","题目","？","到","应该","掌握","从上到下","b","activityc","，","一个","周期"," ","生命周期",".","true","标准","变化","从","则","全局变量","出栈","startactivityforresult","returnactivityb","栈中","定义","模式","判断","-","activitya","同栈","onstart","中","关系","各个","坑","了","singleinstance","分发","按","传递","ondestroy","intent","主要","：","在","和","问","两组","a","任务","使用","经典","对应"],"title":"Activity","title_tokens":["activity"]},{"location":"fourcomponent/#service","text":"service中能否进行耗时操作及如何 和activity通信 1. 生命周期 1. startService * call to startService * onCreat * onStartCommand() * Service running * onDestroy * Service Shut Down 2. bindService * call to bindService * onCreat * onBind * Client are bind to Service * onUnbind * onDestroy * Service shut down 启动模式 1. startService 2. bindService 使用方法 第一步在Manifest中注册 第二步启动startService/bindService 第三步解绑unBindService 第四步暂停stopService Activity和Service通信","text_tokens":["能否","三步","如何","are","to","生命","模式","activity","shut","方法","client","第四","一步","中","*","/","2","call","进行","通信","onunbind","oncreat","running","第一","bind","down","manifest","第一步","onstartcommand","1","第三步","及","(","stopservice","unbindservice","startservice","ondestroy","bindservice","周期",".","耗时","生命周期"," ","在","四步","二步","操作","和","第四步","暂停","onbind","第二步",")","第二","第三","解绑","注册","使用","service","启动"],"title":"Service","title_tokens":["service"]},{"location":"garbage/","text":"jvm内存模型 要理解gc必须理解jvm，jvm主要管理两种内存：堆非堆 堆(Heap Memory)：类实例和数组的内存 非堆(No-heap Memory)：方法区，类结构（运行时常数池，字段和方法），类加载信息 GC主要回收的内存是堆内存 堆内存模型 1. 堆内存分两块，新生代和老年代，比例(1:2) * 老年代主要存放应用程序中生命周期较长的的存活对象 2. 新生代分三个部分，一个eden区和两个survivor区，比例8：1：1 * eden区存放新生的对象 * survivor区存放每次垃圾回收后存活的对象 可回收对象的判定 什么样的对象是垃圾？ 1. 引用计数算法 原理就是给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1， 当引用失效时，计数值就减1，计数器为0的对象就是不在被使用的。 * 简单、高效（objectiveC用的该算法） * 很难处理循环引用（相互引用两个对象） 可达性分析算法 为了解决循环引用，java采用新的算法 从GC的ROOT作为起点，向下搜索它们引用的对象，可生成一棵引用树，树的节点可视为可达对象，反之视为不可达 如何定义GC root,java语言定义如下GC-ROOT对象 * 虚拟机栈中引用的对象 * 方法区中静态属性引用的对象 * 方法区中常量引用的对象 * 本地方法栈中jni引用的对象 ## stop the world 垃圾回收时需要整个引用状态保持不变，否则判定是垃圾，等会就不是了，GC的时候所有的程序执行处于暂停的状态，卡住，这种卡顿非常短，对程序的影响微乎其微，GC的卡顿由此而来。 几种垃圾回收算法 如何回收？Java虚拟机采用的是分代回收算法，想要理解分代回收算法，有必要先了解其它几种简单算法 1. 标记清楚算法(Mark-Sweep) 标记阶段：标记所有需要被回收的对象 清楚阶段：回收被标记对象占用的空间 * 简单，容易实现 * 容易产生内存碎片，碎片太多可能导致后续需要为大对象分配空间无法找到足够的空间，提前触发新的一次垃圾收集动作。 复制算法（Copying） 将内存分为大小相同的两块，每次只使用其中的一块，当这一块用完了，将还活着的对象复制到另外一块，再把已使用的一块一次清理掉，这样就不会出现内存碎片问题， * 简单，高效 * 对内存空间的使用付出了高昂的代价，可 使用内存缩少到了原来的一半 Copying算法的效率取决于活着的对象，活着的对象越多copying越多，效率越慢 标记整理算法（Mark-compact） 标记阶段和Mark-sweep一样，标记出需要被回收的对象，完成标记后，将存活的对象向一端移动，清理掉端边界以外的内存 * 适用于存活对象多，回收对象少的情况 分代回收算法 不是一种新的算法而是复制算法和标记整理算法的整合 复制算法：适用于存活对象少，回收对象多 标记整理算法：适用于存活对象多，回收对象少 堆内存分为老年代(Old generation)和新生代(young Generation),老年代的特点是每次垃圾收集时只有少量的对象需要被回收，新生代的特点是每次垃圾回收时都有大量的对象需要被回收，根据不同代的特点采用不同的算法，这就是分代算法。 详细分析 1. 对于新生代采用Copying算法，因为新生代每次垃圾回收的时候都要回收大部分对象，也就是说需要复制的存活的对象较少，所以采用Copying算法的效率最高，实际中并不是按照上面Copying算法中说的1：1分成相等的两块，而是将新生代分为eden空间和survivor空间8：1：1 2. 由于老年代每次只回收少量对象，一般使用Mark-compact算法 QA1.为什么需要两块Survivor空间？ 这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次GC的时候，我们可以把Eden区的存活对象放到Survivor A空间，但是第二次GC的时候，Survivor A空间的存活对象也需要再次用Copying算法，放到Survivor B空间上，而把刚刚的Survivor A空间和Eden空间清除。第三次GC时，又把Survivor B空间的存活对象复制到Survivor A空间，如此反复。 所以，这里就需要两块Survivor空间来回倒腾。 QA2.为什么EDEN空间这么大而Survivor空间这么小？ 新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。 我看8：1：1就挺好的，当然这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。 新的问题又来了，从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？直接放到老年代去。 Eden空间和两块Survivor空间的工作流程？ 现在假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。 // 分配了一个又一个对象 放到Eden区 // 不好，Eden区满了，只能GC(新生代GC：Minor GC)了 把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的） // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区 // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区 // ... // 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区 // 有的对象太大，超过了Eden区，直接被分配在Old区 // 有的存活对象，放不下Survivor区，也被分配到Old区 // ... // 在某次Minor GC的过程中突然发现： // 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC) Old区慢慢的整理一番，空间又够了 // 继续Minor GC // ... // ... 通过日志分析GC类型 GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。 GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。 GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。 GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。","text_tokens":["两个","计数器","这些","生命","现在","发现","第一","一棵","刚刚","地方","1","缺点","最高","较大","什么样","清理","jni","参考","理解","内存不足","局部","qa2","并","survivor","不够","处理","较","我们","两块","实例","特点","详细","存活","大量","第三","为","转移","the","清除","新","几种","合理","新生","分配","...","qa1","代","分成","来","分析","这个","而来","慢慢","不可","算法","不好","system","大","效率","等","静态","直接","这么","少量","满","定义","无法","java","不","-","minor","/","进行","了","实际","mark","、","上面","memory","往","for","如此","小","对","只","努力","缓解","不同","：","放在","快要","被","老生","concurrent","为了","调整","使用","先","适用","属性","付出","够","其它","少","sigusr1","触发","越多","explicit","容易","的","收到","存放","取决","于","设置","一半","达到","每次","后","可回收","数值","一般","超过","必须","使用率","收集","树","呆","no","可达","向","本来","情况","两种","原理","频繁","流程","活着","比例","只能","过程","池","达","好","异常","也就是说","大而","边界","去","##","复制","绝大","区","整理","非堆","(","oom","程序执行","这是","我","实现","仅供参考","。","高昂","失效","不足","二次","该","为什么","很","类","如何","可","一块","它","到","复制到","移动","root","保持","区满","把","再","copy","否则","周期"," ","三个","出","暂停","之前","字段","什么","从","本地","当","越慢","大小","_","作为","反之","清空","突然","取决于","垃圾","尤其","想要","高效","中","常量","怎么办","以外","compact","heap","反复","后续","回收","导致","简单","移到","新创建","绝大部分","看","比如","0","方法","由于","不会","挺","涉及","找到","根据","年代","添加","由此","整个","应用","假定",",","老","次","整合","时","一定","有","gc","就加","最后","每当","阶段","）","2","另外","倒腾","系统","太","这","引用","表示","变量","常数","采用","还","仅供","生成","就","这里","来回","准备","copying",")","新生代","young","可能","三次","数组","相互","提高","微乎其微","内存","三块","部分","一样","用","放不下","节点","就是","视为","也","就是说","jvm","已","b","继续","，","大大","一个",".","生命周期","一次","完成","原来","操作","一端","必要","新创","一番","状态","模型","虚拟","应用程序","类型","栈中","代价","8","完","内存空间","大大提高","缩少","往往","将","对象","端","（","怎么","接口","需要","大部","短","可以","其中","可达性","和","多","a","generation","处于","用率","经历","所以","objectivec","这种","足够","卡住","stop","放到","相等","如下","非常","分","按照","中说","语言","给","定量","碎片","调用","掉","占用","不过","计数","所有","循环","减","抛","一种","不下","它们","较长","很难","vmruntime","堆","分代","管理","包括","第三次","清楚","*","通过","时候","加载","major","不变","细分","解决","出现","结构","是","产生","搜索","某次","执行","了解","当然","空间","对于","而是","这样","要","会","都","信息","起点","然后","计","卡顿","sweep","但是","影响","只有","程序","？","动作","大部分","第二次",":","应该","malloc","而","能","工作","创建","提前","运行","上","临时","eden","又","old","因为","马上","供参考","第二","空","问题","before","下来","分为","详细分析","判定","虚拟机","或者","自动","相同","日志","局部变量","由此而来","第一次","一定量","信号","主要","在","不是","释放","再次","向下","world","15","区中","标记"],"title":"垃圾回收机制","title_tokens":["回收","机制","垃圾"]},{"location":"garbage/#jvm","text":"要理解gc必须理解jvm，jvm主要管理两种内存：堆非堆 堆(Heap Memory)：类实例和数组的内存 非堆(No-heap Memory)：方法区，类结构（运行时常数池，字段和方法），类加载信息 GC主要回收的内存是堆内存","text_tokens":["理解","堆","数组","类","管理","池","gc","内存","-","方法","）","的","加载","（","memory","结构","常数","是","区","非堆","(","实例","运行","jvm","必须","heap","主要","，","no","："," ","和","要","信息","回收","两种",")","字段","时"],"title":"jvm内存模型","title_tokens":["jvm","内存","模型"]},{"location":"garbage/#_1","text":"1. 堆内存分两块，新生代和老年代，比例(1:2) * 老年代主要存放应用程序中生命周期较长的的存活对象 2. 新生代分三个部分，一个eden区和两个survivor区，比例8：1：1 * eden区存放新生的对象 * survivor区存放每次垃圾回收后存活的对象","text_tokens":["应用程序","比例","较长","堆","两个","8","垃圾","生命","程序","内存","中","*","2","部分","分","的","对象","新生","survivor",":","存放","年代","区","1","每次","后","两块","(","eden","主要","，","存活","一个","周期","."," ","生命周期","三个","：","应用","和","回收","老",")","新生代"],"title":"堆内存模型","title_tokens":["内存","模型","堆"]},{"location":"garbage/#_2","text":"什么样的对象是垃圾？ 1. 引用计数算法 原理就是给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1， 当引用失效时，计数值就减1，计数器为0的对象就是不在被使用的。 * 简单、高效（objectiveC用的该算法） * 很难处理循环引用（相互引用两个对象） 可达性分析算法 为了解决循环引用，java采用新的算法 从GC的ROOT作为起点，向下搜索它们引用的对象，可生成一棵引用树，树的节点可视为可达对象，反之视为不可达 如何定义GC root,java语言定义如下GC-ROOT对象 * 虚拟机栈中引用的对象 * 方法区中静态属性引用的对象 * 方法区中常量引用的对象 * 本地方法栈中jni引用的对象 ## stop the world 垃圾回收时需要整个引用状态保持不变，否则判定是垃圾，等会就不是了，GC的时候所有的程序执行处于暂停的状态，卡住，这种卡顿非常短，对程序的影响微乎其微，GC的卡顿由此而来。","text_tokens":["两个","计数器","属性","0","objectivec","这种","方法","卡住","stop","如下","非常","的","一棵","语言","添加","由此","给","1","地方","数值","整个","树","计数","所有","可达","什么样","循环","减",",","原理","时","有","它们","jni","很难","gc","就加","达","每当","*","）","时候","不变","##","引用","解决","是","处理","采用","搜索","生成","程序执行","就","执行","。","会","起点","计","失效","为","卡顿","the","该","影响","相互","如何","微乎其微","可","程序","它","？","新","用","root","保持","节点","就是","视为","分析","而来","不可","否则","，","一个","算法","."," ","暂停","从","什么","本地","状态","等","当","静态","虚拟","作为","反之","栈中","定义","垃圾","不","java","-","高效","虚拟机","判定","对象","了","、","（","常量","由此而来","需要","对","短","可达性","在","不是","回收","向下","被","world","简单","处于","为了","区中","使用"],"title":"可回收对象的判定","title_tokens":["可回收","的","判定","对象","回收"]},{"location":"garbage/#_3","text":"如何回收？Java虚拟机采用的是分代回收算法，想要理解分代回收算法，有必要先了解其它几种简单算法 1. 标记清楚算法(Mark-Sweep) 标记阶段：标记所有需要被回收的对象 清楚阶段：回收被标记对象占用的空间 * 简单，容易实现 * 容易产生内存碎片，碎片太多可能导致后续需要为大对象分配空间无法找到足够的空间，提前触发新的一次垃圾收集动作。 复制算法（Copying） 将内存分为大小相同的两块，每次只使用其中的一块，当这一块用完了，将还活着的对象复制到另外一块，再把已使用的一块一次清理掉，这样就不会出现内存碎片问题， * 简单，高效 * 对内存空间的使用付出了高昂的代价，可 使用内存缩少到了原来的一半 Copying算法的效率取决于活着的对象，活着的对象越多copying越多，效率越慢 标记整理算法（Mark-compact） 标记阶段和Mark-sweep一样，标记出需要被回收的对象，完成标记后，将存活的对象向一端移动，清理掉端边界以外的内存 * 适用于存活对象多，回收对象少的情况 分代回收算法 不是一种新的算法而是复制算法和标记整理算法的整合 复制算法：适用于存活对象少，回收对象多 标记整理算法：适用于存活对象多，回收对象少 堆内存分为老年代(Old generation)和新生代(young Generation),老年代的特点是每次垃圾收集时只有少量的对象需要被回收，新生代的特点是每次垃圾回收时都有大量的对象需要被回收，根据不同代的特点采用不同的算法，这就是分代算法。 详细分析 1. 对于新生代采用Copying算法，因为新生代每次垃圾回收的时候都要回收大部分对象，也就是说需要复制的存活的对象较少，所以采用Copying算法的效率最高，实际中并不是按照上面Copying算法中说的1：1分成相等的两块，而是将新生代分为eden空间和survivor空间8：1：1 2. 由于老年代每次只回收少量对象，一般使用Mark-compact算法 QA1.为什么需要两块Survivor空间？ 这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次GC的时候，我们可以把Eden区的存活对象放到Survivor A空间，但是第二次GC的时候，Survivor A空间的存活对象也需要再次用Copying算法，放到Survivor B空间上，而把刚刚的Survivor A空间和Eden空间清除。第三次GC时，又把Survivor B空间的存活对象复制到Survivor A空间，如此反复。 所以，这里就需要两块Survivor空间来回倒腾。 QA2.为什么EDEN空间这么大而Survivor空间这么小？ 新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。 我看8：1：1就挺好的，当然这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。 新的问题又来了，从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？直接放到老年代去。 Eden空间和两块Survivor空间的工作流程？ 现在假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。 // 分配了一个又一个对象 放到Eden区 // 不好，Eden区满了，只能GC(新生代GC：Minor GC)了 把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的） // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区 // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区 // ... // 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区 // 有的对象太大，超过了Eden区，直接被分配在Old区 // 有的存活对象，放不下Survivor区，也被分配到Old区 // ... // 在某次Minor GC的过程中突然发现： // 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC) Old区慢慢的整理一番，空间又够了 // 继续Minor GC // ... // ...","text_tokens":["这些","现在","发现","第一","刚刚","1","缺点","最高","较大","清理","参考","理解","局部","qa2","并","survivor","不够","较","我们","两块","特点","详细","存活","大量","第三","为","转移","清除","新","几种","合理","分配","新生","...","qa1","代","分成","来","分析","这个","慢慢","算法","不好","大","效率","直接","这么","少量","满","无法","java","不","-","minor","/","了","实际","mark","上面","往","如此","小","对","只","缓解","不同","：","放在","被","老生","调整","使用","先","适用","付出","够","其它","少","触发","越多","容易","的","取决","于","设置","一半","每次","后","一般","超过","使用率","收集","呆","向","本来","情况","频繁","流程","活着","比例","只能","过程","好","也就是说","大而","边界","去","复制","绝大","整理","区","(","这是","我","实现","仅供参考","。","高昂","二次","为什么","很","如何","可","一块","到","复制到","移动","区满","把","再","copy","周期"," ","出","从","什么","当","越慢","大小","清空","突然","取决于","垃圾","尤其","想要","高效","中","怎么办","以外","compact","反复","后续","回收","导致","简单","移到","新创建","绝大部分","看","比如","由于","不会","挺","涉及","找到","根据","年代","假定",",","老","次","整合","时","有","gc","阶段","）","2","另外","倒腾","太","这","变量","采用","还","仅供","就","这里","来回","copying",")","新生代","young","可能","三次","提高","内存","三块","部分","一样","用","放不下","就是","也","就是说","已","b","继续","，","大大","一个",".","一次","完成","原来","一端","必要","新创","一番","虚拟","代价","8","完","内存空间","大大提高","缩少","往往","将","对象","端","（","怎么","需要","大部","可以","其中","和","多","a","generation","用率","经历","所以","足够","放到","相等","按照","中说","碎片","掉","占用","不过","所有","一种","不下","堆","分代","包括","第三次","清楚","*","时候","major","细分","出现","是","产生","某次","了解","当然","空间","对于","而是","这样","要","都","然后","sweep","但是","只有","？","动作","大部分","第二次","应该","而","能","工作","创建","提前","上","临时","eden","又","old","因为","马上","供参考","第二","空","问题","下来","分为","详细分析","虚拟机","或者","相同","局部变量","第一次","在","不是","再次","15","标记"],"title":"几种垃圾回收算法","title_tokens":["算法","回收","几种","垃圾"]},{"location":"garbage/#gc","text":"GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。 GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。 GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。 GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。","text_tokens":["应用程序","满","内存不足","理解","vmruntime","堆","before","gc","程序","内存","最后","异常","sigusr1","触发","explicit","的","或者","时候","进行","对象","自动","分配","系统","收到","、","表示",":","malloc","而","接口","for","是","达到","我们","定量","来","上","调用","oom","一定量","准备","可以","信号","努力","，"," ",".","。","在","应用","快要","操作","会","释放","抛","之前","concurrent","system","时","不足","当","一定","_","为"],"title":"通过日志分析GC类型","title_tokens":["类型","分析","日志","gc","通过"]},{"location":"handler/","text":"handler原理","text_tokens":["handler","原理"],"title":"Handler原理","title_tokens":["handler","原理"]},{"location":"handler/#handler","text":"","text_tokens":[],"title":"handler原理","title_tokens":["handler","原理"]},{"location":"knowledge/","text":"","text_tokens":[],"title":"Knowledge","title_tokens":["knowledge"]},{"location":"kotuis/","text":"introduce why kotlin? concise safe interoperable","text_tokens":["why","safe","concise","introduce","interoperable","?"," ","kotlin"],"title":"学习笔记","title_tokens":["笔记","学习"]},{"location":"kotuis/#introduce","text":"why kotlin? concise safe interoperable","text_tokens":["why","safe","concise","interoperable","?"," ","kotlin"],"title":"introduce","title_tokens":["introduce"]},{"location":"sdk/","text":"定义 接口设计 出入参设计 调用封装设计 数据返回设计 发送数据 接收数据 参数过滤设计 交互流程设计 异常处理 初始化 个性化配置 SDK安全与校验 SDK打包方法 library module下的build.gradle模板配置： 依赖原则，尽量避免第三方库的依赖 如何解决组件依赖冲突： 定义 jar so aar 一些方法和逻辑合集，对资源api封装后的产物。 接口设计 如无必要勿增实体，如无必要勿增依赖 1. sdk接收什么？输出什么？明确职责 出入参设计 map String 实体类 1. 自定义实体类作为出入参在activity间传输，无法直接传播实体，需要经过序列化。 * 实现serializable接口通过bundle传输 * 实现parcelabel接口，通过budle传输 2. intent中的bundle是通过Binder机制进行数据传输，有大小限制，建议最大不超过500k越小越好，避免传输图片 调用封装设计 如果app需要通过sdk的入口activity进行调用与业务开发，如何做一个优雅的调用封装。 封装前的调用： //繁琐的调用代码 Bundle bundle = new Bundle(); //这里要暴露或者约定一个静态KEY bundle.putParcelable(KEY_REQ, request); Intent intent = new Intent(context, EntryActivity.class); //屏蔽转场动画，让画面跳转更和谐 intent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION); intent.putExtras(bundle); context.startActivity(intent); 封装后的调用： //简洁的调用代码 MySDK.launchSdk(context,req); //将复杂逻辑或细节内置于SDK中，对外提供封装好的静态方法即可 public static void launchSdk(Context context, ReqContent request) { Bundle bundle = new Bundle(); bundle.putParcelable(KEY_REQ, request); Intent intent = new Intent(context, EntryActivity.class); //屏蔽转场动画，让画面跳转更和谐 intent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION); intent.putExtras(bundle); context.startActivity(intent); } 数据返回设计 调用即响应，不可无响应无回调 背景： 1. 需要在app与sdk的activity间进行数据传输 2. 调用sdk后，需要执行一段异步逻辑，结束后需要及时关闭 3. 需要在逻辑代码处理过程中随时随地的构造返回参数并返回。 4. sdk目标用户，各类第三方app，需要通用的交互机制，避免引起兼容问题。 方案： startActivityForResult()?理论可行，但不够灵活，弃。 采用EventBus ? 避免引入非必须第三方依赖，暂时放弃。 采用BroadcastReceiver？Android 内置的四大组件之一，为组件间交互而生。而且灵活方便，与入参方法呼应，可以从Intent中传输数据。 采用应用内广播，无进程间通信，效率更高，更安全 发送数据 //SDK内部封装的静态方法，提供给SDK内部模块统一调用 public static void sendResult(String token, int code, String message) { ResultContent result = new ResultContent(); result.setToken(token); result.setCode(code); result.setMessage(message); Bundle bundle = new Bundle(); bundle.putParcelable(KEY_RESULT, result); Intent intent = new Intent(); intent.setAction(MY_SDK_RECEIVER_ACTION); intent.putExtras(bundle); LocalBroadcastManager.getInstance(MySDK.getContext()).sendBroadcast(intent); } 接收数据 //SDK内部封装的注册方法，提供给APP模块统一调用 public static void registerReceiver(BroadcastReceiver receiver) { IntentFilter filter = new IntentFilter(); filter.addAction(MY_SDK_RECEIVER_ACTION); LocalBroadcastManager.getInstance(getContext()).registerReceiver(receiver, filter); } //SDK内部封装的反注册方法，提供给APP模块统一调用，如果在onCreate()方法中注册，则在onDestroy()方法中反注册。 public static void unregisterReceiver(BroadcastReceiver receiver) { LocalBroadcastManager.getInstance(getContext()).unregisterReceiver(receiver); } //APP 中定义的广播接收器，用于接收返回参数 public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { ResultContent result = MySDKHelper.getResult(intent); if (result == null) { return; } int code = result.getCode(); String message = result.getMessage(); String token = result.getToken(); String log = String.format(Locale.CHINA,\"返回码: %d 返回信息: %s Token: %s\", code, message, token); Log.d(TAG, log); } } 参数过滤设计 对入参数据进行过滤，避免无意义的后续业务流程，及时提供调用反馈。 非空检测，数据类型检测，数据格式检测，自定义注解。 public static final String PRINTER = \"PRINTER\"; public static final String HORN = \"HORN\"; public static final String SOUND = \"SOUND\"; @StringDef({PRINTER, HORN, SOUND}) public @interface DeviceType{} public void getDevice( @DeviceType String deviceType){ } 交互流程设计 前端没有绝对的安全 错误的返回 错误的返回并不会对业务造成损失，比如支付失败，直接当作失败处理即可。 成功的返回 成功的返回有时候会造成损失，比如支付后发货行为，因此必须要判断返回的可靠性。 前端代码，容易被破解者通过hook等非正常手段伪造或者篡改，不能信任前端返回码。 一般支付的交互流程图 异常处理 异常概念（throwable为exception和error父类） 异常的层次 checked Exception 如IoException要么用try catch捕获要么throw出去，在编码的时候会强提醒 unCheckException所有继承自error或者RuntimeException的类如nullPointException APP开发者和sdk开发者看代异常的角度。 因为sdk内部的异常中断了sdk内部的流程而不告诉app这显然是不可接受的，处理sdk内部的异常，原则就是不应该内部消化，而应该向外抛出，以同样的异常形式或者自定义返回码。 Exception or Error Code? 在sdk设计中既可以通过异常告知接入方，也可以通过返回码告知接入方，如何选择？ 场景： 1. sdk入参中需要app传入手机号，并校验参数合法性 2. sdk需要获取app包名/appid进行白名单校验 自定义异常是一种比较重的告知方式，意味着中断，返回码是一种比较轻的告知方式。 在与业务有关的逻辑且涉及用户（非app开发者）可以重试的部分，应该采用返回码，方便后续处理，比如用户输入了不符合手机号码规则的信息，可以通过我们的检查逻辑返回对应的返回码，集成sdk的开发者针对处理即可。 在与业务无关的逻辑且一旦发生用户无法处理的部分，可以采用抛出自定异常的方式，如sdk对app包名的校验，是一个面向开发者的校验逻辑，坦然让app崩溃，让开发者从错误堆栈中找问题,这就是uncheck exception的使用场景 开发者未遵循约定造成的无法重试的专有异常 初始化 初始化的本质是将APP的上下文注入到SDK，使其能通过上下文获取到app的资源和上下文 自定义Application（已经被废弃） 跟调用者自己定义的application冲突，接口反射什么的来处理，没必要 public class App extends Application { @SuppressLint(\"StaticFieldLeak\") private static Context sContext; @Override public void onCreate() { super.onCreate(); sContext = this; } public static Context getContext() { return sContext; } } 静态方法初始化（最常用） public class MySDK { private static Context sContext; private MySDK() { } public static void initSdk(Context context) { //获取ApplicationContext防止内存泄漏 sContext = context.getApplicationContext(); initSomething(); } public static Context getContext() { return sContext; } private static void initSomething() { //init something } } //调用方 public class App extends Application { @Override public void onCreate() { super.onCreate(); //初始化SDK MySDK.initSdk(this); } } \"无侵入\"contentProvider初始化方案 利用contentProvider获取了app的上下文 源码：App的启动过程中加载了provider，并且传了一个Application实例进去，最终在ContentProvider中调用了onCreate()方法。因此，在自定义的ContentProvider中，通过getContext()方法就可以获取到Application的实例了，ContentProvider中的onCreate()方法是先于Application中的onCreate()方法执行的（注意：此时Application对象已经创建）。关于App启动耗时的优化思路，是不是又多了一个关注点？ 1. 自定义用于初始化的provider public class MySDKInitProvider extends FileProvider{ @Override public boolean onCreate() { //初始化 MySDK.initSdk(getContext()); return super.onCreate(); } } 在SDK Module下的manifest中注册，编译时将会合并至主工程项目 <provider android:name=\".MySDKInitProvider\" android:authorities=\"${applicationId}.MySDKInitProvider\" android:exported=\"false\" android:grantUriPermissions=\"true\"> <meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/my_sdk_provider_paths\" /> </provider> 这里需要注意的是Provider的authorities千万别写死，否则两个引入同样SDK的App就无法共存了，这大概是SDK最不该犯的错误之一吧！ 初始化新姿势-App 谷歌新组件，Startup(alpha的阶段，就不太建议用于生产环境中) 个性化配置 使用流式比较优雅的实现sdk的个性化配置。 sdk配置的本质是为sdk相关功能提供默认配置，并且接收开发者的自定义配置 private void initsdk(){ LuisSDK.setdebug(true); LuisSDK.init(this); LuisSDK.setVoice(true); } 流式api的样例 MySDKConfig.getConfig().setDebug(true).setTimeout(8000L); public class LuisSDKConfig{ private static final LuisSDKConfig.Config CONFIG = new LuisSDKConfig.Congi(); public static class Config{ private Config(){ } public LuisSDKConfig.Config setDebug(final boolean isDebug) { sDebug = isDebug; return this; } } public static boolean isDebug() { return sDebug; } public static LuisSDKConfig.Config getConfig() { return CONFIG; } } //调用示例 LuisSDKConfig.getConfig().setdebug(true); SDK安全与校验 资源安全，如何保证sdk包的完整性 在编译的时候aar被合并到apk中，直接校验aar包的摘要不可行，但是可以通过校验aar包中的资源,raw,assets包中文件的摘要，这两个目录下的文件在编译的时候不会被压缩，摘要也不会变。 警惕资源覆盖造成的安全问题Android 会将Library模块中资源与Application模块中的资源进行合并，APP Moduler的资源将会覆盖Library Moduler中的同名资源。 在对文件或者资源进行命名的时候务必添加唯一性的前缀，或其他唯一性命名方案。 这一特性也为我们替换SDK资源，进行个性化改造提供了一种思路 3. 存储安全 * sp存储，采用xml文件格式来存储文件文件所在目录data/data/shared_prefs如果直接将账号密码或者个人敏感信息存储进去，手机root后可轻松获取，存储的时候简单做一层加密逻辑。 * so安全存储，不仅把密钥存储与so，还要把加解密逻辑或者传输逻辑放置于so。 4. 传输安全 安全环境监测 * vpn * root * 多开 * 模拟器环境 5. 混淆与配置 * 手动继承 * SDK内置 将sdk中混淆配置也打包进aar中 指定consumerProguardFiles属性，自定义引入混淆规则，该属性只针对Library有效，对app无效 as4.0新建library会会自动创建出两个***rules.pro文件，其中consumer-rules.pro，自动被defaultConfig下的consumerProguardFiles所引用； proguard-rules.pro，自动被buildType下的proguardFiles引用。 区别： default下的consumerProguardFiles配置的*.pro文件将会在library mopduler打包成aar,以proguard.txt的形式存在 SDK打包方法 library module下的build.gradle模板配置： //区别于application，这意味着该module将被视为library apply plugin: 'com.android.library' //自定义的一个方法，用来获取当前时间 static def releaseTime() { return new Date().format(\"yyyy-MM-dd\", TimeZone.getTimeZone(\"UTC\")) } android { compileSdkVersion 29 buildToolsVersion \"29.0.3\" defaultConfig { minSdkVersion 21 targetSdkVersion 29 versionCode 1 versionName \"1.0\" consumerProguardFiles \"proguard-rules.pro\"//配置自定义的混淆规则，该字段下的混淆规则将作用于集成该SDK的APP testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" ndk { abiFilters 'armeabi-v7a','arm64-v8a'//显式限定sdk支持的arm架构指令集 } } signingConfigs { release { storeFile file(\"../key/mylib.jks\")//相对路径下的签名文件 storePassword \"Android_2333\" keyAlias \"key-sdk\" keyPassword \"Android_2333\" } } buildTypes { release { minifyEnabled true shrinkResources false//sdk module编译时，不支持设置shrinkResources为true signingConfig signingConfigs.release proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//编译本module时参与混淆配置的文件 } debug { minifyEnabled false shrinkResources false //sdk module编译时，不支持设置shrinkResources为true signingConfig signingConfigs.release proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//编译本module时参与混淆配置的文件 } } //自动提取编译生成的aar文件，重命名，最后自动复制到appmodule下的libs目录，方便调试验证。 libraryVariants.all { variant -> if (variant.buildType.name == 'release') { variant.assembleProvider.get().doLast { variant.outputs.each { output -> def outputFile = output.outputFile if (outputFile != null && outputFile.name.endsWith('release.aar')) { // def fileName = \"${project.name}-release-${android.defaultConfig.versionName}-${releaseTime()}\" def outputPath = \"../mylib/build/aar\" def libPath = \"../app/libs\" copy { from outputFile into outputPath // rename { fileName + \".aar\" } } //直接复制到App的libs目录下，方便调试 copy { from outputFile into libPath } } } } } } } dependencies { //这句话代表集引入libs目录下的所有jar包 implementation fileTree(dir: \"libs\", include: [\"*.jar\"]) implementation 'com.android.support:support-v4:28.0.0' implementation 'com.android.support:appcompat-v7:28.0.0' } 如何打一个aar包： 双击gradle脚本assembleRelease，执行正式aar编译生成过程; 编译完成，可以看到outputs目录下自动生成了一个aar文件，同时我们的脚本也生效了，将其复制到了指定的目录下（这里可以做一下自动版本命名之类的工作） 依赖原则，尽量避免第三方库的依赖 如何解决组件依赖冲突： 强制使用指定版本","text_tokens":["下","两个","篡改","china","检测","解密","assets","开发者","500k","共存","gettimezone","使","binder","接收器","一些","谷歌","正式","概念","tag","1","千万别","细节","关注","唯一性","实体","broadcastreceiver","checked","返回","super","引起","$","本质","startup","传输数据","null","提醒","consumer","处理过程","bundle","一层","内置","新建","getdefaultproguardfile","因此","机制","into","jks","构造","android","entryactivity","module","app","过滤","get","minifyenabled","并","堆栈","filetree","其","gradle","abifilters","如","setmessage","选择","源码","不够","s","编译","v8a","环境监测","处理","animation","buildtoolsversion","传播","我们","resultcontent","实例","未","关闭","最","同时","目标","29","路径","作用","第三方","千万","集成","无效","接受","设计","第三","final","include","完整","默认","参在","为","话","private","校验","关注点","mm","指令","父类","保证","all","setflags","registerreceiver","staticfieldleak","新","配置","提供","sdebug","initsdk","moduler","shared","自定义","timezone","runner","原则","既","数据传输","轻松","包名","date","层次","目录","对入","来","string","serializable","throwable","广播","间通信","复杂","意味着","不可","<","逻辑","所","+","调试","进","result","setaction","localbroadcastmanager","符合","效率","等","horn","静态","直接","startactivityforresult","uncheckexception","setvoice","双击","手机号码","定义","无","无法","方式","不","封装","-","模拟器","/","功能","合并","模拟","进行","了","但","contentprovider","或","exception","背景","对","只","action","图片","示例","上下","：","sendresult","警惕","者","对外","动画","dependencies","！","伪造","被","代码","ndk","使用","getcontext","oncreate","调用者","launchsdk","废弃","appmodule","intentfilter","属性","出入","资源","activity","业务流程","初始化","打包","场景","容易","的","api","settimeout","强制","参数","流式","dir","releasetime","于","防止","设置","debug","后","暂时","和谐","超过","一般","出自","raw","必须","default","理过","坦然","这一","泄漏","no","产物","com","这句","keypassword",">","会强","如果","生效","文件格式","流程","pro","启动","内","静态方法","过程","libraryvariants","灵活","重","好","此时","异常","限定","buildtype","比较","指定","sp","签名文件","相对","找","v7a","复制","static","当作","一旦","provider","加密","(","req","versioncode","token","接收","boolean","实现","同名","更高","写","。","检查","重试","相对路径","init","appid","用者","apk","storepassword","rules","libpath","画面","包中","androidjunitrunner","支持","改造","意味","该","不该","内部","void","如何","有时","兼容问题","\"","错误","@","类","手机","可","format","arm64","proguardfiles","到","eventbus","addaction","复制到","assembleprovider","明确","getinstance","root","当前","library","最大","非正常","转场","放置","要么","把","优化","下文","copy","异常中断","否则","outputs","成","非空"," ","反","出","参中","犯","崩溃","exported","28.0","从","什么","已经","进去","遵循","结束","..","大小","_","[","作为","outputfile","方","yyyy","filter","一段","21","congi","段","唯一","so","中","包","敏感","minsdkversion","luissdkconfig","printer","sound","码是","让","applicationid","setdebug","个性化","信任","data","进程","manifest","用户","name","实体类","输入","项目","文件","其他","特性","四大","模块","手机号","而且","intent","=","密码",";","aar","8000l","return","后续","简单","环境","出去","override","加解密","code","利用","mysdkinitprovider","最终","signingconfig","序列","替换","比如","获取","0","集","呼应","方法","5","手段","即","stringdef","devicetype","做","不会","轻","setcode","中断","meta","涉及","编码","成功","针对","跟","添加","3","myreceiver","抛出","合法性","rename","mysdkconfig","应用","uncheck","账号密码","compilesdkversion","mylib","appcompat","输出",",","dd","摘要","authorities","时","码","且","!","有","mysdkhelper","本","new","简洁","上下文","putparcelable","paths","意义","scontext","生产","有关","granturipermissions","locale","阶段","最后","用来","）","2","getapplicationcontext","尽量避免","通信","public","budle","个人","getconfig","太","这","this","引用","屏蔽","常用","applicationcontext","；","采用","putextras","正常","生成","据","就","非","这里","fileprovider","该字","反馈","support","更","样例","大概",")","侵入","testinstrumentationrunner","捕获","方案","机号码","会会","or","getresult","格式","可靠性","try","序列化","合法","内存","file","模板","utc","经过","专有","各类","部分","务必","output","用","variant","交互","繁琐","传输","约定","越小越","false","就是","也","视为","混淆","行为","多开","发送","不能","破解","application","'","，","mysdk","一个",".","%","前","true","]","gettoken","完成","显然","存储","变","不仅","用于","必要","勿","职责","则","有效","shrinkresources","有时候","error","兼容","类型","implementation","判断","可靠","失败","造成","提取","as4.0","plugin","优雅","架构","将","对象","isdebug","int","（","区别","自己","def","指令集","接口","没","统一","map","需要","工程","ondestroy","打","覆盖","可以","其中","自","库","耗时","和","catch","多","入","传入","看到","注册","&&","回调","alpha","避免","luissdk","同样","project","interface","面向","规则","合集","相关","弃","class","引入","endswith","定","消化","白名单","defaultconfig","完整性","代表","异步","并且","其能","log","流程图","是不是","中反","给","即可","调用","libs","压缩","参","响应","方便","hook","所有","反射","filename","验证","工程项目","版本","发送数据","抛","context","跳转","一种","三方","参与","extends","增","29.0","数据","注意","命名","接收数据","proguard","arm","4","安全","依赖","*","通过","先于","吧","getcode","时候","告知","加载","apply","parcelabel","开发","armeabi","解决","通用","startactivity","是","形式","jar","重命名","自定","request","message","显式","key","执行","throw","无关","if","v7","要","会","getdevice","信息","角度","告诉","组件","建议","txt","{","flag","settoken","死","keyalias","但是","手动","名单","1.0","initsomething","密钥","？","据传","xml","及时","test","nullpointexception","之一","getmessage","还要","前端","reqcontent","signingconfigs",":","runtimeexception","sdk","应该","入口","而","随时","2333","发货","传","创建","数据格式","工作","号码","支付","dolast","看代","以","}","数据类型","ioexception","前缀","each","间","又","build","思路","consumerproguardfiles","v4","因为","冲突","与","限制","业务","关于","至主","config","继承","prefs","versionname","随时随地","mopduler","onreceive","初始","账号","?","注解","suppresslint","问题","随地","sendbroadcast","损失","置于","release","注入","监测","向外","storefile","姿势","理论","或者","可行","自动","脚本","receiver","vpn","buildtypes","没有","所在","而生","签名","之类","targetsdkversion","绝对","outputpath","d","在","暴露","时间","尽量","不是","发生","放弃","存在","一下","个性","接入","something","将会","my","from","assemblerelease","对应","resource","unregisterreceiver"],"title":"sdk开发笔记","title_tokens":["笔记","sdk","开发"]},{"location":"sdk/#_1","text":"jar so aar 一些方法和逻辑合集，对资源api封装后的产物。","text_tokens":["后","和","合集","api","的","jar","对","。","一些","资源","封装","方法","，","产物"," ","逻辑","aar","so"],"title":"定义","title_tokens":["定义"]},{"location":"sdk/#_2","text":"如无必要勿增实体，如无必要勿增依赖 1. sdk接收什么？输出什么？明确职责","text_tokens":["1","增","无","如","输出","明确","实体","必要","勿",".","什么","接收","职责","sdk","，","？"," ","依赖"],"title":"接口设计","title_tokens":["接口","设计"]},{"location":"sdk/#_3","text":"map String 实体类 1. 自定义实体类作为出入参在activity间传输，无法直接传播实体，需要经过序列化。 * 实现serializable接口通过bundle传输 * 实现parcelabel接口，通过budle传输 2. intent中的bundle是通过Binder机制进行数据传输，有大小限制，建议最大不超过500k越小越好，避免传输图片","text_tokens":["定义","序列","数据","出入","无法","不","序列化","activity","据传","有","好","500k","经过","自定义","*","通过","中","2","的","进行","budle","数据传输","binder","parcelabel","最大","传输","越小越","接口","大小","实体类","是","传播","1","map","自定","需要","string","超过","serializable","实体","图片","intent","间","，","实现","."," ","。","限制","bundle","机制","参在","建议","直接","避免","作为"],"title":"出入参设计","title_tokens":["参","出入","设计"]},{"location":"sdk/#_4","text":"如果app需要通过sdk的入口activity进行调用与业务开发，如何做一个优雅的调用封装。 封装前的调用： //繁琐的调用代码 Bundle bundle = new Bundle(); //这里要暴露或者约定一个静态KEY bundle.putParcelable(KEY_REQ, request); Intent intent = new Intent(context, EntryActivity.class); //屏蔽转场动画，让画面跳转更和谐 intent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION); intent.putExtras(bundle); context.startActivity(intent); 封装后的调用： //简洁的调用代码 MySDK.launchSdk(context,req); //将复杂逻辑或细节内置于SDK中，对外提供封装好的静态方法即可 public static void launchSdk(Context context, ReqContent request) { Bundle bundle = new Bundle(); bundle.putParcelable(KEY_REQ, request); Intent intent = new Intent(context, EntryActivity.class); //屏蔽转场动画，让画面跳转更和谐 intent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION); intent.putExtras(bundle); context.startActivity(intent); }","text_tokens":["launchsdk","class","activity","方法","做","的","后","即可","和谐","调用","细节","no",",","context","跳转","bundle","如果","内","静态方法","entryactivity","new","简洁","app","putparcelable","好","通过","public","开发","屏蔽","startactivity","animation","static","request","putextras","(","req","这里","key","。","要","更",")","画面","{","flag","void","如何","setflags","提供","reqcontent","繁琐","约定","sdk","转场","入口","}","复杂","，","mysdk","一个"," ",".","前","逻辑","与","业务","静态","_","置于","封装","中","/","优雅","进行","或者","将","让","或","需要","intent","=","：",";","暴露","对外","动画","代码"],"title":"调用封装设计","title_tokens":["封装","调用","设计"]},{"location":"sdk/#_5","text":"调用即响应，不可无响应无回调 背景： 1. 需要在app与sdk的activity间进行数据传输 2. 调用sdk后，需要执行一段异步逻辑，结束后需要及时关闭 3. 需要在逻辑代码处理过程中随时随地的构造返回参数并返回。 4. sdk目标用户，各类第三方app，需要通用的交互机制，避免引起兼容问题。 方案： startActivityForResult()?理论可行，但不够灵活，弃。 采用EventBus ? 避免引入非必须第三方依赖，暂时放弃。 采用BroadcastReceiver？Android 内置的四大组件之一，为组件间交互而生。而且灵活方便，与入参方法呼应，可以从Intent中传输数据。 采用应用内广播，无进程间通信，效率更高，更安全","text_tokens":["弃","引入","activity","方法","呼应","即","的","异步","参数","1","后","暂时","调用","必须","broadcastreceiver","3","理过","返回","参","响应","方便","引起","应用","传输数据","处理过程","三方","内置","机制","构造","android","内","过程","数据","灵活","app","并","4","安全","依赖","2","通信","不够","通用","处理","采用","(","非","执行","关闭","更高","目标","。","第三方","更",")","第三","组件","为","方案","兼容问题","据传","？","及时","eventbus","各类","之一","数据传输","交互","传输","sdk","随时","广播","间通信","不可","间","，","."," ","逻辑","与","从","随时随地","效率","结束","?","startactivityforresult","问题","兼容","随地","无","一段","中","进行","理论","可行","但","进程","用户","背景","需要","而生","四大","而且","可以","intent","：","在","放弃","入","代码","回调","避免"],"title":"数据返回设计","title_tokens":["数据","返回","设计"]},{"location":"sdk/#_6","text":"//SDK内部封装的静态方法，提供给SDK内部模块统一调用 public static void sendResult(String token, int code, String message) { ResultContent result = new ResultContent(); result.setToken(token); result.setCode(code); result.setMessage(message); Bundle bundle = new Bundle(); bundle.putParcelable(KEY_RESULT, result); Intent intent = new Intent(); intent.setAction(MY_SDK_RECEIVER_ACTION); intent.putExtras(bundle); LocalBroadcastManager.getInstance(MySDK.getContext()).sendBroadcast(intent); }","text_tokens":["code","静态方法","内部","new","void","settoken","putparcelable","封装","方法","提供","/","的","setcode","public","setmessage","getinstance","int","receiver","sdk","static","给","统一","putextras","string","调用","模块","(","message","resultcontent","}","key","action","intent","token","=","，","mysdk","sendresult",";"," ",".",",","bundle",")","getcontext","result","setaction","my","localbroadcastmanager","{","静态","_","sendbroadcast"],"title":"发送数据","title_tokens":["数据","发送数据","发送"]},{"location":"sdk/#_7","text":"//SDK内部封装的注册方法，提供给APP模块统一调用 public static void registerReceiver(BroadcastReceiver receiver) { IntentFilter filter = new IntentFilter(); filter.addAction(MY_SDK_RECEIVER_ACTION); LocalBroadcastManager.getInstance(getContext()).registerReceiver(receiver, filter); } //SDK内部封装的反注册方法，提供给APP模块统一调用，如果在onCreate()方法中注册，则在onDestroy()方法中反注册。 public static void unregisterReceiver(BroadcastReceiver receiver) { LocalBroadcastManager.getInstance(getContext()).unregisterReceiver(receiver); } //APP 中定义的广播接收器，用于接收返回参数 public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { ResultContent result = MySDKHelper.getResult(intent); if (result == null) { return; } int code = result.getCode(); String message = result.getMessage(); String token = result.getToken(); String log = String.format(Locale.CHINA,\"返回码: %d 返回信息: %s Token: %s\", code, message, token); Log.d(TAG, log); } }","text_tokens":["code","intentfilter","china","class","方法","的","接收器","log","参数","tag","中反","给","调用","broadcastreceiver","myreceiver","返回","null",",","context","extends","如果","码","mysdkhelper","new","app","locale","getcode","public","s","static","(","resultcontent","message","token","接收","。","if","信息",")","{","内部","getresult","void","\"","@","registerreceiver","format","提供","addaction","getmessage","getinstance",":","sdk","string","}","广播","，"," ",".","反","%","gettoken","用于","localbroadcastmanager","result","则","onreceive","_","定义","filter","oncreate","封装","中","/","int","receiver","统一","模块","ondestroy","action","intent","=","d",";","在","return","my","注册","getcontext","override","unregisterreceiver"],"title":"接收数据","title_tokens":["数据","接收","接收数据"]},{"location":"sdk/#_8","text":"对入参数据进行过滤，避免无意义的后续业务流程，及时提供调用反馈。 非空检测，数据类型检测，数据格式检测，自定义注解。 public static final String PRINTER = \"PRINTER\"; public static final String HORN = \"HORN\"; public static final String SOUND = \"SOUND\"; @StringDef({PRINTER, HORN, SOUND}) public @interface DeviceType{} public void getDevice( @DeviceType String deviceType){ }","text_tokens":["interface","类型","定义","无","格式","数据","检测","void","过滤","\"","@","意义","业务流程","提供","及时","stringdef","devicetype","自定义","进行","的","public","printer","sound","参数","static","数据格式","对入","自定","string","调用","(","}","据","数据类型","=","避免","，","非空","反馈"," ",";","。","业务","getdevice","后续",",",")","final","horn","{","注解","流程"],"title":"参数过滤设计","title_tokens":["参数","过滤","设计"]},{"location":"sdk/#_9","text":"前端没有绝对的安全 错误的返回 错误的返回并不会对业务造成损失，比如支付失败，直接当作失败处理即可。 成功的返回 成功的返回有时候会造成损失，比如支付后发货行为，因此必须要判断返回的可靠性。 前端代码，容易被破解者通过hook等非正常手段伪造或者篡改，不能信任前端返回码。 一般支付的交互流程图","text_tokens":["篡改","比如","有时","错误","判断","可靠","失败","可靠性","并","造成","手段","安全","不会","通过","容易","的","时候","前端","或者","交互","非正常","信任","流程图","成功","处理","没有","当作","发货","后","行为","支付","即可","正常","一般","对","绝对","必须","破解","不能","返回","，","hook"," ","者","。","会","业务","要","因此","伪造","被","代码","等","码","流程","直接","有时候","损失"],"title":"交互流程设计","title_tokens":["设计","流程","交互"]},{"location":"sdk/#_10","text":"异常概念（throwable为exception和error父类） 异常的层次 checked Exception 如IoException要么用try catch捕获要么throw出去，在编码的时候会强提醒 unCheckException所有继承自error或者RuntimeException的类如nullPointException APP开发者和sdk开发者看代异常的角度。 因为sdk内部的异常中断了sdk内部的流程而不告诉app这显然是不可接受的，处理sdk内部的异常，原则就是不应该内部消化，而应该向外抛出，以同样的异常形式或者自定义返回码。 Exception or Error Code? 在sdk设计中既可以通过异常告知接入方，也可以通过返回码告知接入方，如何选择？ 场景： 1. sdk入参中需要app传入手机号，并校验参数合法性 2. sdk需要获取app包名/appid进行白名单校验 自定义异常是一种比较重的告知方式，意味着中断，返回码是一种比较轻的告知方式。 在与业务有关的逻辑且涉及用户（非app开发者）可以重试的部分，应该采用返回码，方便后续处理，比如用户输入了不符合手机号码规则的信息，可以通过我们的检查逻辑返回对应的返回码，集成sdk的开发者针对处理即可。 在与业务无关的逻辑且一旦发生用户无法处理的部分，可以采用抛出自定异常的方式，如sdk对app包名的校验，是一个面向开发者的校验逻辑，坦然让app崩溃，让开发者从错误堆栈中找问题,这就是uncheck exception的使用场景 开发者未遵循约定造成的无法重试的专有异常","text_tokens":["code","规则","面向","获取","比如","定","消化","开发者","白名单","场景","轻","的","中断","涉及","编码","参数","概念","针对","1","即可","出自","checked","坦然","抛出","返回","方便","合法性","所有","uncheck","提醒","抛",",","一种","会强","码","且","流程","app","重","并","有关","堆栈","异常","）","通过","2","时候","告知","比较","如","选择","开发","这","找","是","处理","形式","采用","我们","一旦","自定","非","未","throw","无关","。","检查","重试","appid","信息","集成","接受","对应","设计","角度","告诉","为","捕获","机号码","校验","意味","父类","or","内部","名单","类","如何","错误","合法","try","手机","？","专有","自定义","nullpointexception","原则","既","部分","用","包名","runtimeexception","sdk","应该","约定","而","就是","也","层次","要么","号码","看代","以","throwable","ioexception","意味着","异常中断","不可","，","一个"," ",".","逻辑","因为","与","业务","显然","参中","继承","崩溃","从","符合","遵循","?","error","uncheckexception","问题","方","手机号码","定义","无法","方式","不","向外","造成","中","/","进行","或者","了","码是","让","（","用户","exception","输入","需要","手机号","对","可以","自","：","在","和","catch","发生","后续","入","接入","传入","使用","出去","同样"],"title":"异常处理","title_tokens":["异常","处理"]},{"location":"sdk/#_11","text":"初始化的本质是将APP的上下文注入到SDK，使其能通过上下文获取到app的资源和上下文 自定义Application（已经被废弃） 跟调用者自己定义的application冲突，接口反射什么的来处理，没必要 public class App extends Application { @SuppressLint(\"StaticFieldLeak\") private static Context sContext; @Override public void onCreate() { super.onCreate(); sContext = this; } public static Context getContext() { return sContext; } } 静态方法初始化（最常用） public class MySDK { private static Context sContext; private MySDK() { } public static void initSdk(Context context) { //获取ApplicationContext防止内存泄漏 sContext = context.getApplicationContext(); initSomething(); } public static Context getContext() { return sContext; } private static void initSomething() { //init something } } //调用方 public class App extends Application { @Override public void onCreate() { super.onCreate(); //初始化SDK MySDK.initSdk(this); } } \"无侵入\"contentProvider初始化方案 利用contentProvider获取了app的上下文 源码：App的启动过程中加载了provider，并且传了一个Application实例进去，最终在ContentProvider中调用了onCreate()方法。因此，在自定义的ContentProvider中，通过getContext()方法就可以获取到Application的实例了，ContentProvider中的onCreate()方法是先于Application中的onCreate()方法执行的（注意：此时Application对象已经创建）。关于App启动耗时的优化思路，是不是又多了一个关注点？ 1. 自定义用于初始化的provider public class MySDKInitProvider extends FileProvider{ @Override public boolean onCreate() { //初始化 MySDK.initSdk(getContext()); return super.onCreate(); } } 在SDK Module下的manifest中注册，编译时将会合并至主工程项目 <provider android:name=\".MySDKInitProvider\" android:authorities=\"${applicationId}.MySDKInitProvider\" android:exported=\"false\" android:grantUriPermissions=\"true\"> <meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/my_sdk_provider_paths\" /> </provider> 这里需要注意的是Provider的authorities千万别写死，否则两个引入同样SDK的App就无法共存了，这大概是SDK最不该犯的错误之一吧！ 初始化新姿势-App 谷歌新组件，Startup(alpha的阶段，就不太建议用于生产环境中)","text_tokens":["利用","mysdkinitprovider","最终","下","废弃","两个","获取","class","引入","资源","方法","初始化","共存","使","的","meta","并且","其能","谷歌","是不是","防止","跟","1","千万别","调用","关注","泄漏","super","反射","$","本质","工程项目","startup",">","context","extends","authorities","时","因此","启动","android","静态方法","过程","module","上下文","app","注意","paths","生产","scontext","granturipermissions","此时","阶段","通过","）","先于","吧","getapplicationcontext","public","加载","太","这","this","源码","编译","常用","applicationcontext","是","处理","static","自定","provider","(","实例","就","fileprovider","执行","这里","最","boolean","support","写","。","会","init","千万","用者","大概",")","侵入","组件","建议","{","死","private","方案","关注点","不该","void","错误","\"","@","initsomething","内存","staticfieldleak","？","file","xml","新","到","initsdk","自定义","之一",":","sdk","false","传","创建","来","优化","}","下文","否则","application","又","，","mysdk","一个","思路"," ",".","<","true","冲突","关于","至主","用于","犯","必要","exported","已经","什么","进去","初始","静态","_","suppresslint","方","定义","无","注入","oncreate","无法","不","-","中","姿势","/","合并","将","对象","了","applicationid","（","data","自己","manifest","contentprovider","接口","name","没","项目","需要","工程","可以","=","上下","：",";","耗时","同样","在","和","不是","多","return","！","something","被","my","注册","环境","alpha","getcontext","override","resource","调用者"],"title":"初始化","title_tokens":["初始化","初始"]},{"location":"sdk/#_12","text":"使用流式比较优雅的实现sdk的个性化配置。 sdk配置的本质是为sdk相关功能提供默认配置，并且接收开发者的自定义配置 private void initsdk(){ LuisSDK.setdebug(true); LuisSDK.init(this); LuisSDK.setVoice(true); } 流式api的样例 MySDKConfig.getConfig().setDebug(true).setTimeout(8000L); public class LuisSDKConfig{ private static final LuisSDKConfig.Config CONFIG = new LuisSDKConfig.Congi(); public static class Config{ private Config(){ } public LuisSDKConfig.Config setDebug(final boolean isDebug) { sDebug = isDebug; return this; } } public static boolean isDebug() { return sDebug; } public static LuisSDKConfig.Config getConfig() { return CONFIG; } } //调用示例 LuisSDKConfig.getConfig().setdebug(true);","text_tokens":["相关","定义","new","void","{","class","congi","sdebug","提供","配置","开发者","initsdk","自定义","/","优雅","功能","的","比较","api","settimeout","public","luissdkconfig","isdebug","并且","getconfig","开发","setdebug","流式","个性化","this","sdk","是","static","自定","(","调用","}","示例","=","接收","boolean","实现","，",";"," ",".","本质","。","true","mysdkconfig","8000l","init","config","样例","return","setvoice","个性",")","final","默认","使用","为","private","luissdk"],"title":"个性化配置","title_tokens":["个性化","个性","配置"]},{"location":"sdk/#sdk","text":"资源安全，如何保证sdk包的完整性 在编译的时候aar被合并到apk中，直接校验aar包的摘要不可行，但是可以通过校验aar包中的资源,raw,assets包中文件的摘要，这两个目录下的文件在编译的时候不会被压缩，摘要也不会变。 警惕资源覆盖造成的安全问题Android 会将Library模块中资源与Application模块中的资源进行合并，APP Moduler的资源将会覆盖Library Moduler中的同名资源。 在对文件或者资源进行命名的时候务必添加唯一性的前缀，或其他唯一性命名方案。 这一特性也为我们替换SDK资源，进行个性化改造提供了一种思路 3. 存储安全 * sp存储，采用xml文件格式来存储文件文件所在目录data/data/shared_prefs如果直接将账号密码或者个人敏感信息存储进去，手机root后可轻松获取，存储的时候简单做一层加密逻辑。 * so安全存储，不仅把密钥存储与so，还要把加解密逻辑或者传输逻辑放置于so。 4. 传输安全 安全环境监测 * vpn * root * 多开 * 模拟器环境 5. 混淆与配置 * 手动继承 * SDK内置 将sdk中混淆配置也打包进aar中 指定consumerProguardFiles属性，自定义引入混淆规则，该属性只针对Library有效，对app无效 as4.0新建library会会自动创建出两个***rules.pro文件，其中consumer-rules.pro，自动被defaultConfig下的consumerProguardFiles所引用； proguard-rules.pro，自动被buildType下的proguardFiles引用。 区别： default下的consumerProguardFiles配置的*.pro文件将会在library mopduler打包成aar,以proguard.txt的形式存在","text_tokens":["规则","下","两个","替换","获取","属性","引入","解密","资源","assets","5","打包","不会","做","defaultconfig","完整性","的","于","添加","针对","后","raw","压缩","唯一性","default","3","这一","账号密码","consumer",",","一种","摘要","一层","如果","内置","文件格式","新建","pro","android","app","命名","proguard","4","安全","通过","*","buildtype","时候","个人","指定","sp","这","编译","引用","环境监测","；","采用","形式","我们","自定","加密","同名","。","会","apk","信息","无效","rules","完整","txt","为","包中","方案","校验","但是","改造","会会","该","保证","格式","手动","如何","可","手机","密钥","shared","xml","提供","配置","proguardfiles","到","moduler","自定义","还要","务必","root","轻松","library","传输","sdk","放置","也","目录","创建","混淆","来","多开","把","以","前缀","application","成","，","思路","consumerproguardfiles"," ",".","逻辑","出","与","prefs","存储","所","变","不仅","继承","进","有效","进去","mopduler","账号","直接","_","问题","定义","监测","不","-","唯一","造成","模拟器","so","as4.0","中","/","包","敏感","合并","模拟","可行","进行","或者","将","自动","了","区别","个性化","data","或","vpn","其他","文件","所在","特性","模块","对","只","覆盖","可以","其中","密码","警惕","：","aar","在","存在","个性","将会","被","简单","环境","加解密"],"title":"SDK安全与校验","title_tokens":["安全","校验","sdk","与"]},{"location":"sdk/#sdk_1","text":"","text_tokens":[],"title":"SDK打包方法","title_tokens":["方法","打包","sdk"]},{"location":"sdk/#library-modulebuildgradle","text":"//区别于application，这意味着该module将被视为library apply plugin: 'com.android.library' //自定义的一个方法，用来获取当前时间 static def releaseTime() { return new Date().format(\"yyyy-MM-dd\", TimeZone.getTimeZone(\"UTC\")) } android { compileSdkVersion 29 buildToolsVersion \"29.0.3\" defaultConfig { minSdkVersion 21 targetSdkVersion 29 versionCode 1 versionName \"1.0\" consumerProguardFiles \"proguard-rules.pro\"//配置自定义的混淆规则，该字段下的混淆规则将作用于集成该SDK的APP testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" ndk { abiFilters 'armeabi-v7a','arm64-v8a'//显式限定sdk支持的arm架构指令集 } } signingConfigs { release { storeFile file(\"../key/mylib.jks\")//相对路径下的签名文件 storePassword \"Android_2333\" keyAlias \"key-sdk\" keyPassword \"Android_2333\" } } buildTypes { release { minifyEnabled true shrinkResources false//sdk module编译时，不支持设置shrinkResources为true signingConfig signingConfigs.release proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//编译本module时参与混淆配置的文件 } debug { minifyEnabled false shrinkResources false //sdk module编译时，不支持设置shrinkResources为true signingConfig signingConfigs.release proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//编译本module时参与混淆配置的文件 } } //自动提取编译生成的aar文件，重命名，最后自动复制到appmodule下的libs目录，方便调试验证。 libraryVariants.all { variant -> if (variant.buildType.name == 'release') { variant.assembleProvider.get().doLast { variant.outputs.each { output -> def outputFile = output.outputFile if (outputFile != null && outputFile.name.endsWith('release.aar')) { // def fileName = \"${project.name}-release-${android.defaultConfig.versionName}-${releaseTime()}\" def outputPath = \"../mylib/build/aar\" def libPath = \"../app/libs\" copy { from outputFile into outputPath // rename { fileName + \".aar\" } } //直接复制到App的libs目录下，方便调试 copy { from outputFile into libPath } } } } } } } dependencies { //这句话代表集引入libs目录下的所有jar包 implementation fileTree(dir: \"libs\", include: [\"*.jar\"]) implementation 'com.android.support:support-v4:28.0.0' implementation 'com.android.support:appcompat-v7:28.0.0' } 如何打一个aar包： 双击gradle脚本assembleRelease，执行正式aar编译生成过程; 编译完成，可以看到outputs目录下自动生成了一个aar文件，同时我们的脚本也生效了，将其复制到了指定的目录下（这里可以做一下自动版本命名之类的工作）","text_tokens":["规则","下","signingconfig","appmodule","获取","0","集","引入","endswith","方法","gettimezone","做","defaultconfig","代表","的","正式","dir","releasetime","于","设置","debug","1","libs","3","方便","com","filename","rename","$","验证","这句","所有","版本","keypassword","compilesdkversion","mylib",">","dd",",","null","参与","appcompat","生效","时","getdefaultproguardfile","!","pro","into","jks","android","本","29.0","过程","new","module","libraryvariants","app","命名","get","proguard","minifyenabled","arm","最后","filetree","用来","*","其","gradle","）","限定","abifilters","buildtype","apply","指定","这","签名文件","编译","相对","v7a","v8a","复制","重命名","static","buildtoolsversion","jar","我们","自定","(","生成","显式","该字","key","versioncode","执行","这里","同时","support","。","29","路径","作用","if","相对路径","v7","集成","storepassword",")","include","rules","txt","testinstrumentationrunner","为","{","libpath","话","androidjunitrunner","keyalias","mm","指令","意味","该","all","1.0","如何","\"","arm64","format","timezone","配置","armeabi","file","proguardfiles","utc","复制到","自定义","test","runner","assembleprovider","output","signingconfigs","variant","当前","library",":","2333","sdk","false","视为","date","也","工作","目录","混淆","dolast","}","each","copy","意味着","outputs","application","'","，","一个","consumerproguardfiles"," ",".","build","true","]","v4","完成","versionname","+","调试","28.0","..","shrinkresources","_","直接","[","双击","outputfile","定义","release","yyyy","implementation","21","不","-","段","storefile","提取","plugin","/","架构","包","minsdkversion","将","自动","了","区别","（","脚本","def","指令集","name","buildtypes","文件","签名","之类","targetsdkversion","outputpath","打","可以","=","：",";","aar","时间","dependencies","return","一下","被","ndk","看到","from","&&","assemblerelease","project","支持"],"title":"library module下的build.gradle模板配置：","title_tokens":["下","的","：","module",".","library","模板","配置","build"," ","gradle"]},{"location":"sdk/#_13","text":"","text_tokens":[],"title":"依赖原则，尽量避免第三方库的依赖","title_tokens":["原则","尽量","第三方","尽量避免","的","三方","第三","，","库","避免","依赖"]},{"location":"sdk/#_14","text":"强制使用指定版本","text_tokens":["版本","指定","使用","强制"],"title":"如何解决组件依赖冲突：","title_tokens":["冲突","如何","组件","解决","：","依赖"]},{"location":"sdkversion/","text":"Android各版本对应sdk版本 平台版本 SDK版本 版本名称 Android 10 29 Android Q Android 9.0 28 Pie (Android P) Android 8.1 27 Oreo(Android O)（奥利奥） Android 8.0 26 Oreo Android 7.1 25 Nougat Android 7.0 24 Nougat Android 6.0 23 Marshmallow Android 5.1 22 Lollipop Android 5.0 21 Lollipop Android 4.4 19 KITKAT Android 4.3 18 JELLY_BEAN_MR2 Android 4.2, 4.2.2 17 JELLY_BEAN_MR1 Android 4.1, 4.1.1 16 JELLY_BEAN Android 4.0.3, 4.0.4 15 ICE_CREAM_SANDWICH_MR1 Android 4.0, 4.0.1, 4.0.2 14 ICE_CREAM_SANDWICH Android 3.2 13 HONEYCOMB_MR2 Android 3.1.x 12 HONEYCOMB_MR1 Android 3.0.x 11 HONEYCOMB Android 2.3.4 10 GINGERBREAD_MR1 Android 2.3.3 10 GINGERBREAD_MR1 Android 2.3.2 9 GINGERBREAD Android 2.3.1 9 GINGERBREAD Android 2.3 9 GINGERBREAD Android 2.2.x 8 FROYO Android 2.1.x 7 ECLAIR_MR1 Android 2.0.1 6 ECLAIR_0_1 Android 2.0 5 ECLAIR Android 1.6 4 DONUT Android 1.5 3 CUPCAKE Android 1.1 2 BASE_1_1 Android 1.0 1 BASE","text_tokens":["ice","oreo","0","q","5","9","14","22","1","奥利","3","4.4","16","3.2","2.0","4.2","3.1","版本","26",",","x","10","cream","28","lollipop","android","pie","平台","4","4.1","）","2","sandwich","nougat","25","9.0","donut","jelly","(","mr1","7","marshmallow","29","8.0","17","1.6",")","4.0","24","1.0","cupcake","6.0","4.3","p","奥","o","sdk","1.5","27","kitkat","名称","6","2.2","2.3"," ","19",".","_","11","bean","base","各","8","21","5.0","mr2","gingerbread","23","3.0","2.1","（","eclair","7.1","13","froyo","7.0","1.1","8.1","honeycomb","18","15","12","5.1","对应"],"title":"Android版本对应SDK版本","title_tokens":["android","版本","对应","sdk"]},{"location":"sdkversion/#androidsdk","text":"平台版本 SDK版本 版本名称 Android 10 29 Android Q Android 9.0 28 Pie (Android P) Android 8.1 27 Oreo(Android O)（奥利奥） Android 8.0 26 Oreo Android 7.1 25 Nougat Android 7.0 24 Nougat Android 6.0 23 Marshmallow Android 5.1 22 Lollipop Android 5.0 21 Lollipop Android 4.4 19 KITKAT Android 4.3 18 JELLY_BEAN_MR2 Android 4.2, 4.2.2 17 JELLY_BEAN_MR1 Android 4.1, 4.1.1 16 JELLY_BEAN Android 4.0.3, 4.0.4 15 ICE_CREAM_SANDWICH_MR1 Android 4.0, 4.0.1, 4.0.2 14 ICE_CREAM_SANDWICH Android 3.2 13 HONEYCOMB_MR2 Android 3.1.x 12 HONEYCOMB_MR1 Android 3.0.x 11 HONEYCOMB Android 2.3.4 10 GINGERBREAD_MR1 Android 2.3.3 10 GINGERBREAD_MR1 Android 2.3.2 9 GINGERBREAD Android 2.3.1 9 GINGERBREAD Android 2.3 9 GINGERBREAD Android 2.2.x 8 FROYO Android 2.1.x 7 ECLAIR_MR1 Android 2.0.1 6 ECLAIR_0_1 Android 2.0 5 ECLAIR Android 1.6 4 DONUT Android 1.5 3 CUPCAKE Android 1.1 2 BASE_1_1 Android 1.0 1 BASE","text_tokens":["ice","oreo","0","q","5","9","14","22","1","奥利","3","4.4","16","3.2","2.0","4.2","3.1","版本","26",",","x","10","cream","28","lollipop","android","pie","平台","4","4.1","）","2","sandwich","nougat","25","9.0","donut","jelly","(","mr1","7","marshmallow","29","8.0","17","1.6",")","4.0","24","1.0","cupcake","6.0","4.3","p","奥","o","sdk","1.5","kitkat","名称","6","2.2","2.3"," ","19",".","_","11","bean","base","8","21","5.0","mr2","gingerbread","23","3.0","2.1","（","eclair","7.1","13","froyo","7.0","1.1","8.1","honeycomb","18","15","12","5.1","27"],"title":"Android各版本对应sdk版本","title_tokens":["android","各","sdk","版本","对应"]},{"location":"threadPool/","text":"含义 装线程的池子，目的是管理线程，避免大量创建线程，增加开销，影响响应速度。 //五个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) //六个参数的构造函数-1 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) //六个参数的构造函数-2 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) //七个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize -> 该线程池中核心线程数最大值 核心线程：在创建完线程池之后，核心线程先不创建，在接到任务之后创建核心线程。并且会一直存在于线程池中（即使这个线程啥都不干），有任务要执行时，如果核心线程没有被占用，会优先用核心线程执行任务。数量一般情况下设置为CPU核数的二倍即可。 maximumPoolSize -> 该线程池中线程总数最大值 线程总数=核心线程数+非核心线程数。 非核心线程：简单理解，即核心线程都被占用，但还有任务要做，就创建非核心线程。 keepAliveTime -> 非核心线程闲置超时时长 这个参数可以理解为，任务少，但池中线程多，非核心线程不能白养着，超过这个时间不工作的就会被干掉，但是核心线程会保留。 TimeUnit -> keepAliveTime的单位 这个参数是个枚举类型 * DAYS * HOURS * MINUTES * SECONDS * MILLISECONDS * MICROSECONDS * NANOSECONDS微毫秒 BlockingQueue workQueue -> 线程池中的任务队列 默认情况下，任务进来之后先分配给核心线程执行，核心线程如果都被占用，并不会立刻开启非核心线程执行任务，而是将任务插入任务队列等待执行，核心线程会从任务队列取任务来执行，任务队列可以设置最大值，一旦插入的任务足够多，达到最大值，才会创建非核心线程执行任务。 常见的workQueue有四种： SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现<线程数达到了maximumPoolSize而不能新建线程>的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大。 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前已经创建的核心线程数小于线程池的核心线程数上限，则新建线程(核心线程)处理任务；如果当前已经创建的核心线程数等于核心线程数上限，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误，或是执行实现定义好的饱和策略。 DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。 ThreadFactory threadFactory -> 创建线程的工厂 可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。 RejectedExecutionHandler handler -> 饱和策略 这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy， 表示无法处理新任务，并抛出 RejectedExecutionException 异常。此外还有3种策略，它们分别如下。 CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 DiscardPolicy：不能执行的任务，并将该任务删除。 DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。 如何使用线程池 以上是原理，线面说用法，java给我们提供了四种线程池 FixedThreadPool * CachedThreadPool * SingleThreadExecutor * ScheduledThreadPool FixedThreadPool 可重用固定线程数的线程池，超出的线程会在队列中等待，在Executors类中我们可以找到创建方式 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } FixedThreadPool的corePoolSize和maximumPoolSize都设置为参数nThreads，也就是只有固定数量的核心线程，不存在非核心线程。keepAliveTime为0L表示多余的线程立刻终止，因为不会产生多余的线程，所以这个参数是无效的。FixedThreadPool的任务队列采用的是LinkedBlockingQueue。 创建线程池的方法，在我们的程序中只需要，后面其他种类的同理： public static void main(String[] args) { // 参数是要线程池的线程最大值 ExecutorService executorService = Executors.newFixedThreadPool(10); } CachedThreadPool CachedThreadPool是一个根据需要创建线程的线程池。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } CachedThreadPool的corePoolSize是0，maximumPoolSize是Int的最大值，也就是说CachedThreadPool没有核心线程，全部都是非核心线程，并且没有上限。keepAliveTime是60秒，就是说空闲线程等待新任务60秒，超时则销毁。此处用到的队列是阻塞队列SynchronousQueue,这个队列没有缓冲区，所以其中最多只能存在一个元素,有新的任务则阻塞等待。 SingleThreadExecutor SingleThreadExecutor是使用单个线程工作的线程池。其创建源码如下 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } 我们可以看到总线程数和核心线程数都是1，所以就只有一个核心线程。该线程池才用链表阻塞队列LinkedBlockingQueue，先进先出原则，所以保证了任务的按顺序逐一进行。 ScheduledThreadPool ScheduledThreadPool是一个能实现定时和周期性任务的线程池，它的创建源码如下： public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } 可以看出corePoolSize是传进来的固定值，maximumPoolSize无限大，因为采用的队列DelayedWorkQueue是无解的，所以maximumPoolSize参数无效。该线程池执行如下： 当执行scheduleAtFixedRate或者scheduleWithFixedDelay方法时，会向DelayedWorkQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask(任务的包装类)，并会检查运行的线程是否达到corePoolSize。如果没有则新建线程并启动ScheduledFutureTask，然后去执行任务。 如果运行的线程达到了corePoolSize时，则将任务添加到DelayedWorkQueue中。DelayedWorkQueue会将任务进行排序，先要执行的任务会放在队列的前面。在跟此前介绍的线程池不同的是，当执行完任务后，会将ScheduledFutureTask中的time变量改为下次要执行的时间并放回到DelayedWorkQueue中。","text_tokens":["六个","下","blockingqueue","rejectedexecutionexception","大值","无须","链表","开销","1","七个","缓冲区","新建","闲置","机制","构造","理解","干掉","插入","非核心","并","其","time","回到","源码","处理","我们","并会","最","之后","大量","单位","scheduleatfixedrate","看出","无效","默认","为","0l","singlethreadexecutor","保证","数","毫秒","新","池中","种","提供","原则","分配","等于","出来","固定值","才","来","string","增加","这个","但池","意味着","<","四种","所","+","scheduledthreadpool","直接","满","定义","fixedthreadpool","无法","java","不","方式","-","同理","/","进行","包装","了","但","目的","keepalivetime","种类","workqueue","只","不同","：","放在","此","啥","！","被","含义","为了","那","使用","调用者","先","scheduledfuturetask","超时","等待","少","cachedthreadpool","的","delayedworkqueue","工厂","参数","于","设置","达到","后","池才","接到","一般","超过","必须","取","向","情况",">","10","如果","原理","函数","启动","内","main","只能","threadpoolexecutor","池","逐一","好","异常","也就是说","限定","去","指定","threadfactory","static","一旦","(","接收","实现","。","检查","装","着","总线","用者","delayed","失效","seconds","微","意味","该","executors","void","如何","设定","错误","可","类","它","到","能够","synchronousqueue","核数","当前","schedulewithfixeddelay","最大","最大值","milliseconds","并放","开启","个","下次","nthreads","此处","成","周期"," ","value","delayqueue","从","已经","进去","当","_","或是","[","后面","非核","中","重用","提交","scheduledthreadpoolexecutor","应对","其他","值","怎么办","executorservice","minutes","60l","=","runnable","60",";","先进","newcachedthreadpool","return","此前","导致","简单","等候","0","runnablescheduledfuture","方法","即","由于","做","不会","程","找到","根据","添加","跟","减缓","3","抛出","callerrunspolicy","速度","程多","长",",","周期性","时","newfixedthreadpool","有","new","unit","discardpolicy","abordpolicy","）","此外","2","public","你","corepoolsize","这","表示","数量","变量","；","采用","核心","是否","就","名字","反馈","long",")","中线","程数","采取","立刻","integer","介绍","定时","用","干","还有","最近","就是","也","就是说","不能","，","一个","说",".","]","响应速度","rejectedexecutionhandler","则","全部都是","类型","数都","完","优先","进来","arrayblockingqueue","将","小于","max","固定","超出","用到","int","（","怎么","接口","scheduledexecutorservice","需要","二倍","可以","其中","maximumpoolsize","元素","以上","和","多","总数","任务","策略","看到","避免","白养","handler","所以","discardoldestpolicy","线面","足够","如下","days","首先","饱和","并且","即使","五个","microseconds","linkedblockingqueue","给","单个","销毁","即可","调用","永远","占用","响应","所有","用法","长度","它们","枚举","无限","管理","分别","控制","前面","*","阻塞","缓冲","时候","空闲","删除","出现","是","多余","产生","执行","顺序","而是","无限大","会","要","都","常见","然后","上限","{","但是","影响","秒","cpu","类中","只有","程序","？","先进先出","排序","finalizabledelegatedexecutorservice","newscheduledthreadpool","而","能","工作","创建","传","运行","延时","}","每个","又","入队","终止","因为","限制","newsinglethreadexecutor","线程","全部","nanoseconds","timeunit","已满","无解","或者","args","丢弃","改为","构造函数","进入","一直","队列","没有","所在","按","hours","在","时间","发生","存在","池子","保留"],"title":"线程池","title_tokens":["线程","池"]},{"location":"threadPool/#_1","text":"装线程的池子，目的是管理线程，避免大量创建线程，增加开销，影响响应速度。 //五个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) //六个参数的构造函数-1 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) //六个参数的构造函数-2 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) //七个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize -> 该线程池中核心线程数最大值 核心线程：在创建完线程池之后，核心线程先不创建，在接到任务之后创建核心线程。并且会一直存在于线程池中（即使这个线程啥都不干），有任务要执行时，如果核心线程没有被占用，会优先用核心线程执行任务。数量一般情况下设置为CPU核数的二倍即可。 maximumPoolSize -> 该线程池中线程总数最大值 线程总数=核心线程数+非核心线程数。 非核心线程：简单理解，即核心线程都被占用，但还有任务要做，就创建非核心线程。 keepAliveTime -> 非核心线程闲置超时时长 这个参数可以理解为，任务少，但池中线程多，非核心线程不能白养着，超过这个时间不工作的就会被干掉，但是核心线程会保留。 TimeUnit -> keepAliveTime的单位 这个参数是个枚举类型 * DAYS * HOURS * MINUTES * SECONDS * MILLISECONDS * MICROSECONDS * NANOSECONDS微毫秒 BlockingQueue workQueue -> 线程池中的任务队列 默认情况下，任务进来之后先分配给核心线程执行，核心线程如果都被占用，并不会立刻开启非核心线程执行任务，而是将任务插入任务队列等待执行，核心线程会从任务队列取任务来执行，任务队列可以设置最大值，一旦插入的任务足够多，达到最大值，才会创建非核心线程执行任务。 常见的workQueue有四种： SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现<线程数达到了maximumPoolSize而不能新建线程>的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大。 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前已经创建的核心线程数小于线程池的核心线程数上限，则新建线程(核心线程)处理任务；如果当前已经创建的核心线程数等于核心线程数上限，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误，或是执行实现定义好的饱和策略。 DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。 ThreadFactory threadFactory -> 创建线程的工厂 可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。 RejectedExecutionHandler handler -> 饱和策略 这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy， 表示无法处理新任务，并抛出 RejectedExecutionException 异常。此外还有3种策略，它们分别如下。 CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 DiscardPolicy：不能执行的任务，并将该任务删除。 DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。","text_tokens":["先","六个","白养","下","handler","超时","blockingqueue","所以","discardoldestpolicy","rejectedexecutionexception","足够","即","等待","由于","少","做","不会","如下","的","days","首先","大值","程","饱和","并且","即使","无须","工厂","参数","五个","microseconds","开销","linkedblockingqueue","于","添加","设置","减缓","给","1","达到","即可","接到","一般","七个","超过","调用","必须","3","永远","占用","抛出","响应","callerrunspolicy","所有","取","速度","程多","情况","长度","长",">",",","如果","函数","时","新建","闲置","有","它们","机制","构造","内","threadpoolexecutor","理解","干掉","枚举","无限","插入","unit","管理","池","非核心","discardpolicy","abordpolicy","并","好","异常","分别","控制","）","*","此外","2","限定","时候","public","指定","corepoolsize","你","这","删除","表示","数量","出现","threadfactory","是","处理","核心","；","一旦","(","就","执行","之后","接收","实现","大量","名字","而是","反馈","单位","。","无限大","装","会","要","都","着","long","常见","上限","总线","delayed","用者",")","中线","程数","失效","默认","为","采取","但是","seconds","微","意味","该","影响","保证","立刻","cpu","integer","设定","错误","只有","数","它","毫秒","？","池中","新","种","提供","到","能够","synchronousqueue","用","分配","核数","干","还有","当前","等于","出来","最近","最大","最大值","milliseconds","而","开启","也","工作","创建","才","传","来","增加","这个","个","延时","不能","每个","但池","意味着","成","又","，","入队","一个"," ","<",".","四种","因为","限制","所","value","delayqueue","+","响应速度","从","rejectedexecutionhandler","线程","已经","则","进去","当","直接","nanoseconds","_","或是","类型","满","定义","timeunit","无法","不","完","-","已满","非核","优先","中","/","提交","进来","arrayblockingqueue","将","小于","max","了","丢弃","int","（","但","构造函数","怎么","进入","目的","一直","队列","接口","没有","应对","所在","值","keepalivetime","怎么办","workqueue","minutes","二倍","=","可以","maximumpoolsize","元素","runnable","：","hours","此","在","啥","时间","和","多","发生","存在","！","总数","任务","导致","被","池子","简单","策略","为了","等候","那","保留","使用","避免","调用者"],"title":"含义","title_tokens":["含义"]},{"location":"threadPool/#_2","text":"以上是原理，线面说用法，java给我们提供了四种线程池 FixedThreadPool * CachedThreadPool * SingleThreadExecutor * ScheduledThreadPool FixedThreadPool 可重用固定线程数的线程池，超出的线程会在队列中等待，在Executors类中我们可以找到创建方式 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } FixedThreadPool的corePoolSize和maximumPoolSize都设置为参数nThreads，也就是只有固定数量的核心线程，不存在非核心线程。keepAliveTime为0L表示多余的线程立刻终止，因为不会产生多余的线程，所以这个参数是无效的。FixedThreadPool的任务队列采用的是LinkedBlockingQueue。 创建线程池的方法，在我们的程序中只需要，后面其他种类的同理： public static void main(String[] args) { // 参数是要线程池的线程最大值 ExecutorService executorService = Executors.newFixedThreadPool(10); } CachedThreadPool CachedThreadPool是一个根据需要创建线程的线程池。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } CachedThreadPool的corePoolSize是0，maximumPoolSize是Int的最大值，也就是说CachedThreadPool没有核心线程，全部都是非核心线程，并且没有上限。keepAliveTime是60秒，就是说空闲线程等待新任务60秒，超时则销毁。此处用到的队列是阻塞队列SynchronousQueue,这个队列没有缓冲区，所以其中最多只能存在一个元素,有新的任务则阻塞等待。 SingleThreadExecutor SingleThreadExecutor是使用单个线程工作的线程池。其创建源码如下 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } 我们可以看到总线程数和核心线程数都是1，所以就只有一个核心线程。该线程池才用链表阻塞队列LinkedBlockingQueue，先进先出原则，所以保证了任务的按顺序逐一进行。 ScheduledThreadPool ScheduledThreadPool是一个能实现定时和周期性任务的线程池，它的创建源码如下： public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } 可以看出corePoolSize是传进来的固定值，maximumPoolSize无限大，因为采用的队列DelayedWorkQueue是无解的，所以maximumPoolSize参数无效。该线程池执行如下： 当执行scheduleAtFixedRate或者scheduleWithFixedDelay方法时，会向DelayedWorkQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask(任务的包装类)，并会检查运行的线程是否达到corePoolSize。如果没有则新建线程并启动ScheduledFutureTask，然后去执行任务。 如果运行的线程达到了corePoolSize时，则将任务添加到DelayedWorkQueue中。DelayedWorkQueue会将任务进行排序，先要执行的任务会放在队列的前面。在跟此前介绍的线程池不同的是，当执行完任务后，会将ScheduledFutureTask中的time变量改为下次要执行的时间并放回到DelayedWorkQueue中。","text_tokens":["先","scheduledfuturetask","所以","超时","0","runnablescheduledfuture","线面","方法","等待","cachedthreadpool","不会","如下","的","delayedworkqueue","大值","并且","参数","链表","找到","linkedblockingqueue","根据","添加","设置","跟","给","单个","销毁","1","池才","达到","后","缓冲区","用法","向",">",",","周期性","10","原理","如果","时","新建","newfixedthreadpool","有","启动","main","只能","threadpoolexecutor","new","无限","池","非核心","逐一","并","前面","也就是说","*","阻塞","缓冲","其","time","public","空闲","去","corepoolsize","回到","源码","表示","数量","变量","是","采用","static","核心","多余","我们","产生","是否","(","就","并会","执行","最","实现","顺序","。","无限大","检查","scheduleatfixedrate","会","要","都","总线","看出","上限","然后","无效",")","程数","为","{","0l","seconds","singlethreadexecutor","该","秒","保证","executors","立刻","void","integer","类中","可","类","只有","数","程序","它","新","提供","到","介绍","先进先出","原则","定时","finalizabledelegatedexecutorservice","排序","synchronousqueue","用","newscheduledthreadpool","schedulewithfixeddelay","最大","最大值","milliseconds","固定值","并放","能","就是","也","工作","创建","传","包装","就是说","string","运行","这个","}","下次","nthreads","此处","，","一个","说"," ",".","<","四种","终止","]","因为","周期","newsinglethreadexecutor","value","线程","则","scheduledthreadpool","全部","当","_","[","全部都是","timeunit","数都","fixedthreadpool","java","方式","不","后面","完","非核","同理","中","无解","/","重用","进行","进来","超出","固定","或者","args","了","max","用到","int","将","改为","scheduledthreadpoolexecutor","接口","队列","其他","没有","scheduledexecutorservice","executorservice","keepalivetime","需要","种类","按","只","可以","=","60l","maximumpoolsize","其中","runnable","以上","60","：",";","元素","先进","放在","不同","在","时间","和","newcachedthreadpool","多","return","此前","存在","任务","看到","使用"],"title":"如何使用线程池","title_tokens":["池","线程","如何","使用"]},{"location":"touchEvent/","text":"事件分发","text_tokens":["事件","分发"],"title":"事件分发","title_tokens":["事件","分发"]},{"location":"touchEvent/#_1","text":"","text_tokens":[],"title":"事件分发","title_tokens":["事件","分发"]},{"location":"constructure/mvc/","text":"MVC View：XML布局文件。 Model：实体模型（数据的获取、存储、数据状态变化）。 Controller：对应于Activity，处理数据、业务和UI。 从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个Model-View（Activity:View&Controller）的结构。 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这是苹果开发者文档中摘过来的图片，表明了三者之间的关系，简单描述了三者作用Model：数据模型，用来存储数据View：视图界面，用来展示UI界面和响应用户交互Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互他们工作和关系看起来是如此清晰，是一种非常好的设计思想，是的，首先声明MVC是一个非常好的架构思想。","text_tokens":["遇到","最终","两个","获取","view","所以","activity","千行","转载","数以","开发者","商业","贴切","非常","的","首先","监听","于","controller","实体","多数","纯粹","响应","所有","布局","看起来","情况","一种","改变","只能","android","数据","展示","mvc","好","控制","用来","）","吧","请","开发","非商业","结构","处理","是","我们","看起","(","这是","就","还是","清晰","思想","大量","写","。","这样","acitivty","苹果","过","更","作用","都","只是","设计",")","中摘","充当","但是","大多数","起来","注明","来看","表明","数据模型","xml","联系","三者","model","大多","本身","著作","交互","ui",":","太弱","工作","行为","这个","相信","大管家","其实","描述","，","一个"," ","逻辑","业务","存储","变化","获得","从","大","状态","模型","符合","说法","他们","直接","作为","爆炸","过来","大管","-","中","架构","功能","关系","角色","了","（","、","上面","&","界面","声明","用户","如此","文件","管家","之间","图片","：","文档","在","和","著作权","授权","控制器","！","视图","归","导致","实体模型","代码","出处","简单","作者","对应"],"title":"MVC","title_tokens":["mvc"]},{"location":"constructure/mvc/#mvc","text":"View：XML布局文件。 Model：实体模型（数据的获取、存储、数据状态变化）。 Controller：对应于Activity，处理数据、业务和UI。 从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个Model-View（Activity:View&Controller）的结构。 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这是苹果开发者文档中摘过来的图片，表明了三者之间的关系，简单描述了三者作用Model：数据模型，用来存储数据View：视图界面，用来展示UI界面和响应用户交互Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互他们工作和关系看起来是如此清晰，是一种非常好的设计思想，是的，首先声明MVC是一个非常好的架构思想。","text_tokens":["遇到","最终","两个","获取","view","所以","activity","千行","转载","数以","开发者","商业","贴切","非常","的","首先","监听","于","controller","实体","多数","纯粹","响应","所有","布局","看起来","情况","一种","改变","只能","android","数据","展示","mvc","好","控制","用来","）","吧","请","开发","非商业","结构","处理","是","我们","看起","(","这是","就","还是","清晰","思想","大量","写","。","这样","acitivty","苹果","过","更","作用","都","只是","设计",")","中摘","充当","但是","大多数","起来","注明","来看","表明","数据模型","xml","联系","三者","model","大多","本身","著作","交互","ui",":","太弱","工作","行为","这个","相信","大管家","其实","描述","，","一个"," ","逻辑","业务","存储","变化","获得","从","大","状态","模型","符合","说法","他们","直接","作为","爆炸","过来","大管","-","中","架构","功能","关系","角色","了","（","、","上面","&","界面","声明","用户","如此","文件","管家","之间","图片","：","文档","在","和","著作权","授权","控制器","！","视图","归","导致","实体模型","代码","出处","简单","作者","对应"],"title":"MVC","title_tokens":["mvc"]},{"location":"constructure/mvp/","text":"mvp","text_tokens":["mvp"],"title":"Mvp","title_tokens":["mvp"]},{"location":"constructure/mvp/#mvp","text":"","text_tokens":[],"title":"mvp","title_tokens":["mvp"]},{"location":"constructure/mvvm/","text":"mvvm","text_tokens":["mvvm"],"title":"Mvvm","title_tokens":["mvvm"]},{"location":"constructure/mvvm/#mvvm","text":"","text_tokens":[],"title":"mvvm","title_tokens":["mvvm"]},{"location":"customView/customCombinationView/","text":"第一步定义你要复用的布局 <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"> <TextView android:id=\"@+id/tv_left_attribute\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/tv_order_goods_name\" android:textSize=\"@dimen/edge_14\" android:textColor=\"@color/color_3f3f3f\" android:layout_marginTop=\"@dimen/edge_15\" android:layout_centerVertical=\"true\"/> <TextView android:id=\"@+id/tv_right_attribute\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"@color/color_808080\" android:textSize=\"@dimen/edge_14\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\"/> </RelativeLayout> 第二步定义自定义属性(value下新建attrs) <resources> <declare-styleable name=\"SimpleAttribute\"> <attr name=\"left_text_color\" format=\"color\"/> <attr name=\"left_text_size\" format=\"dimension\"/> <attr name=\"left_text\" format=\"string\"/> <attr name=\"right_text_color\" format=\"color\"/> <attr name=\"right_text_size\" format=\"dimension\"/> <attr name=\"right_text\" format=\"string\"/> </declare-styleable> </resources> 第三步自定义一个View根据需求继承不同的viewGroup,如：RelativeLayout、LinearLayout等,复写两个构造方法 public class SimpleAttribute extends RelativeLayout { 初始化控件 private void initView(Context context) { View.inflate(context, R.layout.attribute_layout, this); mLeftTv = this.findViewById(R.id.tv_left_attribute); mRightTv = this.findViewById(R.id.tv_right_attribute); } 重写构造方法，在构造方法中初始化控件，并引用自定义属性。 private void useCustomAttribute(Context context, AttributeSet attrs) { TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.SimpleAttribute); int leftTextColor = typedArray.getColor(R.styleable.SimpleAttribute_left_text_color, getResources().getColor(R.color.black)); setLeftTextColor(leftTextColor); float leftTextSize = typedArray.getDimension(R.styleable.SimpleAttribute_left_text_size, getResources().getDimension(R.dimen.edge_14)); setLeftTextSize(leftTextSize); String leftText = typedArray.getString(R.styleable.SimpleAttribute_left_text); setLeftText(leftText); int rightTextColor = typedArray.getColor(R.styleable.SimpleAttribute_right_text_color, getResources().getColor(R.color.black)); setRightTextColor(rightTextColor); float rightTextSize = typedArray.getDimension(R.styleable.SimpleAttribute_right_text_size, getResources().getDimension(R.dimen.edge_14)); setRightTextSize(rightTextSize); String rightText = typedArray.getString(R.styleable.SimpleAttribute_right_text); setRightText(rightText); } 完整代码： /** * author : luis * e-mail : luis.gong@cardinfolink.com * date : 2020/7/17 19:39 * desc : */ public class SimpleAttribute extends RelativeLayout { private TextView mLeftTv; private TextView mRightTv; public SimpleAttribute(Context context) { super(context); initView(context); } public SimpleAttribute(Context context, AttributeSet attrs) { super(context, attrs); useCustomAttribute(context, attrs); } private void initView(Context context) { View.inflate(context, R.layout.attribute_layout, this); mLeftTv = this.findViewById(R.id.tv_left_attribute); mRightTv = this.findViewById(R.id.tv_right_attribute); } private void useCustomAttribute(Context context, AttributeSet attrs) { TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.SimpleAttribute); int leftTextColor = typedArray.getColor(R.styleable.SimpleAttribute_left_text_color, getResources().getColor(R.color.black)); setLeftTextColor(leftTextColor); float leftTextSize = typedArray.getDimension(R.styleable.SimpleAttribute_left_text_size, getResources().getDimension(R.dimen.edge_14)); setLeftTextSize(leftTextSize); String leftText = typedArray.getString(R.styleable.SimpleAttribute_left_text); setLeftText(leftText); int rightTextColor = typedArray.getColor(R.styleable.SimpleAttribute_right_text_color, getResources().getColor(R.color.black)); setRightTextColor(rightTextColor); float rightTextSize = typedArray.getDimension(R.styleable.SimpleAttribute_right_text_size, getResources().getDimension(R.dimen.edge_14)); setRightTextSize(rightTextSize); String rightText = typedArray.getString(R.styleable.SimpleAttribute_right_text); setRightText(rightText); } public void setLeftTextSize(float leftTextSize) { mLeftTv.setTextSize(leftTextSize); } public void setLeftTextColor(int leftTextColor) { mLeftTv.setTextColor(leftTextColor); } public void setLeftText(String leftText){ mLeftTv.setText(leftText); } public void setRightTextSize(float rightTextSize) { mRightTv.setTextSize(rightTextSize); } public void setRightTextColor(int rightTextColor) { mRightTv.setTextColor(rightTextColor); } public void setRightText(String rightText){ mRightTv.setText(rightText); } }","text_tokens":["centervertical","下","linearlayout","两个","view","属性","content","declare","复写","class","方法","float","初始化","的","39","alignparentright","14","第一","getresources","inflate","black","setrighttext","复用","根据","第三步","控件","lefttextsize","mail","dimension","res","super","com","布局","color","二步","构造方法",">","第二步",",","808080","context","wrap","extends","e","新建","edge","gong","重写","构造","android","text","需求","relativelayout","attribute","left","并","一步","http","simpleattribute","getdimension","*","righttext","getcolor","2020","public","如","你","this","引用","resources","自定","author","(","7","parent","tv","textview","width","。","要","17","apk","setlefttextcolor",")","第三","luis","完整","{","3f3f3f","private","obtainstyledattributes","desc","lefttextcolor","三步","r","getstring","void","goods","initview","\"","@","layout","format","styleable","dimen","自定义","size","xmlns","cardinfolink",":","order","date","righttextsize","mrighttv","string","}","setlefttext","viewgroup","，","typedarray","一个"," ","<",".","true","righttextcolor","19","setlefttextsize","value","继承","+","第二","等","初始","usecustomattribute","_","height","right","定义","match","attrs","-","schemas","中","setrighttextcolor","/","margintop","setrighttextsize","settextcolor","findviewbyid","settextsize","textcolor","int","、","lefttext","mlefttv","name","第一步","textsize","attr","=","不同","：",";","settext","在","attributeset","代码","15","id"],"title":"自定义组合控件","title_tokens":["控件","自定","定义","组合","自定义"]},{"location":"customView/customView/","text":"自定义View","text_tokens":["view","自定","定义","自定义"],"title":"自定义View","title_tokens":["view","自定","定义","自定义"]},{"location":"customView/customView/#view","text":"","text_tokens":[],"title":"自定义View","title_tokens":["view","自定","定义","自定义"]},{"location":"designpattern/builder/","text":"定义 将一个复杂对象的构建和表示分离，使得同样的构建过程可以构建不同的对象。 经典例子 创建对象传递参数的时候往往通过构造函数来传，，随着构造函数的增加，代码会很难编写。 例：生产组装一辆、台电脑 public class computer{ private final String display； private final String keyBoard； private final String mouse； public static class Builder{ //必选字段 private final String display； private final String keyBoard； //可选字段 private final String mouse； public Builder(String display, String keyBoard){ this.display = display; this.keyBoard = keyBoard; } public Builder mouse(String mouse){ this.mouse = mouse; return this; } public Computer build(){ return new Computer(this); } } private Computer (Builder builder){ display = builder.display; keyBoard = builder.keyBoard; mouse = builder.mouse; } } 测试代码 Computer computer = new Computer.Builder(\"三星\",\"华为\") .mouse(\"苹果\") .build(); Android 采用Builder模式的AlertDialog AlertDialog.Builder dialog = new AlertDialog.Nuilder(this); dialog.setTitle(\"关于我们\") .setMessage(\"大家好!\") .creat() .show(); 优缺点 链式调用抑郁阅读和编写，出错难以debug","text_tokens":["class","电脑","随着","的","华为","参数","mouse","测试代码","show","debug","编写","调用","缺点","构建","阅读",",","函数","测试","!","构造","android","过程","new","生产","好","通过","时候","public","setmessage","creat","this","表示","；","采用","static","我们","(","例子","台","抑郁","alertdialog","。","苹果","会","display",")","final","链式","难","{","private","很","大家","可","\"","builder","settitle","创建","string","增加","}","复杂","，","一个","组装"," ",".","build","来传","关于","使得","一辆","出错","keyboard","定义","例","模式","三星","段","dialog","/","往往","将","对象","优缺点","、","nuilder","分离","构造函数","传递","computer","可以","创建对象","=","不同","：",";","和","return","必选","代码","难以","选字","字","经典","同样"],"title":"Builder","title_tokens":["builder"]},{"location":"designpattern/builder/#_1","text":"将一个复杂对象的构建和表示分离，使得同样的构建过程可以构建不同的对象。","text_tokens":["和","不同","的","过程","将","对象","使得","复杂","分离","表示","可以","构建","，","一个","同样","。"],"title":"定义","title_tokens":["定义"]},{"location":"designpattern/builder/#_2","text":"创建对象传递参数的时候往往通过构造函数来传，，随着构造函数的增加，代码会很难编写。 例：生产组装一辆、台电脑 public class computer{ private final String display； private final String keyBoard； private final String mouse； public static class Builder{ //必选字段 private final String display； private final String keyBoard； //可选字段 private final String mouse； public Builder(String display, String keyBoard){ this.display = display; this.keyBoard = keyBoard; } public Builder mouse(String mouse){ this.mouse = mouse; return this; } public Computer build(){ return new Computer(this); } } private Computer (Builder builder){ display = builder.display; keyBoard = builder.keyBoard; mouse = builder.mouse; } } 测试代码 Computer computer = new Computer.Builder(\"三星\",\"华为\") .mouse(\"苹果\") .build(); Android 采用Builder模式的AlertDialog AlertDialog.Builder dialog = new AlertDialog.Nuilder(this); dialog.setTitle(\"关于我们\") .setMessage(\"大家好!\") .creat() .show();","text_tokens":["class","电脑","随着","的","华为","参数","mouse","测试代码","show","编写",",","函数","测试","!","构造","android","new","生产","好","通过","时候","public","setmessage","creat","this","；","采用","static","我们","(","台","alertdialog","。","苹果","会","display",")","final","难","{","private","很","大家","可","\"","builder","settitle","创建","string","增加","}","，","组装","build"," ",".","来传","关于","一辆","keyboard","例","模式","三星","段","dialog","/","往往","对象","、","nuilder","构造函数","传递","computer","创建对象","=","：",";","return","必选","代码","选字","字"],"title":"经典例子","title_tokens":["例子","经典"]},{"location":"designpattern/builder/#_3","text":"链式调用抑郁阅读和编写，出错难以debug","text_tokens":["和","调用","编写","阅读","抑郁","链式","出错","难以","，","debug"],"title":"优缺点","title_tokens":["优缺点","缺点"]},{"location":"designpattern/factory/","text":"定义 普通工厂模式：生产具体的产品，创建的产品是类(class) 抽象工厂：生产抽象产品，创建的产品是接口(interface) 经典例子 优缺点 降低耦合，很好的扩展性 缺点是不太容易扩展新的产品类，需要具体的改产品类和工厂类。","text_tokens":["interface","很","定义","扩展","类","模式","class","生产","不","新","好","容易","的","优缺点","太","工厂","耦合","接口","抽象","产品","是","创建","需要","(","例子","缺点","具体","，","降低","："," ","。","扩展性","和",")","普通","展性","经典","改"],"title":"工厂","title_tokens":["工厂"]},{"location":"designpattern/factory/#_1","text":"普通工厂模式：生产具体的产品，创建的产品是类(class) 抽象工厂：生产抽象产品，创建的产品是接口(interface)","text_tokens":["interface","类","模式","class","生产","的","工厂","接口","抽象","产品","是","创建","(","具体","，","："," ",")","普通"],"title":"定义","title_tokens":["定义"]},{"location":"designpattern/factory/#_2","text":"","text_tokens":[],"title":"经典例子","title_tokens":["例子","经典"]},{"location":"designpattern/factory/#_3","text":"降低耦合，很好的扩展性 缺点是不太容易扩展新的产品类，需要具体的改产品类和工厂类。","text_tokens":["很","扩展","类","不","新","好","容易","的","展性","太","工厂","耦合","产品","是","需要","缺点","具体","，","降低"," ","。","和","扩展性","改"],"title":"优缺点","title_tokens":["优缺点","缺点"]},{"location":"designpattern/observer/","text":"定义 基于事件和响应的设计模式 简单来说多个观察者同时观察一个对象，当对象发生变化的时候观察者能够回调自身的方法更新自己。 1. 定义一个观察者接口 2. 观察者实现观察者接口 3. 定义被观察者接口或者抽象类，里面有addObserver(Observer observer),removeObserver(Observer observer),notifyObserver(),调用notifyObserver(),遍历list<Observer>, 回调onserver里面的方法。 经典的例子 游戏中英雄，在地图中中走，捡宝盒增加技能或者踩到陷阱减生命力的。 在这个例子中，宝石，宝剑和陷阱属于观察者ConcreteObserver,英雄属于被观察者， 如何建立关系呢？ 首先有很多的英雄和很多的道具，抽取共同的行为 Public interface Observer{ void update(); } 宝石 public Stone implement Observer{ public void update(){ if(inrange()){ System.out.print(\"获取到宝石\"); } } public Boolean inrange(){ //判断是否在距离内 return true; } } 陷阱 public Trap implement Observer{ public void update(){ if(){ System.out.print(\"踩到陷阱\"); } } } 定义抽象类 public abstract Subject{ private List<Observer> observerList = new ArrayList<Observer>(); public void addObserver(Observer observer){ observerList.add(observer); } public void deleteObserver(Observer observer){ observerList.remove(observer); } public void notifyObserver(){ for(Observer observer: observerList){ observer.update(); } } } 定义英雄 public class Hero extend Subject{ public void run(){ notifyObserver(); } } 具体调用 ``` public class client{ public static void main(String[] args){ //初始化对象 Hero hero = new Hero(); Stone stone = new Stone(); Trap trap = new Trap(); hero.addObserver(stone); hero.addObserver(trap); hero.run(); } } 代码输出如下： 获取到宝石 踩到陷阱 ``` 优缺点 解耦观察者被观察者","text_tokens":["interface","里面","inrange","arraylist","解","获取","class","生命","方法","初始化","属于","如下","的","遍历","首先","update","事件","抽象","1","调用","缺点","subject","3","生命力","响应","宝石","减",">","输出",",","走","英雄","设计模式","deleteobserver","有","共同","内","main","new","print","捡","2","时候","onserver","public","多个","static","是否","(","例子","同时","boolean","实现","。","if","发生变化","生变","`","宝盒","设计",")","宝剑","removeobserver","来说","{","private","stone","void","抽象类","如何","abstract","\"","？","addobserver","建立","到","更新","基于","能够",":","run","踩","行为","距离","string","增加","这个","}","中中","extend","具体","，","一个"," ",".","<","true","remove","]","变化","很多","system","concreteobserver","当","呢","add","初始","[","list","观察者","定义","模式","判断","观察","hero","client","自身","中","/","notifyobserver","抽取","关系","或者","对象","args","道具","陷阱","优缺点","游戏","自己","接口","for","out","技能","trap","observer","observerlist","=","地图","：",";","在","和","发生","return","耦","被","代码","简单","回调","implement","经典"],"title":"观察者","title_tokens":["观察者","观察"]},{"location":"designpattern/observer/#_1","text":"基于事件和响应的设计模式 简单来说多个观察者同时观察一个对象，当对象发生变化的时候观察者能够回调自身的方法更新自己。 1. 定义一个观察者接口 2. 观察者实现观察者接口 3. 定义被观察者接口或者抽象类，里面有addObserver(Observer observer),removeObserver(Observer observer),notifyObserver(),调用notifyObserver(),遍历list<Observer>, 回调onserver里面的方法。","text_tokens":["定义","里面","抽象类","模式","方法","观察","有","addobserver","自身","更新","notifyobserver","2","基于","的","时候","能够","或者","对象","遍历","onserver","自己","事件","多个","接口","抽象","1","(","调用","3","observer","同时","响应","，","实现","一个"," ",".","<","。","发生变化","和","生变","发生",">","变化",",","设计","被","简单",")","removeobserver","设计模式","来说","当","回调","list","观察者"],"title":"定义","title_tokens":["定义"]},{"location":"designpattern/observer/#_2","text":"游戏中英雄，在地图中中走，捡宝盒增加技能或者踩到陷阱减生命力的。 在这个例子中，宝石，宝剑和陷阱属于观察者ConcreteObserver,英雄属于被观察者， 如何建立关系呢？ 首先有很多的英雄和很多的道具，抽取共同的行为 Public interface Observer{ void update(); } 宝石 public Stone implement Observer{ public void update(){ if(inrange()){ System.out.print(\"获取到宝石\"); } } public Boolean inrange(){ //判断是否在距离内 return true; } } 陷阱 public Trap implement Observer{ public void update(){ if(){ System.out.print(\"踩到陷阱\"); } } } 定义抽象类 public abstract Subject{ private List<Observer> observerList = new ArrayList<Observer>(); public void addObserver(Observer observer){ observerList.add(observer); } public void deleteObserver(Observer observer){ observerList.remove(observer); } public void notifyObserver(){ for(Observer observer: observerList){ observer.update(); } } } 定义英雄 public class Hero extend Subject{ public void run(){ notifyObserver(); } } 具体调用 ``` public class client{ public static void main(String[] args){ //初始化对象 Hero hero = new Hero(); Stone stone = new Stone(); Trap trap = new Trap(); hero.addObserver(stone); hero.addObserver(trap); hero.run(); } } 代码输出如下： 获取到宝石 踩到陷阱 ```","text_tokens":["interface","inrange","arraylist","获取","class","生命","初始化","属于","如下","的","首先","update","抽象","调用","subject","生命力","宝石","减",">","输出",",","走","英雄","deleteobserver","有","共同","内","main","new","print","捡","public","static","是否","(","例子","boolean","。","if","`","宝盒",")","宝剑","{","private","stone","void","如何","抽象类","abstract","\"","？","addobserver","建立","到",":","run","踩","行为","距离","string","增加","这个","}","中中","extend","具体","，"," ",".","<","true","remove","]","很多","system","concreteobserver","初始","呢","add","[","list","观察者","定义","判断","观察","hero","client","中","/","notifyobserver","抽取","关系","或者","对象","args","道具","陷阱","游戏","for","out","技能","trap","observer","observerlist","=","地图","：",";","在","和","return","被","代码","implement"],"title":"经典的例子","title_tokens":["例子","经典","的"]},{"location":"designpattern/observer/#_3","text":"解耦观察者被观察者","text_tokens":["解","耦","被","观察","观察者"],"title":"优缺点","title_tokens":["优缺点","缺点"]},{"location":"designpattern/singleInstance/","text":"简单来说就是一个类只能构建一个对象的设计模式 第一种不加锁的单例 线程不安全 public class Singleton { private Singleton() {} //私有构造函数 private static Singleton instance = null; //静态工厂方法 public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式 在类被初始化的时候就已经在内存中创建了对象，以空间换时间，不存在线程安全问题。 public class SingleTon{ private static SingleTon INSTANCE = new SingleTon(); private SingleTon(){} public static SingleTon getInstance(){ return INSTANCE; } } 懒汉式 在方法被调起后才创建对象，以时间换空间，在多线程环境下存在风险。 public class SingleTon{ private static SingleTon INSTANCE = null; private SingleTon(){} public static SingleTon getInstance() { if(INSTANCE == null){ INSTANCE = new SingleTon(); } return INSTANCE； } } 简单加上synchronized锁 双重检测(double check lock)是为了b线程在a线程刚结束的临界点执行锁内任务，存在DCL失效问题 public class Singleton { private Singleton() {} //私有构造函数 private static Singleton instance = null; //单例对象 //静态工厂方法 public static Singleton getInstance() { if (instance == null) { //双重检测机制 synchronized (Singleton.class){ //同步锁 if (instance == null) { //双重检测机制 instance = new Singleton(); } } } return instance; } } 以上实现还是有问题 ，单例第三种写法 JVM编译器有个指令重排的概念 * 什么是指令重排 java一个简单的instance = new instance()会被jvm编译成如下jvm指令 1. memory = allocate;分配对象的内存地址 2. creatinstance(memory);初始化对象 3. instance = memory设置instance指向刚分配的内存地址 但是这些指令顺序并非是一重不变，可能会经过jvm和cpu的优化，进行重排序 1.分配对象内存地址 3.设置instance指向刚分配的内存地址 2.初始化对象 当线程A执行完13的时候，线程B抢到资源，返回了一个还没有初始化完成的对象 * 如何避免以上问题？ 在instance对象前面增加一个volatile修饰符 public class Singleton { private Singleton() {} //私有构造函数 private volatile static Singleton instance = null; //单例对象 //静态工厂方法 public static Singleton getInstance() { if (instance == null) { //双重检测机制 synchronized (Singleton.class){ //同步锁 if (instance == null) { //双重检测机制 instance = new Singleton(); } } } return instance; } } volatile阻止了变量访问访问前后指令重排序，对于线程B来说，instance要么指向null，要么指向一个完整的instance,而不会出现中间状态 不仅可以防止指令重排，也可以保证线程访问的变量值是主内存种最新值，jdk1.6及以后才支持，每次均从主内存中读取，牺牲点效率，无伤大雅。 静态内部类 静态内部类只会被加载一次，首次调用，顾线程安全，类加载初始化阶段是单线程的同时延迟了初始化。 类加载时机 1. new,involk static,putstatic,getstatic,指令时若类未加载则触发 2. 反射使用某个类时，若类未加载则触发 3. 子类加载时若父类未加载则触发 4. 程序开始时主方法所在类会被加载 静态内部类的懒加载应该属于第一种情况，为什么外部类加载时，内部类未加载，静态内部类只是刚好写在了另一个类里面，实际上和外部类没什么附属关系。 public class Singleton{ private SingleTon (){} private static class Holder{ //这里的私有没有什么意义 private static SingleTon instance = new Singleton(); } public static Singleton getInstance(){ return Holder.instance } } 如何通过反射打破单例模式，只能构建一个对象 //获得构造器 Constructor con = Singleton.class.getDeclaredConstructor(); //设置为可访问 con.setAccessible(true); //构造两个不同的对象 Singleton singleton1 = (Singleton)con.newInstance(); Singleton singleton2 = (Singleton)con.newInstance(); //验证是否是不同对象 System.out.println(singleton1.equals(singleton2)); 如何防止反射？ 使用枚举实现单例 public enum SingletonEnum { INSTANCE; } 使用枚举单例，不仅可以防止反序列化，而且可以保证枚举对象被反序列化的时候，返回的对象是同一个对象 public enum SingletonEnum { INSTANCE; public void doSomething(){ System.out.printLn(\"do something\"); } } public enum SingletonEnum{ PERSON; private Person person = null; private SingletonEnum(){ person = new Person(); } public Person getPerson(){ return person; } } public class Person{ } 防止内存泄漏单例 public class A8PinPadManage { private A8PinPadManage(){} //私有构造函数 private volatile static Pinpad instance; //单例对象 public static Pinpad getInstance(Context context) { WeakReference<Context> contextWeakReference = new WeakReference<>(context); Context weakReferenceContext = contextWeakReference.get(); if (instance == null) { synchronized (A8PinPadManage.class) { if (instance == null) { instance = new Pinpad((int) SharedPrefsUtil.get(weakReferenceContext, CIL_KAP_ID, 2), \"IPP\"); } } } return instance; } } 解读 私有构造函数，全局只能构建一个对象，不能让随便的就去new,所以要私有 懒汉，单例刚开始没有构建，调用才构建 饿汉，调用new singleton主动构建，不需要判空 instance的初始值可以写成null或者new Singleton() 不加锁，线程不安全 不加双重验证直接锁getinstance方法，可以，增加内存开销，只用synchronize里面的判空，增加开销 参考 小灰漫画 https://www.zhihu.com/search?type=content&q=%E5%8D%95%E4%BE%8B","text_tokens":["下","类会","两个","检测","这些","主","临界","content","allocate","第一","概念","开销","1","写成","返回","换","类未","null","设计模式","机制","参考","构造","子类","get","随便","有个","编译","小灰","加上","还是","未","牺牲","同时","只是","设计","第三","前后","完整","为","private","刚","指令","e5%","父类","保证","cil","singleton","种","打破","分配","才","增加","器","kap","<","system","效率","静态","直接","enum","newinstance","首次","java","不","/","进行","了","实际","地址","memory","getstatic","&","同一","懒汉","volatile","创建对象","不同","被","为了","使用","id","私有","延迟","量值","资源","初始化","触发","instance","锁内","的","最新","懒","search","holder","weakreferencecontext","工厂","一重","防止","设置","判空","后","每次","及","是否是","泄漏","com","do","情况",">","均","sharedprefsutil","函数","只能","漫画","重","开始","去","没什么","contextweakreference","单例","static","weakreference","(","修饰","三种","时主","风险","实现","写","。","失效","为什么","内部","void","a8pinpadmanage","类","如何","可","\"","锁","https","getinstance","getdeclaredconstructor","dcl","实际上","getperson","要么","优化"," ","反","已经","什么","结束","当","_","setaccessible","第三种","编译器","person","synchronized","involk","中","让","值","13","而且","singletonenum","=",";","return","www","简单","环境","修饰符","大雅","里面","序列","类时","调起","方法","指向","不会","属于","只会","刚好","3",",","式","时","8d%","有","new","意义","阶段","2","另","public","变量","；","还","是否","加","就","这里","时机","check",")","点","equals","来说","饿汉","可能","println","e4%","dosomething","序列化","内存","内存地址","顾","多线程","经过","zhihu","就是","也","附属","jvm","不能","b","，","一个",".","一次","%","true","完成","不仅","则","状态","变量值","读取","解读","若类","临界点","完","主动","对象","int","中间状态","需要","singleton2","可以","以上","同一个","双重","和","a","任务","避免","type","所以","class","lock","pinpad","q","加锁","某个","重排","如下","无伤大雅","调用","creatinstance","构建","反射","从主","验证","一种","context","并非","singleton1","只用","con","枚举","时若","4","安全","前面","*","通过","多线","时候","加载","写法","不变","中间","出现","是","访问","执行","空间","对于","顺序","if","全局","第一种","会","要","be%","外","{","译成","但是","synchronize","cpu","程序","ipp","？","部类","排序","95%",":","应该","而","创建","double","以","}","以后","初始值","获得","线程","编译成","初始","?","抢到","问题","8b","模式","关系","或者","时若类","构造函数","单线","没有","putstatic","所在","无伤","constructor","out","同步","阻止","在","时间","存在","something","单线程","jdk1.6","支持"],"title":"单例","title_tokens":["单例"]},{"location":"designpattern/singleInstance/#_1","text":"线程不安全 public class Singleton { private Singleton() {} //私有构造函数 private static Singleton instance = null; //静态工厂方法 public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式 在类被初始化的时候就已经在内存中创建了对象，以空间换时间，不存在线程安全问题。 public class SingleTon{ private static SingleTon INSTANCE = new SingleTon(); private SingleTon(){} public static SingleTon getInstance(){ return INSTANCE; } } 懒汉式 在方法被调起后才创建对象，以时间换空间，在多线程环境下存在风险。 public class SingleTon{ private static SingleTon INSTANCE = null; private SingleTon(){} public static SingleTon getInstance() { if(INSTANCE == null){ INSTANCE = new SingleTon(); } return INSTANCE； } }","text_tokens":["构造","下","私有","饿汉","new","类","class","调起","不","方法","内存","singleton","初始化","安全","多线程","中","/","instance","多线","的","时候","public","对象","getinstance","了","工厂","构造函数","；","static","创建","才","懒汉","后","(","以","}","就","创建对象","=","空间","，","换","风险",";"," ","if","在","。","时间","return","null","存在",")","被","式","已经","线程","函数","初始","环境","{","静态","private","问题"],"title":"第一种不加锁的单例","title_tokens":["第一种","的","一种","第一","不","单例","加锁"]},{"location":"designpattern/singleInstance/#synchronized","text":"双重检测(double check lock)是为了b线程在a线程刚结束的临界点执行锁内任务，存在DCL失效问题 public class Singleton { private Singleton() {} //私有构造函数 private static Singleton instance = null; //单例对象 //静态工厂方法 public static Singleton getInstance() { if (instance == null) { //双重检测机制 synchronized (Singleton.class){ //同步锁 if (instance == null) { //双重检测机制 instance = new Singleton(); } } } return instance; } }","text_tokens":["构造","私有","new","检测","临界","class","lock","临界点","方法","singleton","synchronized","/","instance","锁","锁内","的","public","对象","getinstance","工厂","dcl","单例","构造函数","是","static","double","(","}","b","执行","=","同步","，",";"," ",".","if","在","双重","return","check","存在","null","a","任务",")","为了","线程","失效","函数","结束","{","静态","private","机制","刚","问题"],"title":"简单加上synchronized锁","title_tokens":["简单","锁","synchronized","加上"]},{"location":"designpattern/singleInstance/#_2","text":"JVM编译器有个指令重排的概念 * 什么是指令重排 java一个简单的instance = new instance()会被jvm编译成如下jvm指令 1. memory = allocate;分配对象的内存地址 2. creatinstance(memory);初始化对象 3. instance = memory设置instance指向刚分配的内存地址 但是这些指令顺序并非是一重不变，可能会经过jvm和cpu的优化，进行重排序 1.分配对象内存地址 3.设置instance指向刚分配的内存地址 2.初始化对象 当线程A执行完13的时候，线程B抢到资源，返回了一个还没有初始化完成的对象 * 如何避免以上问题？ 在instance对象前面增加一个volatile修饰符 public class Singleton { private Singleton() {} //私有构造函数 private volatile static Singleton instance = null; //单例对象 //静态工厂方法 public static Singleton getInstance() { if (instance == null) { //双重检测机制 synchronized (Singleton.class){ //同步锁 if (instance == null) { //双重检测机制 instance = new Singleton(); } } } return instance; } } volatile阻止了变量访问访问前后指令重排序，对于线程B来说，instance要么指向null，要么指向一个完整的instance,而不会出现中间状态 不仅可以防止指令重排，也可以保证线程访问的变量值是主内存种最新值，jdk1.6及以后才支持，每次均从主内存中读取，牺牲点效率，无伤大雅。","text_tokens":["私有","检测","这些","主","class","量值","allocate","资源","方法","指向","初始化","不会","instance","重排","如下","的","最新","工厂","概念","无伤大雅","一重","防止","设置","1","每次","及","creatinstance","3","返回","从主","jdk1.6","null",",","均","函数","并非","机制","构造","new","重","前面","*","有个","2","时候","public","不变","编译","单例","中间","出现","变量","是","还","static","(","访问","修饰","执行","牺牲","对于","顺序","if","。","会",")","前后","点","完整","来说","{","private","刚","但是","译成","指令","保证","可能","cpu","如何","内存","内存地址","？","singleton","种","经过","排序","锁","分配","getinstance","而","也","才","要么","优化","增加","}","jvm","b","以后","，","一个"," ",".","完成","不仅","什么","编译成","线程","初始","当","状态","静态","变量值","效率","抢到","问题","读取","编译器","java","完","synchronized","中","/","进行","对象","了","地址","memory","构造函数","没有","值","中间状态","无伤","13","volatile","可以","=","同步","阻止","以上",";","在","双重","和","return","a","被","简单","修饰符","大雅","避免","支持"],"title":"以上实现还是有问题 ，单例第三种写法","title_tokens":["写法","还是","第三","三种","单例","有","实现","以上","，"," ","问题","第三种"]},{"location":"designpattern/singleInstance/#_3","text":"静态内部类只会被加载一次，首次调用，顾线程安全，类加载初始化阶段是单线程的同时延迟了初始化。 类加载时机 1. new,involk static,putstatic,getstatic,指令时若类未加载则触发 2. 反射使用某个类时，若类未加载则触发 3. 子类加载时若父类未加载则触发 4. 程序开始时主方法所在类会被加载 静态内部类的懒加载应该属于第一种情况，为什么外部类加载时，内部类未加载，静态内部类只是刚好写在了另一个类里面，实际上和外部类没什么附属关系。 public class Singleton{ private SingleTon (){} private static class Holder{ //这里的私有没有什么意义 private static SingleTon instance = new Singleton(); } public static Singleton getInstance(){ return Holder.instance } }","text_tokens":["里面","类会","私有","延迟","类时","class","方法","初始化","某个","触发","instance","属于","的","只会","懒","holder","第一","刚好","1","调用","3","反射","情况","类未",",","一种","时","new","子类","时若","开始","意义","阶段","4","安全","2","另","加载","public","没什么","是","static","(","未","这里","时主","同时","写","。","时机","第一种","只是",")","外","{","private","指令","为什么","父类","内部","类","程序","singleton","顾","部类","getinstance","应该","实际上","附属","}","，","一个"," ","一次",".","什么","线程","则","初始","静态","首次","若类","involk","/","关系","了","时若类","实际","getstatic","单线","putstatic","没有","所在","=",";","在","和","return","被","使用","单线程"],"title":"静态内部类","title_tokens":["静态","类","内部"]},{"location":"designpattern/singleInstance/#_4","text":"//获得构造器 Constructor con = Singleton.class.getDeclaredConstructor(); //设置为可访问 con.setAccessible(true); //构造两个不同的对象 Singleton singleton1 = (Singleton)con.newInstance(); Singleton singleton2 = (Singleton)con.newInstance(); //验证是否是不同对象 System.out.println(singleton1.equals(singleton2)); 如何防止反射？ 使用枚举实现单例 public enum SingletonEnum { INSTANCE; } 使用枚举单例，不仅可以防止反序列化，而且可以保证枚举对象被反序列化的时候，返回的对象是同一个对象 public enum SingletonEnum { INSTANCE; public void doSomething(){ System.out.printLn(\"do something\"); } } public enum SingletonEnum{ PERSON; private Person person = null; private SingletonEnum(){ person = new Person(); } public Person getPerson(){ return person; } } public class Person{ }","text_tokens":["构造","newinstance","保证","con","枚举","两个","println","序列","void","{","如何","dosomething","class","可","\"","序列化","person","singleton","？","/","instance","的","时候","public","对象","getdeclaredconstructor","单例","同一","防止","设置","是","getperson","constructor","是否","out","(","}","访问","而且","singleton2","singletonenum","器","可以","=","是否是","返回","实现","不同","反射",";","."," ","验证","true","，","反","一个","同一个","do","new","return","null","获得","不仅","something",")","被","system","equals","为","使用","singleton1","private","enum","setaccessible"],"title":"如何通过反射打破单例模式，只能构建一个对象","title_tokens":["只能","一个","打破","对象","如何","模式","单例","，","构建","反射","通过"]},{"location":"designpattern/singleInstance/#_5","text":"public class A8PinPadManage { private A8PinPadManage(){} //私有构造函数 private volatile static Pinpad instance; //单例对象 public static Pinpad getInstance(Context context) { WeakReference<Context> contextWeakReference = new WeakReference<>(context); Context weakReferenceContext = contextWeakReference.get(); if (instance == null) { synchronized (A8PinPadManage.class) { if (instance == null) { instance = new Pinpad((int) SharedPrefsUtil.get(weakReferenceContext, CIL_KAP_ID, 2), \"IPP\"); } } } return instance; } } 解读 私有构造函数，全局只能构建一个对象，不能让随便的就去new,所以要私有 懒汉，单例刚开始没有构建，调用才构建 饿汉，调用new singleton主动构建，不需要判空 instance的初始值可以写成null或者new Singleton() 不加锁，线程不安全 不加双重验证直接锁getinstance方法，可以，增加内存开销，只用synchronize里面的判空，增加开销","text_tokens":["私有","里面","所以","class","pinpad","方法","加锁","instance","的","weakreferencecontext","开销","判空","调用","写成","构建","验证",">","null",",","context","sharedprefsutil","函数","只用","构造","只能","new","get","开始","随便","安全","2","public","去","contextweakreference","单例","static","加","weakreference","(","就","if","全局","要",")","{","饿汉","private","刚","synchronize","a8pinpadmanage","cil","\"","ipp","内存","singleton","锁","getinstance","才","增加","}","不能","kap","，","初始值","一个"," ","<",".","线程","初始","_","直接","解读","不","synchronized","主动","/","或者","对象","int","让","构造函数","没有","懒汉","需要","volatile","可以","=",";","双重","return","id"],"title":"防止内存泄漏单例","title_tokens":["内存","防止","泄漏","单例"]},{"location":"designpattern/singleInstance/#_6","text":"https://www.zhihu.com/search?type=content&q=%E5%8D%95%E4%BE%8B","text_tokens":["type","e4%","8b","content","q","/","search","https","zhihu","95%",":","&","=","com","%",".","www","be%","8d%","?","e5%"],"title":"参考  小灰漫画","title_tokens":[" ","小灰","漫画","参考"]},{"location":"things/algorithm/","text":"HashMap 概念 用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。 put方法原理 调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。 get方法 首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找 初始化长度 初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。 高并发下的HashMap Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap. 什么是ConcurrentHashMap？ ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。 put和get原理 get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash 红黑树 （数据结构） 二叉树的特性 1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树 红黑树特性 节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。 调整红黑树的两种方法（变色、旋转） AES算法（对称加密算法） MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。 三个基本概念（密钥、填充、模式） 密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。 在java中的具体实现 注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。 AES算法的底层原理 一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey） 字节替代 subByte 十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11] 行移位 shiftRows 如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节 列混淆MixColumns 输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列 加 论密钥(add round key) 128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。 不同工作模式在加密流程中有什么不同？ 所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度 MD5 可以从任意长度的明文字符串生成128位的哈希值 验签过程 1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制 MD5底层原理 分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c Base64 排序 冒泡算法和优化","text_tokens":["192bit","fix","下","两个","篡改","abcd","现象","这些","粒度","主","整数","解密","越来","接插","依次","sign","一组","原始","给定","负载","数倍","金额","重新","第一","概念","并行","链表","1","实践","细节","基本","缺点","有利","归纳","最高","位","w","换成","m16","累加","null","统计","各种","处理过程","0x76543210","第四行","有些","两次","额外","插入","get","并","之所以","一步","左移","有个","并发","subbytes","份","假设","键值","s","高度","处理","替代","因子","二叉树","盒","双方","右子","黄色","aes192","黑色","最","思想","同时","之后","00","中有","代替","目标","不止","发生变化","路径","只要","作用","知道","第三方","128bit","final","第三","定位","完整","默认","为","16x16","校验","随之","mj","保证","二块","数","新","几种","提供","四行","成一","n","既","本身","等于","真正","创造者","表","大于","分成","来","打折","增加","这个","次子","复杂","ade876ishdfakhdj","相乘","第一位","具体","左右","算法","有利于","<","两位","四种","vector","shiftrows","所","变化","m0","+","不断","大","组是","效率","resize","呢","绿色","直接","源代码","例","无法","方式","不","安全性","java","-","封装","/","进行","认为","数据结构","折扣","了","实际","、","上面","一等","&","|","同一","分段","或","高","尾端","32","一把","对","之间","只","组","缺少","不同","：","四步","优势","第","nopadding","被","代码","为了","调整","使用","字","第一个","得出","遇到","aes","量值","图中","不如","初始化","9","其它","典型","密文","带上","0x01234567","的","整数倍","数目","带","31","变色","下图","参数","块","取决","防止","设置","length","子","hashcode","后","达到","红黑树","事情","数值","超过","相当","必须","铭文","i","理过","mixcolumns","收集","树","cbc","底层","泄漏","演变","是非","技术","一共","向","情况","block",">","均","x","两种","私密","10","ecb2","原理","如果","函数","流程","只能","过程","一致性","原本","开始","175","平台","好","......","扩容","两件","256","0x89abcdef","”","步骤","找","根","多个","较差","加密","(","三种","7","例如","接收","\\","实现","完后","更高","。","计算","线性","平时","不足","字符","某种","位置","amout","beauty","加入","赋值","为什么","很","内部","环","如何","大家","可","\"","它","单","水线","到","流水线","size","锁","如图","addroundkey","#","当前","最大","过去","攻击","均匀分布","把","g","除了","个","优化","box","第三行","再","性能","要求","矩阵","表达","一位","成","subbyte","三个"," ","ctr","出","value","等同于","叫做","从","什么","一轮","当","结束","大小","[","_","作为","二进制","取决于","分布","子树","一段","后面","任一","总","-------------------------","64","第四","中","复杂度","index","next","让","initial","常量","结果","求余","越来越","第一步","输入","当于","值","特性","流水","13","顺着","=","原先","密码","修补","后续","1111","有限","0.75","孩子","那么","简单","loadfactor","映射","加解密","利用","最终","替换","获取","比如","concurrenthashmap","0","512","方法","指向","右","当新","可能性","5","由于","行","计算器","即","做","几位","属于","依据","进制","直到","遍历","许多","14","除去","m1","刚好","根据","互不干涉","拆分","k","整个","3","二维","md5","matrix","有点像","假定","排列","ki","输出",",","变成","参数值","重入","摘要","体现","次","h","aes128","明文","e","时","且","有","旧","包含","下面","关联","值补","最后","阶段","任意","）","尝试","2","64bit","~","另外","剩余","田","持有","整段","这","条件","cfb","表示","具体位置","数量","常用","那个","得到","有点","十六进制","采用","运算","是否","拼接","加","生成","账户","指针","从根","就","这里","5b","链接","对称","插法","反馈","基本概念","4x4","1001","electronoc","近似","几乎",")","替换成","java8","普通","哈希","独立","二级","起来","互不","subtitution","可能","数组","两倍","论","非线性","记录","128","经过","阈值","请求","一样","用","名","少于","codebook","ofb","约定","传输","节点","就是","也","混淆","0xfedcba98","发送","不能","第四个","b","加密算法","，","等同","一个","说",".","一次","前","]","完成","47","原来","操作","二个","存储","显然","共","用于","很多","round","官方","则","add","11","3029737","意思","优点","8","sha256","f","capacity","全为","将","对象","小于","完全","用到","（","创造","任何","bit","旋转","分组","所用","怎么","田字","需要","y","坏人","干涉","无误","覆盖","可以","随机","元素","修改","以上","排列成","rounds","同一个","和","多","a","j","主干","电码","等份","iv","12","同样","同于","相关","规则","列","二行","所以","iso126padding","左子","引入","这种","chaining","“","加锁","加轮","如下","完整性","加盐","按照","代表","首先","末尾","原文","二进制位","语言","一行","集合","hash","相应","叶子","连续","一致","即可","调用","红色","利于","第三个","拆","put","16","容量","pkcs5padding","所有","第一行","攻击者","验证","说明","一股","头","循环","长度","张图","c","参与","三方","取代","移位","相当于","m","走到","验签","二位","四个","^","数据","electronic","注意","命名","4","分别","安全","轮","通过","*","阻塞","决定","zegment","时候","第二行","是因为","segment","不变","字符串","难免","分散","解决","出现","结构","book","是","搞笑","产生","对比","aes256","最好","平衡","表面","chainning","key","算器","轮数","而是","列成","这样","会","要","都","生变","中当","可逆","信息","ff","keyexpentions","当中","读写","外","{","原","但是","左","一起","192","影响","查找","扩展","码本","101110001110101110","三步","mi","单次","只有","密钥","？","幂","交替","均匀","第二个","排序","加工","之一","次数",":","m15","字节","而","一个个","增长","entry","创建","工作","feedback","主体","宏观","上","向量","支付","6","加密器","}","每","其余","每个","差别","255","由","异或","并行计算","又","初始值","降低","因为","冲突","与","业务","限制","种子","使得","三行","第二","ecb","z","线程","1234","初始","空","十六","initialization","多少","问题","hashmap","模式","》","写入","匹配","五种","outputfeedback","大打折扣","上锁","分为","个个","acount","或者","电码本","相同","直接插入","打折扣","填充","counter","rehash","一直","没有","冒泡","体位","签名","一股脑","十进制","二叉","二分","补全","主要","第二块","d","补足","448","cipher","在","不是","发生","释放","前会","向下","相加","15","160","难免会","base64","对应","一列","支持"],"title":"Algorithm","title_tokens":["algorithm"]},{"location":"things/algorithm/#hashmap","text":"","text_tokens":[],"title":"HashMap","title_tokens":["hashmap"]},{"location":"things/algorithm/#_1","text":"用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。","text_tokens":["数组","这些","get","-","方法","中","）","的","键值","（","分散","常用","就是","也","集合","entry","是","(","这个","对","每","key","put","最","元素","，","初始值","一个"," ","。","在","和","存储","都","value","null",",","用于","主干","叫做",")","初始","hashmap"],"title":"概念","title_tokens":["概念"]},{"location":"things/algorithm/#put","text":"调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。","text_tokens":["遇到","下","现象","0","越来","接插","指向","当新","可能性","“","的","链表","hashcode","1","后","红黑树","即可","调用","超过","put","头","假定","长度",",","变成","时","插入","最后","通过","2","”","难免","出现","是","采用","(","指针","key","插法","。","不止","会","中当",")","java8","为","位置","beauty","但是","查找","可能","数组","\"","它","到","size","创造者","节点","entry","每","，","一个","."," ","冲突","大","当","直接","hashmap","8","-","认为","index","对象","直接插入","next","创造","&","越来越","得出","可以","=","元素","：","多","被","难免会","对应"],"title":"put方法原理","title_tokens":["原理","方法","put"]},{"location":"things/algorithm/#get","text":"首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找","text_tokens":["可能","-","匹配","到","做","size","的","时候","首先","index","&","找","得到","根据","同一","多个","hash","链表","输入","entry","hashcode","1","节点","需要","上","(","这个","key","顺着","=","，","一个"," ","一次",".","头","同一个",",","向下",")","位置","映射","有","hashmap"],"title":"get方法","title_tokens":["get","方法"]},{"location":"things/algorithm/#_2","text":"初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。","text_tokens":["3029737","下","例","101110001110101110","两个","二进制","取决于","所以","后面","这种","-","-------------------------","最后","幂","初始化","9","其它","hash","做","均匀","size","几位","2","进制","的","全为","index","同于","本身","二进制位","结果","&",":","取决","book","是","增长","length","或","hashcode","1","值","运算","后","输入","(","十进制","就是","3","key","16","=","，","以上","等同","算法"," ",".","。","1001","计算","只要","情况","长度","与",",","1111","等同于",")","15","函数","初始","为","哈希","对应","hashmap"],"title":"初始化长度","title_tokens":["初始化","长度","初始"]},{"location":"things/algorithm/#hashmap_1","text":"Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap.","text_tokens":["规则","下","concurrenthashmap","方法","做","如下","的","负载","链表","hash","达到","1","后","事情","容量","是非","情况","长度",">","安全","*","并发","扩容","2","两件","时候","条件","解决","那个","出现","是","因子","是否","(","。","发生变化","计算","会","要","生变",")","默认","随之","为什么","可能","环","数组","两倍","如何","新","？","幂","size","当前",":","也","创建","，","."," ","原来","因为","变化","什么","线程","resize","hashmap","f","capacity","进行","index","了","rehash","需要","=","：","在","发生","有限","0.75","loadfactor","使用"],"title":"高并发下的HashMap","title_tokens":["的","下","并发","高","hashmap"]},{"location":"things/algorithm/#concurrenthashmap","text":"ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。","text_tokens":["互不","影响","保证","粒度","concurrenthashmap","如何","它","？","写入","安全","阻塞","上锁","并发","锁","zegment","的","了","segment","持有","让","怎么","表","同一","就是","是","hash","搞笑","采用","当于","分段","需要","相当","一把","每个","之间","同时","又","实现","，","一个","技术"," ","降低","更高","。","优势","同一个","操作","都","读写","相当于","线程","效率","独立","二级"],"title":"什么是ConcurrentHashMap？","title_tokens":["concurrenthashmap","什么","是","？"]},{"location":"things/algorithm/#putget","text":"get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash","text_tokens":["获取","concurrenthashmap","方法","加锁","做","的","遍历","重新","hash","1","超过","3","put","所有","说明","累加",",","统计","重入","原理","如果","时","两次","过程","插入","get","通过","尝试","segment","具体位置","数量","得到","运算","是否","key","实现","中有","计算","定位","位置","起来","数组","可","到","均匀","size","阈值","锁","次数","entry","大于","均匀分布","上","把","每","再","具体","，","一个"," ",".","一次","+","则","结束","分布","总","中","进行","或者","将","对象","了","输入","没有","值","体位","对","覆盖","元素","修改","在","不是","释放","为了"],"title":"put和get原理","title_tokens":["和","get","put","原理"]},{"location":"things/algorithm/#_3","text":"","text_tokens":[],"title":"红黑树  （数据结构）","title_tokens":["红黑树","数据结构","数据","（","结构"," ","）"]},{"location":"things/algorithm/#_4","text":"1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树","text_tokens":["利用","左子","这种","方法","右","依次","5","由于","9","如下","的","1","红黑树","缺点","3","树","所有","均","变成","10","走到","插入","开始","4","分别","2","找","解决","根","高度","是","二叉树","右子","平衡","从根","就","思想","几乎","线性","为","左","查找","如何","它","？","排序","次数","等于","最大","节点","也","大于","打折","6","性能","左右","，","."," ","结束","11","例","子树","8","不","大打折扣","或者","折扣","小于","相同","了","打折扣","、","值","13","二叉","二分","：","孩子"],"title":"二叉树的特性","title_tokens":["特性","二叉","的","二叉树"]},{"location":"things/algorithm/#_5","text":"节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。","text_tokens":["两个","包含","任一","到","的","或者","数目","相同","根","节点","是","子","叶子","连续","(","红色","不能","每个","黑色","所有"," ","。","路径","都","null",")","从","空","有"],"title":"红黑树特性","title_tokens":["特性","红黑树"]},{"location":"things/algorithm/#_6","text":"","text_tokens":[],"title":"调整红黑树的两种方法（变色、旋转）","title_tokens":["红黑树","的","变色","两种","（","、","调整","方法","旋转","）"]},{"location":"things/algorithm/#aes","text":"MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。","text_tokens":["保证","一致性","不","sha256","属于","完整性","的","进行","是","一致","加密","对","加密算法","主要","md5","对称","，","泄漏","算法","。","作用","和","可逆","信息","摘要","被","私密","完整","校验"],"title":"AES算法（对称加密算法）","title_tokens":["aes","加密","（","加密算法","对称","算法","）"]},{"location":"things/algorithm/#_7","text":"密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。","text_tokens":["aes","192bit","最终","这些","iso126padding","整数","解密","5","chaining","典型","其它","计算器","密文","做","的","整数倍","数倍","许多","末尾","块","语言","相应","后","1","细节","拆分","整个","拆","必须","铭文","3","最高","理过","16","cbc","位","pkcs5padding","一股","长度","block","输出",",","c","处理过程","体现","aes128","明文","如果","e","时","且","有些","过程","electronic","注意","并","最后","4","安全","有个","）","64bit","2","时候","256","整段","cfb","数量","book","处理","是","采用","拼接","aes256","加密","生成","最好","(","就","aes192","三种","轮数","7","思想","链接","\\","算器","而是","反馈","中有","。","计算","近似","128bit","平时",")","不足","独立","默认","字符","{","为","某种","但是","一起","192","加入","码本","可能","大家","二块","只有","数","密钥","？","几种","提供","成一","经过","用","#","等于","少于","codebook",":","ofb","字节","就是","一个个","也","工作","feedback","分成","主体","上","把","g","这个","加密器","个","}","6","性能","每个","复杂","要求","b","加密算法","差别","成","，","一个","说"," ","算法","ctr","第二","ecb","从","什么","则","问题","例","8","模式","一段","不","安全性","方式","outputfeedback","五种","中","个个","进行","电码本","了","相同","实际","填充","、","任何","（","结果","分组","counter","尾端","值","需要","一股脑","对","之间","补全","缺少","随机","第二块","d","补足","不同","：","密码","cipher","在","不是","a","nopadding","电码","使用","128","同样","支持"],"title":"三个基本概念（密钥、填充、模式）","title_tokens":["基本","填充","（","、","模式","概念","密钥","三个","基本概念","）"]},{"location":"things/algorithm/#java","text":"注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。","text_tokens":["aes","注意","解密","原本","封装","密钥","整数","方式","并","好","其它","一组","的","整数倍","数倍","填充","真正","块","字节","就是","上","调用","表面","生成","除了","key","16","，","算法","：","而是","。","不是","会","长度","都","用于","种子","nopadding","明文","如果","时","使用","外","加解密","额外"],"title":"在java中的具体实现","title_tokens":["的","java","具体","实现","中","在"]},{"location":"things/algorithm/#aes_1","text":"一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey）","text_tokens":["aes","列","最终","两个","0","行","加轮","密文","进制","如下","的","14","除去","刚好","1","mixcolumns","位","长度",",","各种","次","移位","10","明文","aes128","有","四个","阶段","轮","）","subbytes","~","步骤","表示","十六进制","处理","加密","aes256","(","aes192","key","轮数","而是","00","代替","。","ff",")","final","普通","论","可","只有","密钥","？","经过","n","addroundkey","字节","也","混淆","把","255","由","成","具体","，","一个","三个"," ","一次","shiftrows","round","很多","初始","十六","多少","》","initial","（","需要","不同","：","rounds","不是","12","对应"],"title":"AES算法的底层原理","title_tokens":["aes","的","底层","原理","算法"]},{"location":"things/algorithm/#subbyte","text":"十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11]","text_tokens":["subtitution","替换","数组","5","中","通过","依据","2","进制","的","另外","[","步骤","常量","第一","s","块","字节","大小","就是","处理","替代","是","十六进制","盒","值","把","(","每","box","b","二维","5b","=","例如","位","，","排列成","一个","列成","换成"," ","4x4","。","在","]","两位","排列","都","输出",",","a","那么","被","替换成",")","明文","十六","第一个","16x16","11","二位"],"title":"字节替代 subByte","title_tokens":["字节","subbyte"," ","替代"]},{"location":"things/algorithm/#shiftrows","text":"如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节","text_tokens":["两个","二行","第四","四行","左移","如图","第二行","不变","第一","字节","一行","第三行","第一行","一个","："," ","三个","循环","三行","第二","第三","第四行"],"title":"行移位 shiftRows","title_tokens":[" ","shiftrows","行","移位"]},{"location":"things/algorithm/#mixcolumns","text":"输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列","text_tokens":["fix","列","数组","做","的","常量","得到","输入","(","每","矩阵","相乘","matrix","，","一个"," ","和","要","修补","输出",")","明文","对应","一列","二位"],"title":"列混淆MixColumns","title_tokens":["混淆","列","mixcolumns"]},{"location":"things/algorithm/#add-round-key","text":"128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。","text_tokens":["aes","最终","0","做","原始","的","直到","31","1","k","i","16","w","所有","排列","长度","输出",",","10","175","4","轮","......","*","）","2","是","处理","加密","生成","(","就","列成","4x4","。","计算","都","128bit","keyexpentions","当中",")","为","{","位置","赋值","扩展","数组","密钥","到","用","字节","而","来","}","每","b","异或","由","矩阵","，","等同","一个"," ","一次","]","完成","47","与","存储","用于","+","等同于","一轮","初始","[","源代码","-","中","了","用到","（","一直","输入","值","32","元素","排列成","不同","同样","和","第","后续","a","j","被","代码","15","160","对应","同于"],"title":"加 论密钥(add round key)","title_tokens":["加","(","论","round","key",")","密钥","add"," "]},{"location":"things/algorithm/#_8","text":"所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度","text_tokens":["aes","引入","不如","即","初始化","密文","做","加盐","的","第一","并行","概念","块","互不干涉","防止","1","利于","有利","缺点","cbc","md5","所有","有点像","block",",","变成","参与","体现","ecb2","明文","流程","关联","安全","2","有点","较差","book","处理","是","加密","(","chainning","最","更高","。","这样","计算","作用","会","electronoc","都",")","独立","互不","内部","经过","一样","codebook",":","工作","向量","宏观","上","增加","加密器","每","性能","差别","并行计算","异或","复杂","成","，","一个","有利于"," ",".","前","出","操作","与","vector","所","显然","ecb","初始","initialization","作为","优点","无法","模式","不","安全性","复杂度","完全","相同","了","让","值","干涉","之间","只","：","cipher","在","和","后续","前会","简单","iv","第一个","同样"],"title":"不同工作模式在加密流程中有什么不同？","title_tokens":["加密","模式","什么","？","不同","流程","中有","工作","在"]},{"location":"things/algorithm/#md5","text":"可以从任意长度的明文字符串生成128位的哈希值","text_tokens":["值","长度","的","生成","可以","从","明文","字符串","位","哈希","字符","128","任意"],"title":"MD5","title_tokens":["md5"]},{"location":"things/algorithm/#_9","text":"1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制","text_tokens":["相关","规则","利用","两个","篡改","abcd","所以","比如","5","sign","带上","做","给定","进制","的","按照","带","金额","原文","参数","hash","1","后","数值","基本","3","收集","位","md5","攻击者","验证","参与","参数值","三方","如果","时","只能","平台","之所以","4","*","通过","2","时候","是因为","字符串","十六进制","是","双方","账户","拼接","对比","生成","这里","key","同时","接收","目标","无误","。","知道","第三方","信息","第三","amout","字符","哈希","起来","三步","可能","如何","密钥","？","到","请求","既","本身","名","最大",":","约定","传输","就是","也","过去","攻击","来","支付","把","除了","上","发送","ade876ishdfakhdj","成","又","，","一个","算法","."," ","因为","限制","业务","从","1234","则","十六","_","直接","二进制","不","acount","相同","了","值","需要","32","签名","坏人","只","=","不同","在","和","128"],"title":"验签过程","title_tokens":["验签","过程"]},{"location":"things/algorithm/#md5_1","text":"分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c","text_tokens":["abcd","主","0","512","量值","整数","方法","图中","5","“","一组","0x01234567","进制","如下","的","按照","代表","首先","数倍","原文","整数倍","下图","第一","m1","设置","子","1","后","实践","常量","第三个","红色","归纳","i","3","演变","16","位","md5","一共","向","m16","循环","长度","ki",",","张图","c","取代","次","x","0x76543210","h","如果","m","函数","流程","有","四个","旧","包含","^","下面","命名","值补","最后","4","一步","左移","*","）","决定","份","2","~","假设","剩余","0x89abcdef","田","”","这","s","得到","十六进制","处理","是","产生","拼接","(","黄色","就","最","之后","完后","这样","。","计算","会","都","信息","线性",")","第三","哈希","为","位置","原","mj","很","mi","单次","非线性","记录","新","？","单","水线","到","经过","交替","第二个","流水线","加工","n","之一","次数","用","等于","真正","m15","就是","也","分成","0xfedcba98","把","其余","次子","g","每","第四个","再","b","复杂","每个","由","表达","一位","第一位","，","初始值","一个","三个","."," ","一次","四种","二个","<","所","共","使得","+","不断","官方","第二","m0","z","组是","初始","十六","呢","绿色","多少","意思","二进制","不","-","64","f","第四","中","/","分为","进行","了","用到","填充","（","让","上面","、","结果","bit","求余","分组","所用","&","|","田字","一等","第一步","值","流水","需要","y","32","对","组","可以","=","原先","d","不同","：","448","四步","在","和","a","等份","简单","相加","使用","字","128","第一个"],"title":"MD5底层原理","title_tokens":["底层","md5","原理"]},{"location":"things/algorithm/#base64","text":"","text_tokens":[],"title":"Base64","title_tokens":["base64"]},{"location":"things/algorithm/#_10","text":"","text_tokens":[],"title":"排序","title_tokens":["排序"]},{"location":"things/algorithm/#_11","text":"","text_tokens":[],"title":"冒泡算法和优化","title_tokens":["算法","和","优化","冒泡"]},{"location":"things/cutline/","text":"分割线使用三个或以上 * ，也可以使用 - 和 _ ，下面仅以 - 作为示例 --- 效果","text_tokens":["割线","下面","分割线","仅以","分割","-","*","效果","也","或","示例","可以","以上","，","三个"," ","---","和","使用","_","作为"],"title":"Cutline","title_tokens":["cutline"]},{"location":"things/main/","text":"由于语法众多，因此将 大部分语法 汇总在下面表格里，便于一览。 但该表并未涵盖全部语法(如某些特殊符号) ，因此详情请翻看语法的具体章节。 符号 用途 # 标题 空行 段落 > 引用 [^sth] 脚注 !!! 注解 ??? 折叠注解 \\ 转义 * 列表 + 列表 - 列表 *[x] 任务列表 +[x] 任务列表 -[x] 任务列表 --- 分割线 :shortname: emoji ` 行内代码 ```语言 代码块,带高亮 TAB 代码块 #! 代码高亮 ::: 代码高亮 *sth* 斜体 _sth_ 斜体 **sth** 粗体 __sth__ 粗体 ***sth*** 粗斜体 ___sth___ 粗斜体 \\^sth\\^ 上标 \\~sth\\~ 下标 \\^\\^sth\\^\\^ 文字下划线 \\~\\~sth\\~\\~ 文字中横线 {++sth++} 文字下划线,绿色背景高亮 {--sth--} 文字中横线,红色背景高亮 {\\~\\~false\\~>true\\~\\~} 文字下划线接文字横线,绿接红背景高亮 {>>sth<<} 表示注解,灰色背景高亮 \\=\\=sth\\=\\= 黄色背景高亮 {\\=\\=sth\\=\\=} 黄色背景高亮 \\$sth$ 行内式数学公式 \\(sth)\\ 行内式数学公式 \\$\\$...$$ 区块式数学公式 \\begin{}...\\end{} 区块式数学公式 [text](url \"title\") 行内式链接 [text][index],文档最后[index]: url \"title\" 参考式链接 符合要求的URL 自动链接 ![alt](url \"title\") 行内式图片 ![alt][index],文档最后[index]: url \"title\" 参考式图片","text_tokens":["alt","详情","章节","begin","分割线","由于","下标","的","特殊","tab","块","语言","语法","红色","带高亮","高亮","下划线","折叠","空行","$","emoji",">",",","下划","接","x","式","因此","!","参考","text","割线","^","下面","上标","分割","用途","最后","*","~","如","___","end","引用","sth","表示","里","shortname","符合要求","便于","(","黄色","行内","链接","\\","区块","灰色","。","一览","`","斜体",")","某些","__","{","脚注","title","\"","大部分","划线","部分","粗","粗体","#","...","公式",":","false","符号","段落","}","++","要求","翻看","具体","，"," ","<","]","true","---","转义","列表","绿接","数学","+","--","符合","全部","?","注解","[","_","绿色","url","特殊符号","详情请","表格","汇总","-","标题","中","将","index","自动","红","但","涵盖","背景","众多","大部","图片","=","在","文字","数学公式","任务","代码","并未","该表","横线","文档"],"title":"Main","title_tokens":["main"]},{"location":"things/things/","text":"this is interesting things dadadada dididididi","text_tokens":["interesting","things","dididididi","dadadada","this","is"," "],"title":"Things","title_tokens":["things"]},{"location":"things/things/#dadadada","text":"","text_tokens":[],"title":"dadadada","title_tokens":["dadadada"]},{"location":"things/things/#dididididi","text":"","text_tokens":[],"title":"dididididi","title_tokens":["dididididi"]}]}