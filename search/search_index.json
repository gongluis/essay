{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to LuisDocs 本模块介绍 词 一盏离愁孤单伫立在窗口，我在门后假装你人还没走。 旧地如重游，月圆更寂寞。 夜半清醒的烛火不忍苛责我。 一壶漂泊 浪迹天涯难入喉 你走之后 酒暖回忆思念瘦 水向东流 时间怎么偷 花开就一次成熟我却错过 -jay chou 2. 曲3 本模块说明 一路向北 听爸爸的话 本模块声明 hi hello","text_tokens":["离愁","一盏","没","烛火","就","向东","假装","夜半","天涯","向北","曲","一路","的","旧地","偷","本","一次","喉"," ","。","-","门","错过","你","月","hello","思念","浪迹","漂泊","模块","瘦","2","水","不忍","爸爸","在","寂寞","孤单","jay","还","一壶","酒暖","听","却","花开","声明","怎么",".","词","如","hi","东流","重游","，","to","说明","welcome","之后","伫立","人","我","苛责","向东流","圆","窗口","3","成熟","chou","回忆","luisdocs","时间","浪迹天涯","走","难入","清醒","更","介绍","后","的话"],"title":"介绍","title_tokens":["介绍"]},{"location":"#welcome-to-luisdocs","text":"","text_tokens":[],"title":"Welcome to LuisDocs","title_tokens":["welcome"," ","luisdocs","to"]},{"location":"#_1","text":"词 一盏离愁孤单伫立在窗口，我在门后假装你人还没走。 旧地如重游，月圆更寂寞。 夜半清醒的烛火不忍苛责我。 一壶漂泊 浪迹天涯难入喉 你走之后 酒暖回忆思念瘦 水向东流 时间怎么偷 花开就一次成熟我却错过 -jay chou 2. 曲3","text_tokens":["门","之后","离愁","还","你","一壶","错过","一盏","没","月","烛火","酒暖","伫立","人","思念","我","向东","浪迹","花开","就","却","假装","苛责","向东流","漂泊","怎么","瘦","圆","窗口",".","夜半","天涯","词","如","3","2","曲","成熟","chou","的","旧地","回忆","水","时间","东流","不忍","偷","重游","浪迹天涯","一次","走","难入","清醒","在","更","喉","，"," ","。","寂寞","-","孤单","后","jay"],"title":"本模块介绍","title_tokens":["介绍","本","模块"]},{"location":"#_2","text":"一路向北 听爸爸的话","text_tokens":["爸爸"," ","的话","听","向北","一路"],"title":"本模块说明","title_tokens":["说明","本","模块"]},{"location":"#_3","text":"hi hello","text_tokens":["hi","hello"," "],"title":"本模块声明","title_tokens":["声明","本","模块"]},{"location":"algorithm/","text":"HashMap 概念 用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。 put方法原理 调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。 get方法 首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找 初始化长度 初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。 高并发下的HashMap Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap. 什么是ConcurrentHashMap？ ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。 put和get原理 get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash 红黑树 （数据结构） 二叉树的特性 1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树 红黑树特性 节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。 调整红黑树的两种方法（变色、旋转） AES算法（对称加密算法） MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。 三个基本概念（密钥、填充、模式） 密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。 在java中的具体实现 注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。 AES算法的底层原理 一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey） 字节替代 subByte 十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11] 行移位 shiftRows 如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节 列混淆MixColumns 输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列 加 论密钥(add round key) 128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。 不同工作模式在加密流程中有什么不同？ 所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度 MD5 可以从任意长度的明文字符串生成128位的哈希值 验签过程 1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制 MD5底层原理 分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c Base64 排序 冒泡算法和优化","text_tokens":["遍历","结束","：","5","发生变化","覆盖","13","pkcs5padding","加盐","摘要","接插","最后","数据结构","具体位置","只能","m","最大","原理","混淆","m1","可能","总","叶子","electronoc","处理","被","14","使用","对","有限","那么","二分","第三行","或者","封装","相关","第三方","bit","一次","命名","不止","最好","第一个","代表","作用","几位","写入","/","问题","均匀","chainning","mi","轮","不同","这些","加密器","电码","由","传输","0x89abcdef","单","后面","就是","nopadding","既","除去","语言","完后","十进制","防止","份","数据","显然","一个个","用到","优点","^","生成","目标","随机","ff","初始化","只","7","aes128","水线","get","把","列","多个","原始","决定","一股脑","用于","键值","进制","4x4","0xfedcba98","表","chaining","变成","[","如果","只要","主体","多","c","1","12","keyexpentions","outputfeedback","哈希","是非","累加","典型","大于","红黑树","阻塞","怎么","四步","\"","黑色","则",".","一步","算法","z","共","本身","认为","参与","数量","平台","并行计算","y","当前","cipher","提供","这样","校验","64","田","0x01234567",":","同一个","向下","二维","带","第四行","四种","之后","主","到","所有","差别","取决","结果","修改","对称","拆分","-------------------------","f","账户","按照","并行","得出","基本概念","beauty","x","黄色","两个","说","一起","第三","都","出现","包含","旋转","每个","除了","替代","顺着","次数","起来","完成","zegment","左右","开始","官方","00","限制","从根","其余","二叉树","独立","相乘","数倍","底层","真正","求余","等同于","扩容","扩展","位","两种","box","经过","一个","依据","左移","value","设置","一段","映射","addroundkey","ecb","0x76543210","增长","10","记录","1111","个个","安全性","无法","i","32","不足","一列","越来","模式","影响","是否","直接插入","segment","block","业务","不能","之一","16x16","支付","第四","拆","和","补足","较差","剩余","16","轮数","不如","替换成","192bit","复杂度","）","二块","-","更高","子","依次","当于","192","{","了","当","*","作为","对应","新","相加","subbyte","约定","128bit","一行","反馈","创造","子树","二进制位","那个","填充","末尾","给定","解密","移位","原","输出","整段","448","3029737","安全","原文","需要","capacity","~","优势","ki","田字","打折扣","每","过程","前会","互不","无误","中","幂","sha256","额外","四行","java","对比","补全","a","=","分为","即","有利于","二个","主要","数值","从","如下","用","以上","组是","支持","插法","常量","验签","五种","256","第一","一股","成","缺少","或","有点像","攻击者","第","各种","因为","分组","加","有利","加密","matrix","完全","所","hashcode","找","保证","加轮","null","具体","d","三行","多少","排列成","环","一致性","三种","而是","外","调用","非线性","m16","归纳","走到","5b","假设","同样","值补","(","出","头","size","让","可","常用","？","码本","组","subbytes","因子","种子","key","hash","调整","counter","密钥","呢","是","结构","final","加工",")","3","下","加入","叫做","左子","代码","右","下图","锁","实际","一等","表面","知道","次子","cbc","函数","字符","高",">","达到","大小","ecb2","异或","同一","同时","连续","后","64bit","规则","m15","拼接","变化","初始","引入","ade876ishdfakhdj","次","三步","默认","例","简单","变色","可以","next","<","原先","initial","验证","没有","接收","替换","concurrenthashmap","aes192","如何","例如","255","它","特性","上","超过","大家","右子","分段","abcd","iv","链接","hashmap","平时","mixcolumns","8","二进制","分布","一共","ofb","0.75","块"," ","。","解决","取决于","处理过程","签名","上面","与","步骤","算器","成一","负载","必须","近似","首先","15","很","盒","一致","acount","最终","即可","第一位","几乎","有个","如图","排列","第一行","但是","创造者","index","数","第一步","很多","随之","演变","}","m0","字符串","密码","获取",",","分散","电码本","j","\\","只有","47","initialization","进行","一把","信息","循环","输入","尝试","shiftrows","金额","绿色","在","resize","阈值","密文","有些","任意","两件","读写","个","等于","行","链表","其它","160","两次","101110001110101110","上锁","尾端","持有","集合","刚好","二行","对象","所以","宏观","aes256","位置","空","高度","完整","这里","方式","fix","length","根","单次","要","性能","可逆","小于","元素","”","（","平衡","#","比如","铭文","请求","流水线","细节","字","重新","几种","第二行","不是","均","11","使得","entry","round","完整性","，","初始值","会","electronic","三个","+","参数","左","175","值","论","交替","所用","也","最","互不干涉","理过","当新","降低","利用","相应","_","许多","由于","java8","任何","赋值","冲突","发送","表达","4","换成","量值","为什么","搞笑","篡改","rounds","大","体现","前","这个","产生","均匀分布","1001","中有","vector","难免","并发","一位","w","双方","攻击","根据","计算器","指针","这","g","原本","1234","收集","add","越来越","好","优化","字节","可能性","9","泄漏","]","就","现象","loadfactor","大打折扣","相当","整个","sign","数组","粒度","rehash","定位","之所以","第二个","的","put","128","加锁","第二","不变","折扣","n","有","二位","条件","全为","释放","排序","subtitution","&","概念","指向","原来","内部","不断","加解密","再","后续","带上","生变","路径","重入","时候","少于","通过","容量","一样","运算","同于","要求","iso126padding","而","......","线性","相当于","、","代替","十六","孩子","amout","参数值","复杂","向","实践","下面","插入","矩阵","2","两位","操作","普通","另外","之间","二级","注意","存储","一轮","流程","查找","任一","树","取代","分成","什么","缺点","干涉","旧","二叉","整数倍","不","k","采用","难免会","源代码","向量","关联","十六进制","为","h","来","md5","阶段","512","明文","feedback","0","红色","最高","线程","数目","四个","mj","第二块","一直","增加","中当","》","将","创建","book","发生","做","列成","节点","实现","第四个","aes","名","私密","流水","得到","这种","等同","相同","6","情况","又","遇到","表示","某种","一组","体位","整数","e","分别","统计","cfb","|","有点","说明","思想","时","31","事情","属于","两倍","张图","修补","codebook","方法","直到","技术","是因为","三方","过去","冒泡","加密算法","ctr","匹配","b","当中","图中","长度","s","主干","base64","基本","等份","直接","且","工作","坏人","第三个","并","意思","假定","打折","计算","效率","为了","“","利于"],"title":"算法","title_tokens":["算法"]},{"location":"algorithm/#hashmap","text":"","text_tokens":[],"title":"HashMap","title_tokens":["hashmap"]},{"location":"algorithm/#_1","text":"用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。","text_tokens":["一个","(","value","也","最","常用","集合","就是","key","方法","都","数组","是",")","主干","元素","（","的",",","每","叫做","put","这个","存储","分散","对","null","和","中","hashmap","在","get","entry","，","）","初始值","。","用于","键值","-"," ","这些","初始"],"title":"概念","title_tokens":["概念"]},{"location":"algorithm/#put","text":"调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。","text_tokens":["一个","越来越","：","可以","next","可能性","现象","接插","最后","越来","数组","它","直接插入","超过","可能","的","put","被","hashmap","不止","8"," ","。","&","-","指向","当","对应","创造","通过","即可","但是","创造者","index","插入","2",",","每","查找","=","采用","难免会","链表","变成","为","多","插法","1","对象","0","位置","红黑树","中当","\"",".","元素","”","hashcode","认为","节点","遇到","entry","，","调用","会","时","(","头","size","到","当新","java8","key","得出","beauty","冲突","是","出现","长度",")","下","大","直接","难免","假定","后","指针","“"],"title":"put方法原理","title_tokens":["原理","put","方法"]},{"location":"algorithm/#get","text":"首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找","text_tokens":["一个","(","头","映射","size","到","时候","1","首先","key","hash","位置","index","匹配",".","需要",")","上","做","hashcode","找","可能","的",",","顺着","节点","这个","hashmap","一次","得到","输入","entry","有","，","多个"," ","=","&","-","同一","同一个","根据","向下","链表"],"title":"get方法","title_tokens":["get","方法"]},{"location":"algorithm/#_2","text":"初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。","text_tokens":["为","(","101110001110101110","以上","只要","size","例","1","后面","9","增长","15","结果","1111","运算","取决","二进制位","同于","就是","-------------------------","哈希","所以","key","hash","十进制","3029737","最后","或","两个","index",".","length","是","算法","长度",")","book","2","3","下","做","hashcode","对应","本身",",","的","幂","1001","16","hashmap","初始化","这种","等同","输入","情况","函数","二进制","几位","，","等同于","全为"," ","=","&","-",":","计算","进制","后","均匀","。","取决于","值","初始","与","其它"],"title":"初始化长度","title_tokens":["初始","初始化","长度"]},{"location":"algorithm/#hashmap_1","text":"Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap.","text_tokens":["：","默认","发生变化","loadfactor","concurrenthashmap","如何","数组","是否","rehash","可能","的","使用","有限","hashmap","条件","0.75"," ","。","原来","解决","了","*","新","生变","负载","时候","容量","那个","安全","需要","capacity","index","2","随之","幂","进行","在","什么","resize","=","两件","链表","如下","1","线程","是非",".","创建","因为","发生","要","做","当前","情况","环","，","会",":","(","也","事情","size","？","两倍","因子","f","方法","hash","是","出现","长度",")","下","为什么","并发",">","达到","计算","扩容","后","规则","变化"],"title":"高并发下的HashMap","title_tokens":["的","高","hashmap","并发","下"]},{"location":"algorithm/#concurrenthashmap","text":"ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。","text_tokens":["一个","上锁","让","持有","？","就是","降低","线程","hash","技术","安全","相当于","阻塞","怎么","concurrenthashmap","相当","需要","如何","影响","是","都","它","优势","粒度","segment","每个","分段","搞笑","操作","的","实现","之间","二级","zegment","保证","互不","锁","一把","并发","独立","又","写入","，"," ","。","同一","效率","同时","同一个","更高","读写","当于","了","采用","表"],"title":"什么是ConcurrentHashMap？","title_tokens":["concurrenthashmap","是","什么","？"]},{"location":"algorithm/#putget","text":"get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash","text_tokens":["遍历","一个","结束","覆盖","没有","concurrenthashmap","具体位置","数组","是否","segment","上","定位","超过","原理","总","的","put","加锁","对","或者","一次","分布","释放"," ","均匀","了","再","重入","通过","运算","插入","获取",",","每","过程","中","进行","输入","尝试","在","get","把","阈值","两次","如果","1","对象","累加","大于","位置","则","将",".","元素","做","实现","数量","具体","重新","得到","不是","entry","，","体位","统计","+","说明","值","时","size","到","可","所有","修改","key","方法","hash","3","次数","起来","均匀分布","锁","中有","计算","为了"],"title":"put和get原理","title_tokens":["原理","和","put","get"]},{"location":"algorithm/#_3","text":"","text_tokens":[],"title":"红黑树  （数据结构）","title_tokens":["（","红黑树","数据结构","）"," ","结构","数据"]},{"location":"algorithm/#_4","text":"1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树","text_tokens":["结束","：","5","例","13","9","10","就","大打折扣","如何","最大","它","右子","的","二分","或者","折扣","8","排序"," ","解决","依次","了","子树","线性","几乎","、","孩子","插入","2","打折扣","查找","树","缺点","二叉","不","等于","变成","如下","为","1","大于","红黑树","高度",".","根","性能","小于","找","平衡","节点","6","这种","相同","均","11","，","分别","走到","左","值","思想","也","所有","？","利用","由于","方法","是","4","3","次数","左子","左右","开始","右","从根","二叉树","打折"],"title":"二叉树的特性","title_tokens":["二叉树","的","特性","二叉"]},{"location":"algorithm/#_5","text":"节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。","text_tokens":["路径","(","到","所有","红色","数目","空","黑色","两个","是","根","都",")","包含","每个","不能","叶子","节点","的","null","或者","任一","相同","有"," ","。","子","连续","从"],"title":"红黑树特性","title_tokens":["特性","红黑树"]},{"location":"algorithm/#_6","text":"","text_tokens":[],"title":"调整红黑树的两种方法（变色、旋转）","title_tokens":["（","调整","的","红黑树","、","）","变色","两种","旋转","方法"]},{"location":"algorithm/#aes","text":"MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。","text_tokens":["属于","md5","对称","泄漏","一致","摘要","加密算法","完整","是","算法","加密","可逆","的","保证","被","对","和","私密","sha256","信息","进行","校验","一致性","作用","完整性","，","。","不","主要"],"title":"AES算法（对称加密算法）","title_tokens":["（","aes","加密算法","）","对称","算法","加密"]},{"location":"algorithm/#_7","text":"密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。","text_tokens":["一个","一段","：","默认","5","例","字节","ecb","pkcs5padding","个个","就","安全性","不足","最后","整个","aes192","模式","上","大家","block","可能","的","处理","128","拆","对","第二","使用","补足","链接","16","平时","最好","轮数","8","192bit","ofb","块","）","问题","。"," ","二块","192","{","了","不同","处理过程","这些","加密器","电码","算器","成一","时候","128bit","少于","反馈","必须","近似","就是","nopadding","末尾","填充","解密","要求","iso126padding","输出","整段","最终","语言","有个","安全","但是","、","需要","数","复杂","2","一个个","}","密码",",","之间","注意","过程","生成","电码本","\\","只有","随机","中","进行","7","aes128","在","补全","把","分成","什么","a","密文","一股脑","有些","整数倍","不","个","采用","从","等于","chaining","其它","用","为","如果","尾端","支持","主体","c","1","明文","五种","feedback","最高","outputfeedback","256","典型","aes256","一股","第二块","成","缺少","方式","则","分组","算法","book","性能","加密","做","（","#","数量","铭文","aes","cipher","细节","d","提供","几种","6","不是","相同","三种","，","而是","某种","整数","e","electronic",":","cfb","同样","值","思想","时","(","也","？","码本","差别","理过","结果","相应","拆分","许多","codebook","任何","counter","加密算法","ctr","密钥","b","说","一起","是","长度",")","3","4","每个","加入","体现","这个","且","工作","实际","中有","cbc","并","独立","数倍","字符","计算","位","64bit","后","计算器","拼接","g","经过"],"title":"三个基本概念（密钥、填充、模式）","title_tokens":["（","基本","基本概念","、","）","密钥","概念","三个","模式","填充"]},{"location":"algorithm/#java","text":"注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。","text_tokens":["时","如果","：","好","明文","字节","就是","nopadding","填充","解密","种子","key","密钥","方式","都","算法","长度","上","除了","的","注意","生成","aes","使用","封装","表面","16","额外","不是","并","数倍","真正","，","而是","外","整数","一组","调用","会","。","用于","块","整数倍","加解密","原本","其它"],"title":"在java中的具体实现","title_tokens":["的","实现","具体","中","java","在"]},{"location":"algorithm/#aes_1","text":"一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey）","text_tokens":["次","一个","addroundkey","：","字节","10","initial","aes192","255","混淆","的","处理","14","一次","mixcolumns","n","轮数","有","）"," ","。","轮","不同","对应","步骤","由","移位","除去","最终","代替","十六","需要","~","很多","普通",",","只有","ff","shiftrows","aes128","把","列","密文","进制","行","如下","十六进制","阶段","1","明文","刚好","12","0","四个","aes256","成","》","各种","加密","（","aes","加轮","具体","多少","不是","表示","round","，","而是","三个","论","(","也","可","？","subbytes","key","两个","密钥","final","长度",")","rounds","00","位","初始","经过"],"title":"AES算法的底层原理","title_tokens":["的","aes","算法","原理","底层"]},{"location":"algorithm/#subbyte","text":"十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11]","text_tokens":["[","一个","依据","(","十六进制","5","常量","字节","明文","就是","通过","]","盒","输出","第一","排列","替换","十六","b","例如","都","数组","是","换成","s",")","2","两位","16x16","列成","替代","的",",","每","另外","处理","被","那么","中","排列成","11","第一个","在","把","a","替换成","二位","，","大小","块"," ","4x4","subtitution","。","=","进制","box","5b","位","二维","值","步骤"],"title":"字节替代 subByte","title_tokens":["替代"," ","subbyte","字节"]},{"location":"algorithm/#shiftrows","text":"如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节","text_tokens":["左移","一个","第四行","：","一行","二行","字节","第一","如图","第一行","两个","第三","第四","不变","第三行","第二","第二行","三行","四行","循环"," ","三个"],"title":"行移位 shiftRows","title_tokens":["shiftrows","行"," ","移位"]},{"location":"algorithm/#mixcolumns","text":"输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列","text_tokens":["一个","(","常量","明文","修补","输出","一列","fix","数组",")","矩阵","matrix","要","做","的","每","和","得到","输入","相乘","列","二位","，"," ","对应"],"title":"列混淆MixColumns","title_tokens":["列","mixcolumns","混淆"]},{"location":"algorithm/#add-round-key","text":"128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。","text_tokens":["一个","字节","10","]","就","i","32","数组","的","处理","被","和","16","一次","）"," ","。","-","{","轮","了","*","不同","后续","对应","与","由","128bit","15","同于","而","输出","......","最终","排列","矩阵","2","用到","}",",","每","生成","存储","j","一轮","中","47","输入","a","原始","4x4","用于","k","源代码","[","用","160","为","来","1","keyexpentions","0","位置","一直","第","加密","元素","做","列成","（","aes","排列成","等同","，","+","同样","175","值","(","31","所有","到","直到","赋值","密钥","b","当中","是","都","长度",")","4","代码","完成","w","等同于","计算","异或","扩展","初始"],"title":"加 论密钥(add round key)","title_tokens":["round","(","add"," ","密钥","加",")","论","key"]},{"location":"algorithm/#_8","text":"所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度","text_tokens":["一个","：","简单","ecb","加盐","安全性","无法","模式","上","block","的","electronoc","处理","和","iv","较差","第一个","不如","作用","复杂度","块","。"," ","chainning","概念","更高","内部","了","作为","后续","与","加密器","一样","安全","防止","复杂","显然","2","优点","操作",",","每","之间","前会","互不","initialization","流程","初始化","只","在","缺点","干涉","密文","即","有利于","不","变成","关联","向量","md5","1","明文","宏观","第一","增加","成","有点像",".","book","有利","加密","性能","完全","做","所","参与","并行计算","aes","cipher","这样","相同","，","会",":","同样","有点","值","(","出","最","让","所有","互不干涉","差别","codebook","并行","都","是",")","前","体现","工作","vector","引入","cbc","独立","计算","异或","ecb2","利于","初始","经过"],"title":"不同工作模式在加密流程中有什么不同？","title_tokens":["什么","工作","？","模式","中有","流程","加密","不同","在"]},{"location":"algorithm/#md5","text":"可以从任意长度的明文字符串生成128位的哈希值","text_tokens":["字符","的","生成","任意","128","可以","明文","位","长度","值","从","哈希","字符串"],"title":"MD5","title_tokens":["md5"]},{"location":"algorithm/#_9","text":"1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制","text_tokens":["一个","收集","5","验证","接收","32","只能","如何","sign","最大","上","业务","之所以","支付","可能","的","abcd","这里","128","相关","和","第三方","二进制"," ","。","了","*","不同","签名","带上","传输","约定","时候","就是","通过","给定","既","acount","amout","原文","十六","参数值","需要","2","字符串","生成","无误","目标","信息","对比","只","金额","在","把","=","进制","不","数值","从","十六进制","如果","来","md5","1","所以","哈希","成","攻击者","则",".","因为","算法","做","本身","参与","比如","平台","请求","名","相同","又","，",":","参数","带","值","时","也","到","？","_","利用","账户","key","按照","是因为","hash","三方","过去","两个","密钥","发送","第三","是","4","3","除了","篡改","基本","直接","起来","三步","坏人","限制","知道","字符","双方","攻击","同时","位","后","规则","拼接","1234","ade876ishdfakhdj"],"title":"验签过程","title_tokens":["验签","过程"]},{"location":"algorithm/#md5_1","text":"分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c","text_tokens":["次","设置","一个","左移","：","5","简单","原先","可以","0x76543210","<","记录","就","i","32","最后","m","之一","m1","第二个","的","第四","处理","abcd","128","使用","对","第二","bit","黄色","和","剩余","16","一次","命名","第一个","n","代表","二进制","有","一共","/","）"," ","。","&","-","子","mi","不断","了","*","不同","上面","再","新","相加","由","0x89abcdef","单","就是","首先","填充","很","原","第一位","线性","完后","448","原文","、","十六","需要","第一步","份","复杂","向","~","实践","下面","2","ki","演变","^","田字","m0","用到",",","每","中","流程","信息","循环","进行","绿色","取代","水线","在","把","a","分成","旧","决定","0xfedcba98","分为","=","进制","整数倍","不","二个","等于","用","如下","为","十六进制","如果","组是","h","md5","c","常量","1","512","0","红色","四个","哈希","第一","mj","位置","四步",".","单次","一步","分组","z","共","所","”","（","第四个","y","流水线","字","d","流水","多少","这样","得到","使得","64","田","，","一组","整数","初始值","0x01234567","会","非线性","m16","三个","归纳","|","+","假设","值","交替","所用","值补","(","四种","也","之后","最","让","主","到","？","组","结果","张图","f","方法","按照","x","b","呢","图中","第三","都","是","表达","加工","长度",")","4","包含","3","量值","每个","s","等份","产生","次数","官方","下图","一等","第三个","次子","其余","数倍","函数","真正","求余","意思","一位","计算","位","后","“","m15","拼接","这","g","初始","经过"],"title":"MD5底层原理","title_tokens":["md5","原理","底层"]},{"location":"algorithm/#base64","text":"","text_tokens":[],"title":"Base64","title_tokens":["base64"]},{"location":"algorithm/#_10","text":"","text_tokens":[],"title":"排序","title_tokens":["排序"]},{"location":"algorithm/#_11","text":"","text_tokens":[],"title":"冒泡算法和优化","title_tokens":["优化","算法","和","冒泡"]},{"location":"basic/","text":"'this is about me page'","text_tokens":["page","this","is"," ","me","'","about"],"title":"Basic","title_tokens":["basic"]},{"location":"basicDataType/","text":"二进制简介 假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为： 00000000 00000000 00000000 00000101 5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。 负数的二进制(补码=反码+1) -5在计算机中如何表示？ 在计算机中负数以其正值的补码形式表达 比如 00000000 00000000 00000000 00000101 是 5的 原码。 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。 11111111 11111111 11111111 11111010 是 00000000 00000000 00000000 00000101 的反码。 补码：反码加1称为补码。 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。 11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011 -5在计算机中表示为：11111111 11111111 11111111 11111011 进制间转换 十进制转二进制 转二进制就除2把余数都标在右侧 最下面的余数放在最左面 例20的二进制 20...0 20除2商10余0 10...0 10除2商5余0 5....1 5除2商2余1 2....0 2除2商1余0 .....1 --------->0000 10100 十六进制转二进制 0x12--->0001 0010 0x1234-->0001 0010 0011 0100 二进制转十六进制 0001 0010 0011 0100-->0x1234 基本数据类型占的位数 bit: 1 bit位 = 1 二进制数据 byte: 1 byte = 8 bit位 （-128 ~ 127） 字母: 1 字母 = 1 byte = 8 bit(位) short: 16位 char: Unicode字符，16bit位 int: 32bit位，比如int 类型占用4个字节，32位 long: 64bit位 float: 32bit位 double: 64bit位 string: 汉字：1 汉字 = 2 byte = 16 bit 《《***这里不是很准确，当编码不同的时候，1个汉字所占的字节数也会有所不同，有些编码是占 2个字节，有些则不是，可能是 3个或者 4个***》》 与运算&0XFF &作为位运算 （还可以作为逻辑运算符） 操作数的二进制形式，同为1结果才是1，其它则为0，操作数可以是二进制八进制十六进制 0xff的十进制是255，八位二进制11111111,一个数&上它应该是不变的，但是 系统监测到byte作为int类型向控制台输出的时候，会自动将byte的内存空间高位补1扩充到32位。&0xff即是取了低八位，尽管十进制数不同但是保持了二进制补码的一致 例： 0x1234 十六进制 0001 0010 0011 0100 二进制 0xff---->1111 1111 左侧补0---->0000 0000 1111 1111 运算结果取低八位 0000 0000 0011 0100 有符号整数，正数要去除一个符号位，负数不用 计算机用位（bit）来作为基础单位 byte它的范围是-127~128,用8个bit可表示 1（2^8）~2^8-1 1111 1111 short,同char char，它的范围是0~2^15所以只能用16个bit,即两个byte int,他的范围是-2^-31~2^31-1 long double 8byte 64bit 取值-(2^64)~2^63 float 4byte 32bit byte类型的-127，其计算机存储的补码是10000001（8位），将其作为int类型向控制台输出的时候，jvm作了一个补位的处理，因为int类型是32位，所以补位后的补码就是1111111111111111111111111 10000001（32位），这个32位二进制补码表示的也是-127.虽然byte->int（八位扩展到32位），计算机背后存储的二进制补码由10000001（8位）转化成了1111111111111111111111111 10000001（32位）很显然这两个补码表示的十进制数字依然是相同的。 移位运算 <<:左移运算符，num << 1,相当于num乘以2 >>:右移运算符，num >> 1,相当于num除以2 >>>:无符号右移，忽略符号位，空位都以0补齐! 位异或运算符 位异或运算符为^，其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为 0 或同时为 1）时，结果为 0；如果对应的二进制位不相同，结果则为 1。 11^7=12 (化成二进制然后计算)","text_tokens":["一个","左移","无","正数","5","：","例","字节","一堆","可以","10","同为","<","1111","一","就","short","有所","jvm","32","左面","不足","相当","只能","转化","如何","int","11111010","255","它","float","空间","转换","long","上","计算机","----","符号","用位","乘以","然后","内存","---","可能","的","补","数字","不过","填","这里","128","不变","那么","处理","bit","节数","其","或者","高位","右移","16","补位","8","放在","《","二进制","有","00000000","运算符","保持","!","1111111111111111111111111","字节数","）"," ","。","&","-","标在","作为","对齐","当于","准确","了","前面","*","类型","unicode","取反","商","当","新","反码","不同","与","逻辑","控制","8byte","由","除以","0001","时候","0x1234","就是","10100","15","忽略","很","原码","运算","余数","63","移位","原","输出","一致","十进制","右侧","0000","相当于","但是","十六","byte","算符","数","...","作","向","数据","~","显然","下面","string","2","编码","^","基础","11111111","操作","所得","....",",","自动","左侧","存储","10000001","中","先","内存空间","他","虽然","八位","7","在","算机","把","形式","有些","=","进制","占","即","不","我们","个","按位","其它","用","十六进制","为","控制台","如果","来","还","32bit","正值","1",".....","称为","12","低位","0","所以","转换成","二制","》","0011","八进制","或","依然","不用","则","将","--",".","因为","127","加","要","尽管","16bit","范围","所","有所不同","（","就是说","去除","占用","比如","空位","参与","0xff","20","扩充","值为","补码","得到","不是","相同","11","负数","以","表示","作数","64","，","4byte","整数","会","同",":","00000101","---------","假设","+","取","字母","这","(","31","也","最","取值","补零","到","可","时","？","汉字","结果","操作数","转化成","数据类型","转","也就是说","余","11111011","两个","才","应该","二进制位","char","是","都","表达","；","换成","4",")","3","单位","num","低","系统","基本","101","监测","对应","简介","这个","0x12","除","化成","0100","0010","double","知道","字符",">","计算","异或","扩展","位","64bit","取低","后","间","补齐","规则","同时","加上","背后","位数"],"title":"基础数据类型","title_tokens":["数据","类型","基础","数据类型"]},{"location":"basicDataType/#_1","text":"假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为： 00000000 00000000 00000000 00000101 5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。","text_tokens":["为","5","：","字节","一堆","一","0","所以","转换成","二制","32","数","int","是","它","换成","转换","4","计算机","（","的","101","占用","不过","填","那么","中","值为","知道","算机","在","00000000","有","表示","，","）"," ","计算","。","位","00000101","假设","我们","前面","了","类型"],"title":"二进制简介","title_tokens":["二进制","简介","进制"]},{"location":"basicDataType/#1","text":"-5在计算机中如何表示？ 在计算机中负数以其正值的补码形式表达 比如 00000000 00000000 00000000 00000101 是 5的 原码。 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。 11111111 11111111 11111111 11111010 是 00000000 00000000 00000000 00000101 的反码。 补码：反码加1称为补码。 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。 11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011 -5在计算机中表示为：11111111 11111111 11111111 11111011","text_tokens":["一个","为","5","：","新","正值","？","1","称为","就是","原码","原","也就是说","11111011","如何","将","数","是","11111010","表达","加","要","计算机","11111111","然后","所得","就是说","的","比如","中","其","先","补码","得到","在","算机","负数","以","表示","形式","00000000","二进制","，","计算"," ","。","-","进制","00000101","=","+","加上","取反","按位","反码"],"title":"负数的二进制(补码=反码+1)","title_tokens":["二进制","的","(","=","1","进制","补码","+",")","反码","负数"]},{"location":"basicDataType/#_2","text":"十进制转二进制 转二进制就除2把余数都标在右侧 最下面的余数放在最左面 例20的二进制 20...0 20除2商10余0 10...0 10除2商5余0 5....1 5除2商2余1 2....0 2除2商1余0 .....1 --------->0000 10100 十六进制转二进制 0x12--->0001 0010 0x1234-->0001 0010 0011 0100 二进制转十六进制 0001 0010 0011 0100-->0x1234","text_tokens":["十六进制","最","5","0001","例","1",".....","0x1234","10","10100","就","余数","0","十进制","转","右侧","左面","0000","余","0011","十六","...","--","都","下面","2","---","的","....","0x12","20","除","0100","0010","放在","把","二进制",">"," ","进制","标在","---------","商"],"title":"进制间转换","title_tokens":["转换","间","进制"]},{"location":"basicDataType/#_3","text":"bit: 1 bit位 = 1 二进制数据 byte: 1 byte = 8 bit位 （-128 ~ 127） 字母: 1 字母 = 1 byte = 8 bit(位) short: 16位 char: Unicode字符，16bit位 int: 32bit位，比如int 类型占用4个字节，32位 long: 64bit位 float: 32bit位 double: 64bit位 string: 汉字：1 汉字 = 2 byte = 16 bit 《《***这里不是很准确，当编码不同的时候，1个汉字所占的字节数也会有所不同，有些编码是占 2个字节，有些则不是，可能是 3个或者 4个***》》","text_tokens":["(","也","：","32bit","时候","1","字节","汉字","很","short","有所","不同","32","》","byte","则","int","char","是","数据","~","127","4",")","long","float","16bit","string","2","编码","3","所","有所不同","（","可能","的","比如","占用","这里","128","bit","节数","或者","16","double","不是","8","《","二进制","字符","类型","，","字节数","）","会"," ","=",":","进制","位","-","64bit","当","占","准确","个","*","字母","unicode","有些"],"title":"基本数据类型占的位数","title_tokens":["基本","的","占","数据","类型","数据类型","位数"]},{"location":"basicDataType/#0xff","text":"&作为位运算 （还可以作为逻辑运算符） 操作数的二进制形式，同为1结果才是1，其它则为0，操作数可以是二进制八进制十六进制 0xff的十进制是255，八位二进制11111111,一个数&上它应该是不变的，但是 系统监测到byte作为int类型向控制台输出的时候，会自动将byte的内存空间高位补1扩充到32位。&0xff即是取了低八位，尽管十进制数不同但是保持了二进制补码的一致 例： 0x1234 十六进制 0001 0010 0011 0100 二进制 0xff---->1111 1111 左侧补0---->0000 0000 1111 1111 运算结果取低八位 0000 0000 0011 0100 有符号整数，正数要去除一个符号位，负数不用 计算机用位（bit）来作为基础单位 byte它的范围是-127~128,用8个bit可表示 1（2^8）~2^8-1 1111 1111 short,同char char，它的范围是0~2^15所以只能用16个bit,即两个byte int,他的范围是-2^-31~2^31-1 long double 8byte 64bit 取值-(2^64)~2^63 float 4byte 32bit byte类型的-127，其计算机存储的补码是10000001（8位），将其作为int类型向控制台输出的时候，jvm作了一个补位的处理，因为int类型是32位，所以补位后的补码就是1111111111111111111111111 10000001（32位），这个32位二进制补码表示的也是-127.虽然byte->int（八位扩展到32位），计算机背后存储的二进制补码由10000001（8位）转化成了1111111111111111111111111 10000001（32位）很显然这两个补码表示的十进制数字依然是相同的。","text_tokens":["一个","正数","：","例","可以","同为","1111","short","jvm","32","只能","转化","int","1111111111111111111111111","255","它","空间","符号","上","----","基础","计算机","long","用位","float","内存","数字","的","补","处理","不变","128","bit","其","高位","16","8","运算符","二进制","有","保持","）"," ","。","&","-","了","左侧","不同","作为","类型","4byte","补位","逻辑","8byte","控制","由","0001","时候","0x1234","就是","15","运算","63","很","一致","输出","十进制","0000","但是","算符","十六","byte","数","作","向","~","显然","2","^","11111111","操作",",","自动","存储","10000001","内存空间","他","虽然","八位","算机","形式","进制","即","个","其它","用","十六进制","为","控制台","来","还","32bit","1","0","所以","八进制","0011","依然","不用","则","将",".","因为","127","要","尽管","范围","（","去除","0xff","扩充","补码","相同","负数","64","表示","作数","，","整数","会","同","取","31","取值","(","也","到","可","结果","操作数","转化成","两个","才","应该","char","是",")","单位","低","系统","监测","这个","化成","0100","0010","double",">","计算","扩展","位","取低","64bit","后","这","背后"],"title":"与运算&amp;0XFF","title_tokens":["0xff",";","amp","&","运算","与"]},{"location":"basicDataType/#_4","text":"<<:左移运算符，num << 1,相当于num乘以2 >>:右移运算符，num >> 1,相当于num除以2 >>>:无符号右移，忽略符号位，空位都以0补齐!","text_tokens":["除以","左移","无","1","忽略","<","运算","0","相当于","相当","算符","都","符号","乘以","num","2","空位",",","右移","!","运算符","以","，",">"," ",":","位","当于","补齐"],"title":"移位运算","title_tokens":["运算","移位"]},{"location":"basicDataType/#_5","text":"位异或运算符为^，其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为 0 或同时为 1）时，结果为 0；如果对应的二进制位不相同，结果则为 1。 11^7=12 (化成二进制然后计算)","text_tokens":["为","补零","如果","时","(","：","1","二进制位","结果","运算","12","低位","0","不足","或","算符","则","是","；",")","^","然后","（","数字","的","参与","其","化成","高位","相同","11","7","运算符","二进制","，","）"," ","异或","对齐","进制","位","同时","。","=","计算","规则","不","对应"],"title":"位异或运算符","title_tokens":["运算符","算符","异或","位","运算"]},{"location":"contact/","text":"'hey guys! this is contact me page'","text_tokens":["page","guys","this","is"," ","me","'","contact","hey","!"],"title":"Contact","title_tokens":["contact"]},{"location":"designParttern/","text":"云收银APP阅读文档 SplashActicity 1.initUmeng+initSunmiBlePrint 2.延时3s一个handler来决定接下来进入哪个页面（括号里面是条件）  进入GuidActivity(判断sp版本号跟配置文件版本号是否一致，进入登陆页面时保存版本号)  进入MainActivity(通过logintoken判断是否进入MainActivity)  进入LoginAcitivity(else进入LoginActivity) 3.开启日志上传Service GuidActivity  一个很简单滑动的轮播图外加一个进入LoginActivity的按钮 LoginActivity  自定义EditText(主要功能有：清除图标，EditText抖动动画)  重置密码  登陆（包含获取公钥接口+登陆接口）   1.对于登陆参数pwd字段的加密（RSA(pwd,publicKey)）   2.自定义Toast(YellowToastUtils密码错误顶部显示一段黄色背景提示)   3.使用Linerlayout+RelativeLayout framlayout+权重布局法  4.","text_tokens":["一个","接下来","版本","一段","：","进入","简单","文件","日志","保存","顶部","公钥","下来","开启","抖动","判断","轮播","是否","定义","错误","的","黄色","使用","loginacitivity","framlayout","relativelayout","有","loginactivity","条件","）"," ","图","权重","动画","图标","initsunmibleprint","阅读","里面","通过","上传","很","一致","else","yellowtoastutils","rsa","配置","splashacticity","2","pwd","密码","获取",",","滑动","mainactivity","接口","guidactivity","布局","括号","决定","功能","edittext","主要","自定义","跟","linerlayout","背景","版本号","来","1","页面",".","显示","加密","（","提示","法","initumeng","，","publickey","延时","对于","外加","+"," ","参数","文档","云","重置","时","(","配置文件","接下","登陆","清除","收银","3s","是","自定","sp","4",")","3","包含","handler","字段","toast","service","哪个","app","按钮","logintoken"],"title":"**云收银APP阅读文档**","title_tokens":["收银","app","*","文档","云","阅读"]},{"location":"designParttern/#app","text":"SplashActicity 1.initUmeng+initSunmiBlePrint 2.延时3s一个handler来决定接下来进入哪个页面（括号里面是条件）  进入GuidActivity(判断sp版本号跟配置文件版本号是否一致，进入登陆页面时保存版本号)  进入MainActivity(通过logintoken判断是否进入MainActivity)  进入LoginAcitivity(else进入LoginActivity) 3.开启日志上传Service GuidActivity  一个很简单滑动的轮播图外加一个进入LoginActivity的按钮 LoginActivity  自定义EditText(主要功能有：清除图标，EditText抖动动画)  重置密码  登陆（包含获取公钥接口+登陆接口）   1.对于登陆参数pwd字段的加密（RSA(pwd,publicKey)）   2.自定义Toast(YellowToastUtils密码错误顶部显示一段黄色背景提示)   3.使用Linerlayout+RelativeLayout framlayout+权重布局法  4.","text_tokens":["一个","接下来","版本","一段","：","进入","简单","文件","日志","保存","顶部","公钥","下来","开启","抖动","判断","轮播","是否","定义","错误","的","黄色","使用","loginacitivity","framlayout","relativelayout","有","loginactivity","条件","）"," ","图","权重","动画","图标","initsunmibleprint","里面","通过","上传","很","一致","else","yellowtoastutils","rsa","配置","splashacticity","2","pwd","密码","获取",",","滑动","mainactivity","接口","guidactivity","布局","括号","决定","功能","edittext","主要","自定义","跟","linerlayout","背景","版本号","来","1","页面",".","显示","加密","（","提示","法","initumeng","，","publickey","延时","对于","外加","+"," ","参数","重置","时","(","配置文件","接下","登陆","清除","3s","是","自定","sp","4",")","3","包含","handler","字段","toast","service","哪个","按钮","logintoken"],"title":"云收银APP阅读文档","title_tokens":["收银","app","文档","云","阅读"]},{"location":"fourcomponent/","text":"四大组件及生命周期 Activity 生命周期 经典题目：A->B 问A和B的生命周期变化？然后从B返回A，问A和B的生命周期变化？ A(onPause) B(onCreat) B(onStart) B(onResume) A(onStop) 从B返回A B(onPause) A(onRestart) A(onStart) A(onResume) B(onStop) B(onDestroy) 主要知识点：掌握两组对应关系 onStart-onResume onPause-onStop 启动模式 1. standard 标准的栈结构 2. singleTop 在栈顶可复用 3. singleInstance 全局复用，一个独立的栈中，有坑 ActivityA,ActivityB(singleInstance),ActivityC A中启动B,B中启动C 此时按理在任务栈中的顺序从上到下是CBA 按理在C中按返回键应该回到B中，此时却回到了A中。 方法在B中定义全局变量returnActivityB,然后在A的onstart方法中判断全局变量returnActivityB，如果为true则跳转到B 4. singleTask 同栈的复用，顶出栈 经典题目：各个模式的使用场景 数据传递 1. intent 2. startActivityForResult 事件分发 Service service中能否进行耗时操作及如何 和activity通信 1. 生命周期 1. startService * call to startService * onCreat * onStartCommand() * Service running * onDestroy * Service Shut Down 2. bindService * call to bindService * onCreat * onBind * Client are bind to Service * onUnbind * onDestroy * Service shut down 启动模式 1. startService 2. bindService 使用方法 第一步在Manifest中注册 第二步启动startService/bindService 第三步解绑unBindService 第四步暂停stopService Activity和Service通信","text_tokens":["一个","：","activityc","关系","singleinstance","上到","及","此时","stopservice","standard","问","activityb","onrestart","周期","模式","判断","如何","ondestroy","定义","然后","第四","的","返回","activity","onstop","使用","第二","和","down","启动","manifest","有","生命","/"," ","。","-","栈","bindservice","了","*","两组","从上到下","对应","坑","are","耗时","onpause","onstartcommand","顺序","第一步","暂停","数据","按","事件","activitya","2","client","操作","bind",",","全局","onresume","中","进行","在","intent","a","按理","第四步","主要","从","跳转","栈中","复用","为","二步","如果","startservice","c","1","onstart","singletop","标准","全局变量","却","同栈","第一","四步","题目","任务",".","则","一步","生命周期","变量","出栈","singletask","，","键","to","shut","注册","call","各个","(","running","到","顶","可","？","true","onbind","组件","能否","回到","方法","知识","知识点","解绑","传递","unbindservice","b","应该","第三","结构","是","场景","startactivityforresult","4",")","3","cba","分发","经典","三步","第二步","onunbind","独立","四大",">","service","通信","掌握","第三步","oncreat","returnactivityb","变化"],"title":"四大组件","title_tokens":["组件","四大"]},{"location":"fourcomponent/#_1","text":"","text_tokens":[],"title":"四大组件及生命周期","title_tokens":["四大","生命","周期","生命周期","及","组件"]},{"location":"fourcomponent/#activity","text":"生命周期 经典题目：A->B 问A和B的生命周期变化？然后从B返回A，问A和B的生命周期变化？ A(onPause) B(onCreat) B(onStart) B(onResume) A(onStop) 从B返回A B(onPause) A(onRestart) A(onStart) A(onResume) B(onStop) B(onDestroy) 主要知识点：掌握两组对应关系 onStart-onResume onPause-onStop 启动模式 1. standard 标准的栈结构 2. singleTop 在栈顶可复用 3. singleInstance 全局复用，一个独立的栈中，有坑 ActivityA,ActivityB(singleInstance),ActivityC A中启动B,B中启动C 此时按理在任务栈中的顺序从上到下是CBA 按理在C中按返回键应该回到B中，此时却回到了A中。 方法在B中定义全局变量returnActivityB,然后在A的onstart方法中判断全局变量returnActivityB，如果为true则跳转到B 4. singleTask 同栈的复用，顶出栈 经典题目：各个模式的使用场景 数据传递 1. intent 2. startActivityForResult 事件分发","text_tokens":["一个","：","activityc","关系","singleinstance","上到","此时","standard","问","activityb","onrestart","周期","模式","判断","ondestroy","定义","然后","的","返回","onstop","使用","和","启动","有","生命"," ","。","-","栈","了","两组","从上到下","对应","坑","onpause","顺序","数据","按","事件","activitya","2",",","全局","onresume","中","在","intent","a","按理","主要","从","跳转","栈中","复用","为","如果","c","1","onstart","singletop","标准","全局变量","却","同栈","题目","任务",".","则","生命周期","变量","出栈","singletask","，","键","各个","(","到","顶","可","？","true","回到","方法","知识","知识点","传递","b","应该","结构","是","场景","startactivityforresult","4",")","3","cba","分发","经典","独立",">","掌握","oncreat","returnactivityb","变化"],"title":"Activity","title_tokens":["activity"]},{"location":"fourcomponent/#service","text":"service中能否进行耗时操作及如何 和activity通信 1. 生命周期 1. startService * call to startService * onCreat * onStartCommand() * Service running * onDestroy * Service Shut Down 2. bindService * call to bindService * onCreat * onBind * Client are bind to Service * onUnbind * onDestroy * Service shut down 启动模式 1. startService 2. bindService 使用方法 第一步在Manifest中注册 第二步启动startService/bindService 第三步解绑unBindService 第四步暂停stopService Activity和Service通信","text_tokens":["are","二步","(","startservice","running","耗时","1","及","onbind","stopservice","能否","方法","第一","onstartcommand","解绑","四步","unbindservice","如何",".","周期","模式","ondestroy","一步","生命周期","第一步",")","第三","2","暂停","client","操作","bind","第四","activity","使用","第二","和","三步","中","down","第二步","进行","启动","onunbind","manifest","在","生命","/","service"," ","通信","第三步","oncreat","to","bindservice","shut","注册","第四步","*","call"],"title":"Service","title_tokens":["service"]},{"location":"garbage/","text":"jvm内存模型 要理解gc必须理解jvm，jvm主要管理两种内存：堆非堆 堆(Heap Memory)：类实例和数组的内存 非堆(No-heap Memory)：方法区，类结构（运行时常数池，字段和方法），类加载信息 GC主要回收的内存是堆内存 堆内存模型 1. 堆内存分两块，新生代和老年代，比例(1:2) * 老年代主要存放应用程序中生命周期较长的的存活对象 2. 新生代分三个部分，一个eden区和两个survivor区，比例8：1：1 * eden区存放新生的对象 * survivor区存放每次垃圾回收后存活的对象 可回收对象的判定 什么样的对象是垃圾？ 1. 引用计数算法 原理就是给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1， 当引用失效时，计数值就减1，计数器为0的对象就是不在被使用的。 * 简单、高效（objectiveC用的该算法） * 很难处理循环引用（相互引用两个对象） 可达性分析算法 为了解决循环引用，java采用新的算法 从GC的ROOT作为起点，向下搜索它们引用的对象，可生成一棵引用树，树的节点可视为可达对象，反之视为不可达 如何定义GC root,java语言定义如下GC-ROOT对象 * 虚拟机栈中引用的对象 * 方法区中静态属性引用的对象 * 方法区中常量引用的对象 * 本地方法栈中jni引用的对象 ## stop the world 垃圾回收时需要整个引用状态保持不变，否则判定是垃圾，等会就不是了，GC的时候所有的程序执行处于暂停的状态，卡住，这种卡顿非常短，对程序的影响微乎其微，GC的卡顿由此而来。 几种垃圾回收算法 如何回收？Java虚拟机采用的是分代回收算法，想要理解分代回收算法，有必要先了解其它几种简单算法 1. 标记清楚算法(Mark-Sweep) 标记阶段：标记所有需要被回收的对象 清楚阶段：回收被标记对象占用的空间 * 简单，容易实现 * 容易产生内存碎片，碎片太多可能导致后续需要为大对象分配空间无法找到足够的空间，提前触发新的一次垃圾收集动作。 复制算法（Copying） 将内存分为大小相同的两块，每次只使用其中的一块，当这一块用完了，将还活着的对象复制到另外一块，再把已使用的一块一次清理掉，这样就不会出现内存碎片问题， * 简单，高效 * 对内存空间的使用付出了高昂的代价，可 使用内存缩少到了原来的一半 Copying算法的效率取决于活着的对象，活着的对象越多copying越多，效率越慢 标记整理算法（Mark-compact） 标记阶段和Mark-sweep一样，标记出需要被回收的对象，完成标记后，将存活的对象向一端移动，清理掉端边界以外的内存 * 适用于存活对象多，回收对象少的情况 分代回收算法 不是一种新的算法而是复制算法和标记整理算法的整合 复制算法：适用于存活对象少，回收对象多 标记整理算法：适用于存活对象多，回收对象少 堆内存分为老年代(Old generation)和新生代(young Generation),老年代的特点是每次垃圾收集时只有少量的对象需要被回收，新生代的特点是每次垃圾回收时都有大量的对象需要被回收，根据不同代的特点采用不同的算法，这就是分代算法。 详细分析 1. 对于新生代采用Copying算法，因为新生代每次垃圾回收的时候都要回收大部分对象，也就是说需要复制的存活的对象较少，所以采用Copying算法的效率最高，实际中并不是按照上面Copying算法中说的1：1分成相等的两块，而是将新生代分为eden空间和survivor空间8：1：1 2. 由于老年代每次只回收少量对象，一般使用Mark-compact算法 QA1.为什么需要两块Survivor空间？ 这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次GC的时候，我们可以把Eden区的存活对象放到Survivor A空间，但是第二次GC的时候，Survivor A空间的存活对象也需要再次用Copying算法，放到Survivor B空间上，而把刚刚的Survivor A空间和Eden空间清除。第三次GC时，又把Survivor B空间的存活对象复制到Survivor A空间，如此反复。 所以，这里就需要两块Survivor空间来回倒腾。 QA2.为什么EDEN空间这么大而Survivor空间这么小？ 新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。 我看8：1：1就挺好的，当然这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。 新的问题又来了，从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？直接放到老年代去。 Eden空间和两块Survivor空间的工作流程？ 现在假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。 // 分配了一个又一个对象 放到Eden区 // 不好，Eden区满了，只能GC(新生代GC：Minor GC)了 把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的） // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区 // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区 // ... // 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区 // 有的对象太大，超过了Eden区，直接被分配在Old区 // 有的存活对象，放不下Survivor区，也被分配到Old区 // ... // 在某次Minor GC的过程中突然发现： // 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC) Old区慢慢的整理一番，空间又够了 // 继续Minor GC // ... // ... 通过日志分析GC类型 GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。 GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。 GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。 GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。","text_tokens":["：","往往","mark","jvm","malloc","虚拟机","理解","最后","大量","短","只能","空间","原理","然后","可能","不过","处理","被","这里","使用","对","或者","一次","三次","保持","/","eden","问题","一番","非常","不同","够","类型","sigusr1","这些","仅供参考","放到","来回","就是","之前","语言","应用程序","no","自动","生成","容易","复制到","清空","它们","只","能","把","卡顿","分配","少","objectivec","多","1","非堆","memory","可达","generation","system","当然","怎么",".","继续","复制","算法","移动","root","分析","占用","视为","准备","这样",":","向下","等","付出","可达性","看","所有","到","取决","状态","清除","按照","局部变量","第三次","两个","管理","应该","第三","都","往","出现","仅供","存活","高效","完成","于","涉及","定量","两种","一般","一个","设置","加载","相互","一棵","频繁","一种","无法","大部分","慢慢","不足","执行","影响","新创","定义","不会","老生","和","已","缩少","一半","放在","呆","第一次","sweep","）","the","反复","-","老","了","*","地方","当","运行","作为","添加","新","信号","新创建","计数","不可","区中","清理","一定","程序","old","放不下","刚刚","需要","否则","缓解","详细分析","每次","处于","过程","掉","接口","中","先","java","a","区","分为","标记","主要","数值","从","挺","用","如下","什么样","copy","还","常量","计","qa2","第一","相等","大部","因为","用率","生命周期","存放","细分","代","就是说","不够","足够","临时","程序执行","太","一块","两块","而是","调用","compact","包括","(","出","可","本来","？","oom","突然","调整","搜索","完","想要","结构","是",")","详细","concurrent","实际","特点","大小","达到","参考","而来","后","major","新生","较长","次","简单","可以","日志","较大","实例","回收","周期","如何","它","上","超过","去","马上","达","常数","explicit","8","整理","计数器"," ","。","解决","取决于","上面","world","合理","必须","15","很","第二次","但是","新生代","for","...","暂停","了解","给","本地","由此",",","只有","模型","信息","循环","内存空间","进行","在","大大","内存不足","我们","可回收","比例","其它","如此","再次","提高","垃圾","对象","必要","qa1","所以","vmruntime","空","部分","边界","要","（","比如","少量","以外","几种","不是","，","小","会","三个","对于","也","越多","由此而来","_","该","大大提高","找到","代价","快要","由于","也就是说","高昂","触发","年代","为什么","产生","大","这个","反之","heap","适用","字段","收到","每当","根据","一定量","碎片","某次","这","满","异常","越慢","收集","好","minor","就","下来","整个","分代","数组","其中","减","内存","stop","三块","虚拟","的","不变","第二","有","jni","生命","抛","尤其","起点","释放","##","原来","before","大而","不好","很难","不下","后续","再","倒腾","池","young","时候","一样","通过","而","分","移到","区满","、","发现","向","2","一端","引用","卡住","经历","操作","另外","局部","流程","努力","树","这么","分成","什么","缺点","整合","不","采用","栈中","为","静态","来","阶段","0","最高","动作","绝大","提前","将","清楚","创建","变量","应用","活着","gc","节点","实现","端","这种","相同","copying","情况","使用率","又","表示","导致","堆","失效","时","这是","较","中说","我","就加","方法","survivor","b","属性","类","系统","直接","怎么办","供参考","工作","绝大部分","现在","并","判定","假定","效率","二次","为了","转移","微乎其微"],"title":"垃圾回收机制","title_tokens":["机制","垃圾","回收"]},{"location":"garbage/#jvm","text":"要理解gc必须理解jvm，jvm主要管理两种内存：堆非堆 堆(Heap Memory)：类实例和数组的内存 非堆(No-heap Memory)：方法区，类结构（运行时常数池，字段和方法），类加载信息 GC主要回收的内存是堆内存","text_tokens":["时","(","池","：","加载","必须","非堆","memory","jvm","实例","方法","理解","回收","管理","结构","数组","是",")","要","no","类","内存","（","gc","的","和","信息","heap","常数","字段","区","，","）"," ","-","两种","堆","主要","运行"],"title":"jvm内存模型","title_tokens":["模型","内存","jvm"]},{"location":"garbage/#_1","text":"1. 堆内存分两块，新生代和老年代，比例(1:2) * 老年代主要存放应用程序中生命周期较长的的存活对象 2. 新生代分三个部分，一个eden区和两个survivor区，比例8：1：1 * eden区存放新生的对象 * survivor区存放每次垃圾回收后存活的对象","text_tokens":["一个","(","：","垃圾","1","对象","较长","程序","分","部分","回收","新生代","survivor","两个","周期",".","应用程序","生命周期",")","存放","2","年代","存活","内存","应用","每次","的","和","中","8","两块","区","，","生命","eden"," ",":","三个","主要","堆","后","老","新生","*","比例"],"title":"堆内存模型","title_tokens":["堆","模型","内存"]},{"location":"garbage/#_2","text":"什么样的对象是垃圾？ 1. 引用计数算法 原理就是给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1， 当引用失效时，计数值就减1，计数器为0的对象就是不在被使用的。 * 简单、高效（objectiveC用的该算法） * 很难处理循环引用（相互引用两个对象） 可达性分析算法 为了解决循环引用，java采用新的算法 从GC的ROOT作为起点，向下搜索它们引用的对象，可生成一棵引用树，树的节点可视为可达对象，反之视为不可达 如何定义GC root,java语言定义如下GC-ROOT对象 * 虚拟机栈中引用的对象 * 方法区中静态属性引用的对象 * 方法区中常量引用的对象 * 本地方法栈中jni引用的对象 ## stop the world 垃圾回收时需要整个引用状态保持不变，否则判定是垃圾，等会就不是了，GC的时候所有的程序执行处于暂停的状态，卡住，这种卡顿非常短，对程序的影响微乎其微，GC的卡顿由此而来。","text_tokens":["一个","简单","相互","就","一棵","虚拟机","回收","短","整个","执行","如何","影响","它","减","定义","原理","stop","虚拟","的","处理","被","不变","使用","对","达","有","jni","保持","计数器","）","起点"," ","。","##","-","the","解决","非常","了","很难","*","作为","当","地方","添加","新","计数","不可","区中","world","时候","就是","程序","语言","、","需要","暂停","给","否则","本地","引用","卡住","由此",",","处于","生成","循环","它们","java","树","在","什么","卡顿","不","采用","数值","从","用","如下","为","什么样","栈中","静态","objectivec","常量","垃圾","1","计","对象","0","可达",".","算法","root","（","分析","gc","节点","视为","程序执行","这种","不是","，","会","向下","等","失效","可达性","时","所有","可","？","由此而来","状态","该","就加","方法","搜索","两个","是","属性","高效","反之","判定","每当","而来","为了","微乎其微"],"title":"可回收对象的判定","title_tokens":["的","回收","判定","对象","可回收"]},{"location":"garbage/#_3","text":"如何回收？Java虚拟机采用的是分代回收算法，想要理解分代回收算法，有必要先了解其它几种简单算法 1. 标记清楚算法(Mark-Sweep) 标记阶段：标记所有需要被回收的对象 清楚阶段：回收被标记对象占用的空间 * 简单，容易实现 * 容易产生内存碎片，碎片太多可能导致后续需要为大对象分配空间无法找到足够的空间，提前触发新的一次垃圾收集动作。 复制算法（Copying） 将内存分为大小相同的两块，每次只使用其中的一块，当这一块用完了，将还活着的对象复制到另外一块，再把已使用的一块一次清理掉，这样就不会出现内存碎片问题， * 简单，高效 * 对内存空间的使用付出了高昂的代价，可 使用内存缩少到了原来的一半 Copying算法的效率取决于活着的对象，活着的对象越多copying越多，效率越慢 标记整理算法（Mark-compact） 标记阶段和Mark-sweep一样，标记出需要被回收的对象，完成标记后，将存活的对象向一端移动，清理掉端边界以外的内存 * 适用于存活对象多，回收对象少的情况 分代回收算法 不是一种新的算法而是复制算法和标记整理算法的整合 复制算法：适用于存活对象少，回收对象多 标记整理算法：适用于存活对象多，回收对象少 堆内存分为老年代(Old generation)和新生代(young Generation),老年代的特点是每次垃圾收集时只有少量的对象需要被回收，新生代的特点是每次垃圾回收时都有大量的对象需要被回收，根据不同代的特点采用不同的算法，这就是分代算法。 详细分析 1. 对于新生代采用Copying算法，因为新生代每次垃圾回收的时候都要回收大部分对象，也就是说需要复制的存活的对象较少，所以采用Copying算法的效率最高，实际中并不是按照上面Copying算法中说的1：1分成相等的两块，而是将新生代分为eden空间和survivor空间8：1：1 2. 由于老年代每次只回收少量对象，一般使用Mark-compact算法 QA1.为什么需要两块Survivor空间？ 这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次GC的时候，我们可以把Eden区的存活对象放到Survivor A空间，但是第二次GC的时候，Survivor A空间的存活对象也需要再次用Copying算法，放到Survivor B空间上，而把刚刚的Survivor A空间和Eden空间清除。第三次GC时，又把Survivor B空间的存活对象复制到Survivor A空间，如此反复。 所以，这里就需要两块Survivor空间来回倒腾。 QA2.为什么EDEN空间这么大而Survivor空间这么小？ 新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。 我看8：1：1就挺好的，当然这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。 新的问题又来了，从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？直接放到老年代去。 Eden空间和两块Survivor空间的工作流程？ 现在假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。 // 分配了一个又一个对象 放到Eden区 // 不好，Eden区满了，只能GC(新生代GC：Minor GC)了 把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的） // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区 // 又分配了一个又一个对象 放到Eden区 // 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了 把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区 // ... // 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区 // 有的对象太大，超过了Eden区，直接被分配在Old区 // 有的存活对象，放不下Survivor区，也被分配到Old区 // ... // 在某次Minor GC的过程中突然发现： // 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC) Old区慢慢的整理一番，空间又够了 // 继续Minor GC // ... // ...","text_tokens":["：","往往","mark","虚拟机","理解","大量","只能","空间","然后","可能","不过","被","这里","使用","对","或者","一次","三次","/","eden","问题","一番","不同","够","这些","仅供参考","放到","来回","就是","容易","复制到","清空","只","能","把","分配","少","多","1","generation","当然","怎么",".","继续","复制","算法","移动","分析","占用","这样","付出","看","所有","到","取决","清除","按照","局部变量","第三次","应该","第三","都","往","出现","仅供","存活","高效","完成","于","涉及","一般","一个","设置","频繁","一种","无法","大部分","慢慢","新创","不会","老生","和","已","缩少","一半","放在","呆","第一次","sweep","）","反复","-","了","老","*","当","新","新创建","清理","old","放不下","刚刚","需要","缓解","详细分析","每次","过程","掉","先","中","java","a","区","分为","标记","从","挺","用","copy","还","qa2","第一","相等","大部","因为","用率","细分","代","就是说","不够","足够","临时","太","一块","两块","而是","compact","包括","(","出","可","本来","？","突然","调整","完","想要","是",")","详细","实际","特点","大小","参考","后","major","新生","次","简单","可以","较大","回收","如何","周期","上","超过","去","马上","8","整理"," ","。","取决于","上面","合理","15","很","第二次","但是","新生代","...","了解",",","只有","内存空间","在","大大","我们","如此","其它","比例","再次","提高","垃圾","对象","必要","qa1","所以","空","部分","边界","要","（","比如","少量","以外","几种","不是","，","小","对于","也","越多","大大提高","找到","代价","由于","也就是说","高昂","触发","年代","为什么","产生","大","这个","适用","根据","碎片","某次","这","满","越慢","收集","好","minor","就","下来","分代","其中","内存","三块","虚拟","的","第二","有","尤其","原来","大而","不好","不下","后续","再","倒腾","young","时候","一样","而","移到","区满","发现","向","2","一端","经历","另外","局部","流程","这么","分成","什么","缺点","整合","不","采用","为","来","阶段","最高","动作","绝大","提前","将","清楚","创建","变量","活着","gc","实现","端","相同","copying","情况","使用率","又","导致","堆","时","这是","较","中说","我","survivor","b","直接","怎么办","供参考","工作","绝大部分","现在","并","假定","效率","二次","转移"],"title":"几种垃圾回收算法","title_tokens":["算法","几种","垃圾","回收"]},{"location":"garbage/#gc","text":"GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。 GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。 GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。 GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。","text_tokens":["时","为","来","时候","可以","对象","_","一定","oom","之前","malloc","程序","快要","vmruntime","而","system","不足","理解","、","最后","for",".","应用程序","是","上","触发","内存","应用","系统","操作","gc","的","自动","准备","concurrent","满","接口","或者","进行","努力","explicit","sigusr1","在","表示","收到","，","抛","达到","会","定量"," ","。",":","释放","调用","内存不足","堆","一定量","before","分配","我们","当","异常","信号"],"title":"通过日志分析GC类型","title_tokens":["分析","gc","通过","日志","类型"]},{"location":"handler/","text":"handler原理","text_tokens":["handler","原理"],"title":"Handler原理","title_tokens":["handler","原理"]},{"location":"handler/#handler","text":"","text_tokens":[],"title":"handler原理","title_tokens":["handler","原理"]},{"location":"knowledge/","text":"","text_tokens":[],"title":"Knowledge","title_tokens":["knowledge"]},{"location":"kotuis/","text":"introduce why kotlin? concise safe interoperable","text_tokens":["why"," ","interoperable","kotlin","?","concise","introduce","safe"],"title":"学习笔记","title_tokens":["学习","笔记"]},{"location":"kotuis/#introduce","text":"why kotlin? concise safe interoperable","text_tokens":["why"," ","interoperable","kotlin","?","concise","safe"],"title":"introduce","title_tokens":["introduce"]},{"location":"threadPool/","text":"含义 装线程的池子，目的是管理线程，避免大量创建线程，增加开销，影响响应速度。 //五个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) //六个参数的构造函数-1 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) //六个参数的构造函数-2 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) //七个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize -> 该线程池中核心线程数最大值 核心线程：在创建完线程池之后，核心线程先不创建，在接到任务之后创建核心线程。并且会一直存在于线程池中（即使这个线程啥都不干），有任务要执行时，如果核心线程没有被占用，会优先用核心线程执行任务。数量一般情况下设置为CPU核数的二倍即可。 maximumPoolSize -> 该线程池中线程总数最大值 线程总数=核心线程数+非核心线程数。 非核心线程：简单理解，即核心线程都被占用，但还有任务要做，就创建非核心线程。 keepAliveTime -> 非核心线程闲置超时时长 这个参数可以理解为，任务少，但池中线程多，非核心线程不能白养着，超过这个时间不工作的就会被干掉，但是核心线程会保留。 TimeUnit -> keepAliveTime的单位 这个参数是个枚举类型 * DAYS * HOURS * MINUTES * SECONDS * MILLISECONDS * MICROSECONDS * NANOSECONDS微毫秒 BlockingQueue workQueue -> 线程池中的任务队列 默认情况下，任务进来之后先分配给核心线程执行，核心线程如果都被占用，并不会立刻开启非核心线程执行任务，而是将任务插入任务队列等待执行，核心线程会从任务队列取任务来执行，任务队列可以设置最大值，一旦插入的任务足够多，达到最大值，才会创建非核心线程执行任务。 常见的workQueue有四种： SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现<线程数达到了maximumPoolSize而不能新建线程>的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大。 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前已经创建的核心线程数小于线程池的核心线程数上限，则新建线程(核心线程)处理任务；如果当前已经创建的核心线程数等于核心线程数上限，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误，或是执行实现定义好的饱和策略。 DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。 ThreadFactory threadFactory -> 创建线程的工厂 可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。 RejectedExecutionHandler handler -> 饱和策略 这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy， 表示无法处理新任务，并抛出 RejectedExecutionException 异常。此外还有3种策略，它们分别如下。 CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 DiscardPolicy：不能执行的任务，并将该任务删除。 DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。 如何使用线程池 以上是原理，线面说用法，java给我们提供了四种线程池 FixedThreadPool * CachedThreadPool * SingleThreadExecutor * ScheduledThreadPool FixedThreadPool 可重用固定线程数的线程池，超出的线程会在队列中等待，在Executors类中我们可以找到创建方式 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } FixedThreadPool的corePoolSize和maximumPoolSize都设置为参数nThreads，也就是只有固定数量的核心线程，不存在非核心线程。keepAliveTime为0L表示多余的线程立刻终止，因为不会产生多余的线程，所以这个参数是无效的。FixedThreadPool的任务队列采用的是LinkedBlockingQueue。 创建线程池的方法，在我们的程序中只需要，后面其他种类的同理： public static void main(String[] args) { // 参数是要线程池的线程最大值 ExecutorService executorService = Executors.newFixedThreadPool(10); } CachedThreadPool CachedThreadPool是一个根据需要创建线程的线程池。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } CachedThreadPool的corePoolSize是0，maximumPoolSize是Int的最大值，也就是说CachedThreadPool没有核心线程，全部都是非核心线程，并且没有上限。keepAliveTime是60秒，就是说空闲线程等待新任务60秒，超时则销毁。此处用到的队列是阻塞队列SynchronousQueue,这个队列没有缓冲区，所以其中最多只能存在一个元素,有新的任务则阻塞等待。 SingleThreadExecutor SingleThreadExecutor是使用单个线程工作的线程池。其创建源码如下 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } 我们可以看到总线程数和核心线程数都是1，所以就只有一个核心线程。该线程池才用链表阻塞队列LinkedBlockingQueue，先进先出原则，所以保证了任务的按顺序逐一进行。 ScheduledThreadPool ScheduledThreadPool是一个能实现定时和周期性任务的线程池，它的创建源码如下： public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } 可以看出corePoolSize是传进来的固定值，maximumPoolSize无限大，因为采用的队列DelayedWorkQueue是无解的，所以maximumPoolSize参数无效。该线程池执行如下： 当执行scheduleAtFixedRate或者scheduleWithFixedDelay方法时，会向DelayedWorkQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask(任务的包装类)，并会检查运行的线程是否达到corePoolSize。如果没有则新建线程并启动ScheduledFutureTask，然后去执行任务。 如果运行的线程达到了corePoolSize时，则将任务添加到DelayedWorkQueue中。DelayedWorkQueue会将任务进行排序，先要执行的任务会放在队列的前面。在跟此前介绍的线程池不同的是，当执行完任务后，会将ScheduledFutureTask中的time变量改为下次要执行的时间并放回到DelayedWorkQueue中。","text_tokens":["：","scheduledexecutorservice","工厂","seconds","理解","大量","只能","最大","原理","构造","然后","integer","处理","被","使用","或者","大值","优先","/","六个","全部都是","不同","类型","非核心","delayqueue","！","你","maximumpoolsize","后面","就是","种类","常见","cachedthreadpool","设定","用到","它们","单个","callerrunspolicy","只","能",";","分配","无解","scheduleatfixedrate","固定","检查","[","delayedworkqueue","如果","少","newfixedthreadpool","多","1","并放","fixedthreadpool","原则","阻塞","怎么","等待","则",".","重用","看出","占用","数量","当前","提供","无须","rejectedexecutionexception","return","饱和","采取","60l","取","传","下次","四种","arrayblockingqueue","线面","之后","到","所有","出来","并且","hours","改为","管理","说","都","出现","永远","进去","每个","于","限制","能够","blockingqueue","删除","那","介绍","runnablescheduledfuture","newcachedthreadpool","一般","此外","数都","但","设置","一个","意味","value","进入","10","秒","无法","执行","影响","微","用者","是否","错误","不能","定义","static","程","不会","和","void","超时","corepoolsize","放在","）","机制","workqueue","-","{","了","*","当","运行","添加","新","核心","二倍","终止","反馈","程序","newsinglethreadexecutor","需要","string","接口","先","中","main","已满","但池","java","啥","=","即","args","从","跟","用","无限","如下","以上","executors","60","discardoldestpolicy","milliseconds","五个","策略","成","指定","因为","所","就是说","足够","保证","用法","装","闲置","而是","先进","非核","延时","调用","executorservice","看到","(","可","？","完","是",")","3","全部","下","runnable","时间","干掉","函数","newscheduledthreadpool",">","达到","nthreads","长","后","scheduledthreadpool","干","着","keepalivetime","默认","简单","可以","<","days","没有","最近","目的","接收","源码","如何","int","周期","它","超过","应对","其","并会","去","启动","队列"," ","。","固定值","先进先出","池中","synchronousqueue","必须","名字","首先","其他","缓冲区","minutes","即可","但是","缓冲","unit","顺序","数","timeunit","给","按","linkedblockingqueue","}","同理",",","只有","空闲","进行","在","我们","个","等于","链表","含义","0l","速度","threadfactory","立刻","所以","种","方式","或是","池子","要","即使","小于","元素","包装","microseconds","（","构造函数","，","会","新建","响应速度","+","参数","值","此","scheduledfuturetask","也","多余","最","无效","_","所在","该","找到","由于","也就是说","才","保留","handler","产生","public","这个","接到","开销","根据","这","满","异常","nanoseconds","好","白养","threadpoolexecutor","此处","rejectedexecutionhandler","]","就","限定","开启","中线","七个","其中","long","提交","无限大","的","避免","discardpolicy","意味着","有","排序","前面","控制","池","时候","此前","程多","而","毫秒","丢弃","向","内","插入","总线","2","finalizabledelegatedexecutorservice","time","cpu","schedulewithfixeddelay","响应","进来","等候","不","采用","已经","为","来","最大值","减缓","还有","0","定时","线程","一直","增加","上限","任务","创建","将","类中","发生","变量","做","singlethreadexecutor","枚举","实现","销毁","池才","情况","又","一旦","表示","分别","导致","失效","scheduledthreadpoolexecutor","delayed","时","超出","程数","max","方法","回到","周期性","入队","逐一","；","abordpolicy","长度","总数","单位","new","类","直接","怎么办","工作","抛出","核数","并","调用者","存在","为了"],"title":"线程池","title_tokens":["线程","池"]},{"location":"threadPool/#_1","text":"装线程的池子，目的是管理线程，避免大量创建线程，增加开销，影响响应速度。 //五个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) //六个参数的构造函数-1 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) //六个参数的构造函数-2 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) //七个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize -> 该线程池中核心线程数最大值 核心线程：在创建完线程池之后，核心线程先不创建，在接到任务之后创建核心线程。并且会一直存在于线程池中（即使这个线程啥都不干），有任务要执行时，如果核心线程没有被占用，会优先用核心线程执行任务。数量一般情况下设置为CPU核数的二倍即可。 maximumPoolSize -> 该线程池中线程总数最大值 线程总数=核心线程数+非核心线程数。 非核心线程：简单理解，即核心线程都被占用，但还有任务要做，就创建非核心线程。 keepAliveTime -> 非核心线程闲置超时时长 这个参数可以理解为，任务少，但池中线程多，非核心线程不能白养着，超过这个时间不工作的就会被干掉，但是核心线程会保留。 TimeUnit -> keepAliveTime的单位 这个参数是个枚举类型 * DAYS * HOURS * MINUTES * SECONDS * MILLISECONDS * MICROSECONDS * NANOSECONDS微毫秒 BlockingQueue workQueue -> 线程池中的任务队列 默认情况下，任务进来之后先分配给核心线程执行，核心线程如果都被占用，并不会立刻开启非核心线程执行任务，而是将任务插入任务队列等待执行，核心线程会从任务队列取任务来执行，任务队列可以设置最大值，一旦插入的任务足够多，达到最大值，才会创建非核心线程执行任务。 常见的workQueue有四种： SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现<线程数达到了maximumPoolSize而不能新建线程>的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大。 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前已经创建的核心线程数小于线程池的核心线程数上限，则新建线程(核心线程)处理任务；如果当前已经创建的核心线程数等于核心线程数上限，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误，或是执行实现定义好的饱和策略。 DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。 ThreadFactory threadFactory -> 创建线程的工厂 可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。 RejectedExecutionHandler handler -> 饱和策略 这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy， 表示无法处理新任务，并抛出 RejectedExecutionException 异常。此外还有3种策略，它们分别如下。 CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 DiscardPolicy：不能执行的任务，并将该任务删除。 DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。","text_tokens":["设置","keepalivetime","一个","value","意味","：","默认","进入","好","简单","可以","白养","<","threadpoolexecutor","rejectedexecutionhandler","就","days","没有","工厂","无法","最近","目的","接收","限定","seconds","理解","开启","大量","执行","int","影响","最大","中线","七个","微","它","long","超过","用者","错误","不能","定义","构造","应对","提交","无限大","的","程","避免","不会","integer","处理","被","abordpolicy","使用","discardpolicy","和","意味着","超时","corepoolsize","大值","有","优先","队列","/","）","机制","。"," ","workqueue","六个","-","nanoseconds","池中","了","*","类型","当","添加","新","非核心","delayqueue","控制","核心","池","！","二倍","synchronousqueue","时候","你","反馈","maximumpoolsize","程多","必须","首先","名字","而","minutes","即可","毫秒","但是","常见","unit","丢弃","数","timeunit","给","内","设定","插入","总线","2","linkedblockingqueue",",","接口","先","中","只有","cpu","已满","但池","它们","callerrunspolicy","在","啥","响应","=","进来","即","等候","不","分配","个","从","等于","用","无限","为","已经","如果","少","来","如下","discardoldestpolicy","milliseconds","最大值","1","多","减缓","五个","速度","还有","threadfactory","立刻","线程","所以","策略","一直","增加","种","成","上限","怎么","等待","指定","则","任务","创建","将",".","因为","或是","池子","发生","要","即使","小于","元素","做","所","microseconds","（","枚举","占用","实现","数量","足够","构造函数","保证","当前","提供","无须","装","rejectedexecutionexception","情况","闲置","又","一旦","表示","饱和","，","而是","非核","会","延时","新建","导致","采取","分别","调用","响应速度","+","参数","取","失效","传","值","delayed","此","时","(","四种","也","之后","arrayblockingqueue","到","所有","？","_","出来","该","所在","程数","由于","max","并且","hours","完","入队","才","管理","都","是","保留","出现","；",")","永远","总数","单位","长度","handler","下","进去","每个","3","runnable","public","时间","这个","直接","怎么办","工作","于","限制","能够","blockingqueue","删除","抛出","核数","并","那","接到","干掉","函数",">","达到","调用者","长","存在","开销","为了","干","这","满","一般","异常","此外","着","但"],"title":"含义","title_tokens":["含义"]},{"location":"threadPool/#_2","text":"以上是原理，线面说用法，java给我们提供了四种线程池 FixedThreadPool * CachedThreadPool * SingleThreadExecutor * ScheduledThreadPool FixedThreadPool 可重用固定线程数的线程池，超出的线程会在队列中等待，在Executors类中我们可以找到创建方式 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } FixedThreadPool的corePoolSize和maximumPoolSize都设置为参数nThreads，也就是只有固定数量的核心线程，不存在非核心线程。keepAliveTime为0L表示多余的线程立刻终止，因为不会产生多余的线程，所以这个参数是无效的。FixedThreadPool的任务队列采用的是LinkedBlockingQueue。 创建线程池的方法，在我们的程序中只需要，后面其他种类的同理： public static void main(String[] args) { // 参数是要线程池的线程最大值 ExecutorService executorService = Executors.newFixedThreadPool(10); } CachedThreadPool CachedThreadPool是一个根据需要创建线程的线程池。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } CachedThreadPool的corePoolSize是0，maximumPoolSize是Int的最大值，也就是说CachedThreadPool没有核心线程，全部都是非核心线程，并且没有上限。keepAliveTime是60秒，就是说空闲线程等待新任务60秒，超时则销毁。此处用到的队列是阻塞队列SynchronousQueue,这个队列没有缓冲区，所以其中最多只能存在一个元素,有新的任务则阻塞等待。 SingleThreadExecutor SingleThreadExecutor是使用单个线程工作的线程池。其创建源码如下 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } 我们可以看到总线程数和核心线程数都是1，所以就只有一个核心线程。该线程池才用链表阻塞队列LinkedBlockingQueue，先进先出原则，所以保证了任务的按顺序逐一进行。 ScheduledThreadPool ScheduledThreadPool是一个能实现定时和周期性任务的线程池，它的创建源码如下： public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } 可以看出corePoolSize是传进来的固定值，maximumPoolSize无限大，因为采用的队列DelayedWorkQueue是无解的，所以maximumPoolSize参数无效。该线程池执行如下： 当执行scheduleAtFixedRate或者scheduleWithFixedDelay方法时，会向DelayedWorkQueue添加一个实现RunnableScheduledFuture接口的ScheduledFutureTask(任务的包装类)，并会检查运行的线程是否达到corePoolSize。如果没有则新建线程并启动ScheduledFutureTask，然后去执行任务。 如果运行的线程达到了corePoolSize时，则将任务添加到DelayedWorkQueue中。DelayedWorkQueue会将任务进行排序，先要执行的任务会放在队列的前面。在跟此前介绍的线程池不同的是，当执行完任务后，会将ScheduledFutureTask中的time变量改为下次要执行的时间并放回到DelayedWorkQueue中。","text_tokens":["设置","keepalivetime","一个","value","：","可以","<","threadpoolexecutor","10","]","此处","就","scheduledexecutorservice","没有","秒","源码","seconds","只能","执行","周期","int","最大","它","其中","是否","原理","static","无限大","然后","的","不会","integer","使用","和","void","其","或者","并会","去","超时","corepoolsize","启动","放在","队列","大值","有","/","排序"," ","。","固定值","先进先出","{","了","全部都是","前面","*","当","不同","运行","添加","新","非核心","核心","池","synchronousqueue","终止","此前","maximumpoolsize","后面","就是","其他","缓冲区","程序","种类","缓冲","newsinglethreadexecutor","顺序","需要","cachedthreadpool","数","timeunit","向","给","按","string","linkedblockingqueue","finalizabledelegatedexecutorservice","用到","}","总线","同理",",","time","接口","中","只有","main","空闲","schedulewithfixeddelay","先","进行","单个","java","只","跟","能","在",";","=","进来","args","不","我们","无解","采用","scheduleatfixedrate","固定","链表","检查","[","如下","executors","以上","为","60","用","无限","delayedworkqueue","如果","newfixedthreadpool","milliseconds","最大值","多","1","0l","并放","0","定时","立刻","fixedthreadpool","线程","所以","原则","阻塞","上限","等待","方式","则","任务","创建",".","将","类中","因为","重用","变量","要","元素","看出","singlethreadexecutor","包装","就是说","实现","数量","保证","用法","销毁","提供","池才","return","表示","，","先进","非核","会","新建","60l","executorservice","参数","传","scheduledthreadpoolexecutor","看到","scheduledfuturetask","下次","时","线面","四种","(","也","多余","最","无效","可","超出","到","_","该","找到","程数","max","方法","回到","并且","也就是说","周期性","完","改为","说","逐一","是","都",")","全部","new","类","runnable","产生","public","时间","这个","工作","并","介绍","newscheduledthreadpool",">","nthreads","达到","存在","runnablescheduledfuture","根据","后","scheduledthreadpool","newcachedthreadpool","数都"],"title":"如何使用线程池","title_tokens":["使用","线程","池","如何"]},{"location":"touchEvent/","text":"事件分发","text_tokens":["分发","事件"],"title":"事件分发","title_tokens":["分发","事件"]},{"location":"touchEvent/#_1","text":"","text_tokens":[],"title":"事件分发","title_tokens":["分发","事件"]},{"location":"constructure/mvc/","text":"MVC View：XML布局文件。 Model：实体模型（数据的获取、存储、数据状态变化）。 Controller：对应于Activity，处理数据、业务和UI。 从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个Model-View（Activity:View&Controller）的结构。 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这是苹果开发者文档中摘过来的图片，表明了三者之间的关系，简单描述了三者作用Model：数据模型，用来存储数据View：视图界面，用来展示UI界面和响应用户交互Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互他们工作和关系看起来是如此清晰，是一种非常好的设计思想，是的，首先声明MVC是一个非常好的架构思想。","text_tokens":["一个","：","归","转载","关系","简单","好","联系","文件","控制器","管家","行为","就","还是","界面","一种","作者","只是","著作权","清晰","商业","大量","只能","非商业","业务","苹果","的","说法","activity","处理","和","作用","多数","符合","改变","view","）","android"," ","。","&","-","注明","用户","了","非常","作为","大多","上面","对应","逻辑","控制","写","！","他们","授权","首先","model","出处","最终","表明","但是","、","贴切","数据","获取","之间","存储","爆炸","中","图片","布局","模型","设计","在","controller","监听","响应","功能","开发者","我们","实体模型","从","如此","太弱","过","所以","中摘","声明","xml","过来","吧","acitivty","本身","（","数据模型","纯粹","这样","看起","情况","遇到","，","角色","开发","导致",":","实体","展示","相信","数以","文档","思想","(","这是","所有","大管家","状态","千行","获得","两个","著作","架构","结构","都","是","大管","充当",")","用来","ui","看起来","大多数","大","来看","直接","这个","代码","三者","起来","工作","描述","于","视图","mvc","交互","更","其实","变化","请"],"title":"MVC","title_tokens":["mvc"]},{"location":"constructure/mvc/#mvc","text":"View：XML布局文件。 Model：实体模型（数据的获取、存储、数据状态变化）。 Controller：对应于Activity，处理数据、业务和UI。 从上面这个结构来看，Android本身的设计还是符合MVC架构的，但是Android中纯粹作为View的XML视图功能太弱，我们大量处理View的逻辑只能写在Activity中，这样Activity就充当了View和Controller两个角色，直接导致Activity中的代码大爆炸。相信大多数Android开发者都遇到过一个Acitivty数以千行的代码情况吧！所以，更贴切的说法是，这个MVC结构最终其实只是一个Model-View（Activity:View&Controller）的结构。 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这是苹果开发者文档中摘过来的图片，表明了三者之间的关系，简单描述了三者作用Model：数据模型，用来存储数据View：视图界面，用来展示UI界面和响应用户交互Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互他们工作和关系看起来是如此清晰，是一种非常好的设计思想，是的，首先声明MVC是一个非常好的架构思想。","text_tokens":["一个","：","归","转载","关系","简单","好","联系","文件","控制器","管家","行为","就","还是","界面","一种","作者","只是","著作权","清晰","商业","大量","只能","非商业","业务","苹果","的","说法","activity","处理","和","作用","多数","符合","改变","view","）","android","。"," ","&","-","注明","用户","了","非常","作为","大多","上面","对应","逻辑","控制","写","！","他们","授权","首先","model","出处","最终","表明","但是","、","贴切","数据","获取","之间","存储","爆炸","中","图片","布局","模型","设计","在","controller","监听","响应","功能","开发者","我们","实体模型","从","如此","太弱","过","所以","中摘","声明","xml","过来","吧","acitivty","本身","（","数据模型","纯粹","这样","看起","情况","遇到","，","角色","开发","导致",":","实体","展示","相信","数以","文档","思想","(","这是","所有","大管家","状态","千行","获得","两个","著作","架构","结构","都","是","大管","充当",")","用来","ui","看起来","大多数","大","来看","直接","这个","代码","三者","起来","工作","描述","于","视图","mvc","交互","更","其实","变化","请"],"title":"MVC","title_tokens":["mvc"]},{"location":"constructure/mvp/","text":"mvp","text_tokens":["mvp"],"title":"Mvp","title_tokens":["mvp"]},{"location":"constructure/mvp/#mvp","text":"","text_tokens":[],"title":"mvp","title_tokens":["mvp"]},{"location":"constructure/mvvm/","text":"mvvm","text_tokens":["mvvm"],"title":"Mvvm","title_tokens":["mvvm"]},{"location":"constructure/mvvm/#mvvm","text":"","text_tokens":[],"title":"mvvm","title_tokens":["mvvm"]},{"location":"customView/customCombinationView/","text":"第一步定义你要复用的布局 <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"> <TextView android:id=\"@+id/tv_left_attribute\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/tv_order_goods_name\" android:textSize=\"@dimen/edge_14\" android:textColor=\"@color/color_3f3f3f\" android:layout_marginTop=\"@dimen/edge_15\" android:layout_centerVertical=\"true\"/> <TextView android:id=\"@+id/tv_right_attribute\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"@color/color_808080\" android:textSize=\"@dimen/edge_14\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\"/> </RelativeLayout> 第二步定义自定义属性(value下新建attrs) <resources> <declare-styleable name=\"SimpleAttribute\"> <attr name=\"left_text_color\" format=\"color\"/> <attr name=\"left_text_size\" format=\"dimension\"/> <attr name=\"left_text\" format=\"string\"/> <attr name=\"right_text_color\" format=\"color\"/> <attr name=\"right_text_size\" format=\"dimension\"/> <attr name=\"right_text\" format=\"string\"/> </declare-styleable> </resources> 第三步自定义一个View根据需求继承不同的viewGroup,如：RelativeLayout、LinearLayout等,复写两个构造方法 public class SimpleAttribute extends RelativeLayout { 初始化控件 private void initView(Context context) { View.inflate(context, R.layout.attribute_layout, this); mLeftTv = this.findViewById(R.id.tv_left_attribute); mRightTv = this.findViewById(R.id.tv_right_attribute); } 重写构造方法，在构造方法中初始化控件，并引用自定义属性。 private void useCustomAttribute(Context context, AttributeSet attrs) { TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.SimpleAttribute); int leftTextColor = typedArray.getColor(R.styleable.SimpleAttribute_left_text_color, getResources().getColor(R.color.black)); setLeftTextColor(leftTextColor); float leftTextSize = typedArray.getDimension(R.styleable.SimpleAttribute_left_text_size, getResources().getDimension(R.dimen.edge_14)); setLeftTextSize(leftTextSize); String leftText = typedArray.getString(R.styleable.SimpleAttribute_left_text); setLeftText(leftText); int rightTextColor = typedArray.getColor(R.styleable.SimpleAttribute_right_text_color, getResources().getColor(R.color.black)); setRightTextColor(rightTextColor); float rightTextSize = typedArray.getDimension(R.styleable.SimpleAttribute_right_text_size, getResources().getDimension(R.dimen.edge_14)); setRightTextSize(rightTextSize); String rightText = typedArray.getString(R.styleable.SimpleAttribute_right_text); setRightText(rightText); } 完整代码： /** * author : luis * e-mail : luis.gong@cardinfolink.com * date : 2020/7/17 19:39 * desc : */ public class SimpleAttribute extends RelativeLayout { private TextView mLeftTv; private TextView mRightTv; public SimpleAttribute(Context context) { super(context); initView(context); } public SimpleAttribute(Context context, AttributeSet attrs) { super(context, attrs); useCustomAttribute(context, attrs); } private void initView(Context context) { View.inflate(context, R.layout.attribute_layout, this); mLeftTv = this.findViewById(R.id.tv_left_attribute); mRightTv = this.findViewById(R.id.tv_right_attribute); } private void useCustomAttribute(Context context, AttributeSet attrs) { TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.SimpleAttribute); int leftTextColor = typedArray.getColor(R.styleable.SimpleAttribute_left_text_color, getResources().getColor(R.color.black)); setLeftTextColor(leftTextColor); float leftTextSize = typedArray.getDimension(R.styleable.SimpleAttribute_left_text_size, getResources().getDimension(R.dimen.edge_14)); setLeftTextSize(leftTextSize); String leftText = typedArray.getString(R.styleable.SimpleAttribute_left_text); setLeftText(leftText); int rightTextColor = typedArray.getColor(R.styleable.SimpleAttribute_right_text_color, getResources().getColor(R.color.black)); setRightTextColor(rightTextColor); float rightTextSize = typedArray.getDimension(R.styleable.SimpleAttribute_right_text_size, getResources().getDimension(R.dimen.edge_14)); setRightTextSize(rightTextSize); String rightText = typedArray.getString(R.styleable.SimpleAttribute_right_text); setRightText(rightText); } public void setLeftTextSize(float leftTextSize) { mLeftTv.setTextSize(leftTextSize); } public void setLeftTextColor(int leftTextColor) { mLeftTv.setTextColor(leftTextColor); } public void setLeftText(String leftText){ mLeftTv.setText(leftText); } public void setRightTextSize(float rightTextSize) { mRightTv.setTextSize(rightTextSize); } public void setRightTextColor(int rightTextColor) { mRightTv.setTextColor(rightTextColor); } public void setRightText(String rightText){ mRightTv.setText(rightText); } }","text_tokens":["一个","value","：","@","<","3f3f3f","attrs","19","wrap","layout","width","int","content","float","simpleattribute","http","定义","initview","构造","的","schemas","name","obtainstyledattributes","14","第二","settextcolor","void","relativelayout","attr","/","attribute","textsize","view","android"," ","。","-","{","不同","*","declare","需求","808080","context","r","lefttext","centervertical","你","resources","tv","black","15","mlefttv","class","date","super","mrighttv","righttext","、","第一步","textcolor","cardinfolink","string","color","}","引用","mail",",","format","getdimension","lefttextsize","重写","usecustomattribute","com","中","布局","viewgroup","linearlayout","res","初始化","7","在","settext","textview","继承",";","attributeset","setlefttext","=","settextsize","控件","left","自定义","extends","复用","二步","inflate","dimension","第一","复写","\"","match","setlefttextcolor","完整",".","height","getstring","一步","如","righttextcolor","构造方法","要","righttextsize","margintop","parent","private","xmlns","17","edge","lefttextcolor","，","this","e","getcolor","新建","39",":","等","+","luis","setrighttext","(","size","true","_","getresources","dimen","findviewbyid","方法","setrighttextcolor","author","id","order","两个","goods","第三","自定","typedarray","属性",")","styleable","下","public","2020","代码","apk","三步","desc","第二步","setrighttextsize","并","right",">","第三步","gong","根据","setlefttextsize","alignparentright","text","初始"],"title":"自定义组合控件","title_tokens":["组合","控件","自定","定义","自定义"]},{"location":"customView/customView/","text":"自定义View","text_tokens":["自定","定义","view","自定义"],"title":"自定义View","title_tokens":["自定","定义","view","自定义"]},{"location":"customView/customView/#view","text":"","text_tokens":[],"title":"自定义View","title_tokens":["自定","定义","view","自定义"]},{"location":"designpattern/builder/","text":"定义 将一个复杂对象的构建和表示分离，使得同样的构建过程可以构建不同的对象。 经典例子 创建对象传递参数的时候往往通过构造函数来传，，随着构造函数的增加，代码会很难编写。 例：生产组装一辆、台电脑 public class computer{ private final String display； private final String keyBoard； private final String mouse； public static class Builder{ //必选字段 private final String display； private final String keyBoard； //可选字段 private final String mouse； public Builder(String display, String keyBoard){ this.display = display; this.keyBoard = keyBoard; } public Builder mouse(String mouse){ this.mouse = mouse; return this; } public Computer build(){ return new Computer(this); } } private Computer (Builder builder){ display = builder.display; keyBoard = builder.keyBoard; mouse = builder.mouse; } } 测试代码 Computer computer = new Computer.Builder(\"三星\",\"华为\") .mouse(\"苹果\") .build(); Android 采用Builder模式的AlertDialog AlertDialog.Builder dialog = new AlertDialog.Nuilder(this); dialog.setTitle(\"关于我们\") .setMessage(\"大家好!\") .creat() .show(); 优缺点 链式调用抑郁阅读和编写，出错难以debug","text_tokens":["一个","：","往往","好","例","可以","组装","测试代码","mouse","模式","creat","大家","定义","构造","static","苹果","的","出错","debug","和","抑郁","电脑","分离","settitle","!","/","android"," ","。","构建","{","不同","必选","阅读","时候","通过","很","难","class","、","段","复杂","nuilder","string","}","来传",",","选字","过程","缺点",";","一辆","=","生产","我们","采用","builder","对象","编写","增加","\"","将","创建",".","链式","build","display","private","构造函数","字","使得","return","表示","，","难以","this","会","调用","dialog","参数","同样","alertdialog","三星","(","例子","可","优缺点","台","关于","华为","传递","创建对象","随着","final","；","keyboard",")","new","经典","public","代码","setmessage","函数","computer","show","测试"],"title":"Builder","title_tokens":["builder"]},{"location":"designpattern/builder/#_1","text":"将一个复杂对象的构建和表示分离，使得同样的构建过程可以构建不同的对象。","text_tokens":["表示","一个","的","，","过程","。","和","将","可以","复杂","对象","构建","分离","同样","不同","使得"],"title":"定义","title_tokens":["定义"]},{"location":"designpattern/builder/#_2","text":"创建对象传递参数的时候往往通过构造函数来传，，随着构造函数的增加，代码会很难编写。 例：生产组装一辆、台电脑 public class computer{ private final String display； private final String keyBoard； private final String mouse； public static class Builder{ //必选字段 private final String display； private final String keyBoard； //可选字段 private final String mouse； public Builder(String display, String keyBoard){ this.display = display; this.keyBoard = keyBoard; } public Builder mouse(String mouse){ this.mouse = mouse; return this; } public Computer build(){ return new Computer(this); } } private Computer (Builder builder){ display = builder.display; keyBoard = builder.keyBoard; mouse = builder.mouse; } } 测试代码 Computer computer = new Computer.Builder(\"三星\",\"华为\") .mouse(\"苹果\") .build(); Android 采用Builder模式的AlertDialog AlertDialog.Builder dialog = new AlertDialog.Nuilder(this); dialog.setTitle(\"关于我们\") .setMessage(\"大家好!\") .creat() .show();","text_tokens":["：","往往","好","例","组装","测试代码","mouse","模式","creat","大家","构造","static","苹果","的","电脑","settitle","!","/","android","。"," ","{","必选","时候","通过","很","难","class","、","段","nuilder","string","}","来传",",","选字",";","一辆","=","生产","我们","采用","builder","对象","编写","增加","\"","创建",".","build","display","private","构造函数","字","return","，","this","会","dialog","参数","alertdialog","三星","(","可","台","关于","华为","传递","创建对象","随着","final","；","keyboard",")","new","public","代码","setmessage","函数","computer","show","测试"],"title":"经典例子","title_tokens":["经典","例子"]},{"location":"designpattern/builder/#_3","text":"链式调用抑郁阅读和编写，出错难以debug","text_tokens":["，","出错","难以","debug","调用","和","链式","抑郁","编写","阅读"],"title":"优缺点","title_tokens":["缺点","优缺点"]},{"location":"designpattern/factory/","text":"定义 普通工厂模式：生产具体的产品，创建的产品是类(class) 抽象工厂：生产抽象产品，创建的产品是接口(interface) 经典例子 优缺点 降低耦合，很好的扩展性 缺点是不太容易扩展新的产品类，需要具体的改产品类和工厂类。","text_tokens":["(","例子","：","好","降低","抽象","优缺点","很","工厂","class","需要","模式","创建","扩展性","是",")","定义","类","interface","经典","普通","的","产品","容易","和","具体","接口","太","缺点","，"," ","。","生产","耦合","扩展","展性","不","改","新"],"title":"工厂","title_tokens":["工厂"]},{"location":"designpattern/factory/#_1","text":"普通工厂模式：生产具体的产品，创建的产品是类(class) 抽象工厂：生产抽象产品，创建的产品是接口(interface)","text_tokens":["(","：","抽象","工厂","class","模式","创建","是",")","类","interface","普通","的","产品","具体","接口","，"," ","生产"],"title":"定义","title_tokens":["定义"]},{"location":"designpattern/factory/#_2","text":"","text_tokens":[],"title":"经典例子","title_tokens":["经典","例子"]},{"location":"designpattern/factory/#_3","text":"降低耦合，很好的扩展性 缺点是不太容易扩展新的产品类，需要具体的改产品类和工厂类。","text_tokens":["好","降低","很","工厂","需要","扩展性","是","类","的","产品","容易","和","具体","太","缺点","，"," ","。","耦合","扩展","展性","不","改","新"],"title":"优缺点","title_tokens":["缺点","优缺点"]},{"location":"designpattern/observer/","text":"定义 基于事件和响应的设计模式 简单来说多个观察者同时观察一个对象，当对象发生变化的时候观察者能够回调自身的方法更新自己。 1. 定义一个观察者接口 2. 观察者实现观察者接口 3. 定义被观察者接口或者抽象类，里面有addObserver(Observer observer),removeObserver(Observer observer),notifyObserver(),调用notifyObserver(),遍历list<Observer>, 回调onserver里面的方法。 经典的例子 游戏中英雄，在地图中中走，捡宝盒增加技能或者踩到陷阱减生命力的。 在这个例子中，宝石，宝剑和陷阱属于观察者ConcreteObserver,英雄属于被观察者， 如何建立关系呢？ 首先有很多的英雄和很多的道具，抽取共同的行为 Public interface Observer{ void update(); } 宝石 public Stone implement Observer{ public void update(){ if(inrange()){ System.out.print(\"获取到宝石\"); } } public Boolean inrange(){ //判断是否在距离内 return true; } } 陷阱 public Trap implement Observer{ public void update(){ if(){ System.out.print(\"踩到陷阱\"); } } } 定义抽象类 public abstract Subject{ private List<Observer> observerList = new ArrayList<Observer>(); public void addObserver(Observer observer){ observerList.add(observer); } public void deleteObserver(Observer observer){ observerList.remove(observer); } public void notifyObserver(){ for(Observer observer: observerList){ observer.update(); } } } 定义英雄 public class Hero extend Subject{ public void run(){ notifyObserver(); } } 具体调用 ``` public class client{ public static void main(String[] args){ //初始化对象 Hero hero = new Hero(); Stone stone = new Stone(); Trap trap = new Trap(); hero.addObserver(stone); hero.addObserver(trap); hero.run(); } } 代码输出如下： 获取到宝石 踩到陷阱 ``` 优缺点 解耦观察者被观察者","text_tokens":["遍历","一个","run","add","：","发生变化","关系","简单","hero","<","行为","更新","]","trap","implement","onserver","解","模式","如何","判断","abstract","是否","减","定义","interface","static","的","被","和","游戏","void","或者","有","技能","生命","/"," ","。","抽取","{","当","英雄","生变","里面","设计模式","concreteobserver","回调","时候","首先","subject","class","输出","list","for","捡","内","自身","事件","抽象类","很多","2","共同","string","}","client","建立","获取",",","接口","中","main","设计","初始化","在","boolean","缺点","多个","if","update","响应",";","观察者","=","args","观察","addobserver","来说","notifyobserver","基于","[","如下","1","deleteobserver","对象","print","system","arraylist","增加","\"",".","发生","private","实现","道具","具体","stone","地图","return","extend","，","调用",":","宝石","宝剑","remove","耦","(","例子","属于","到","？","inrange","true","抽象","优缺点","踩","方法","`","observerlist","距离","中中","呢","3",")","new","经典","public","这个","代码","生命力","能够","removeobserver","observer","宝盒","自己","走","陷阱",">","out","同时","变化","初始"],"title":"观察者","title_tokens":["观察","观察者"]},{"location":"designpattern/observer/#_1","text":"基于事件和响应的设计模式 简单来说多个观察者同时观察一个对象，当对象发生变化的时候观察者能够回调自身的方法更新自己。 1. 定义一个观察者接口 2. 观察者实现观察者接口 3. 定义被观察者接口或者抽象类，里面有addObserver(Observer observer),removeObserver(Observer observer),notifyObserver(),调用notifyObserver(),遍历list<Observer>, 回调onserver里面的方法。","text_tokens":["遍历","一个","生变","(","里面","设计模式","notifyobserver","回调","发生变化","时候","简单","1","<","对象","更新","抽象","方法","list","onserver","模式",".","自身","事件","发生","3","2","抽象类","定义",")","的",",","实现","被","和","接口","能够","或者","removeobserver","observer","设计","自己","有","，","多个",">","响应","调用"," ","观察者","。","同时","观察","addobserver","当","变化","来说","基于"],"title":"定义","title_tokens":["定义"]},{"location":"designpattern/observer/#_2","text":"游戏中英雄，在地图中中走，捡宝盒增加技能或者踩到陷阱减生命力的。 在这个例子中，宝石，宝剑和陷阱属于观察者ConcreteObserver,英雄属于被观察者， 如何建立关系呢？ 首先有很多的英雄和很多的道具，抽取共同的行为 Public interface Observer{ void update(); } 宝石 public Stone implement Observer{ public void update(){ if(inrange()){ System.out.print(\"获取到宝石\"); } } public Boolean inrange(){ //判断是否在距离内 return true; } } 陷阱 public Trap implement Observer{ public void update(){ if(){ System.out.print(\"踩到陷阱\"); } } } 定义抽象类 public abstract Subject{ private List<Observer> observerList = new ArrayList<Observer>(); public void addObserver(Observer observer){ observerList.add(observer); } public void deleteObserver(Observer observer){ observerList.remove(observer); } public void notifyObserver(){ for(Observer observer: observerList){ observer.update(); } } } 定义英雄 public class Hero extend Subject{ public void run(){ notifyObserver(); } } 具体调用 ``` public class client{ public static void main(String[] args){ //初始化对象 Hero hero = new Hero(); Stone stone = new Stone(); Trap trap = new Trap(); hero.addObserver(stone); hero.addObserver(trap); hero.run(); } } 代码输出如下： 获取到宝石 踩到陷阱 ```","text_tokens":["run","add","：","关系","hero","<","行为","]","trap","implement","如何","判断","abstract","是否","减","定义","interface","static","的","被","和","游戏","void","或者","有","技能","生命","/","。"," ","抽取","{","英雄","concreteobserver","首先","subject","class","输出","list","for","捡","内","抽象类","很多","共同","string","}","client","建立","获取",",","中","main","初始化","在","boolean","if","update",";","观察者","=","args","观察","addobserver","notifyobserver","[","如下","deleteobserver","对象","print","system","arraylist","增加","\"",".","private","道具","具体","stone","地图","return","extend","，","调用",":","宝石","宝剑","remove","(","例子","属于","到","？","inrange","true","抽象","踩","`","observerlist","距离","中中","呢",")","new","public","这个","代码","生命力","observer","宝盒","走","陷阱",">","out","初始"],"title":"经典的例子","title_tokens":["的","经典","例子"]},{"location":"designpattern/observer/#_3","text":"解耦观察者被观察者","text_tokens":["耦","被","解","观察者","观察"],"title":"优缺点","title_tokens":["缺点","优缺点"]},{"location":"designpattern/singleInstance/","text":"简单来说就是一个类只能构建一个对象的设计模式 第一种不加锁的单例 线程不安全 public class Singleton { private Singleton() {} //私有构造函数 private static Singleton instance = null; //静态工厂方法 public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式 在类被初始化的时候就已经在内存中创建了对象，以空间换时间，不存在线程安全问题。 public class SingleTon{ private static SingleTon INSTANCE = new SingleTon(); private SingleTon(){} public static SingleTon getInstance(){ return INSTANCE; } } 懒汉式 在方法被调起后才创建对象，以时间换空间，在多线程环境下存在风险。 public class SingleTon{ private static SingleTon INSTANCE = null; private SingleTon(){} public static SingleTon getInstance() { if(INSTANCE == null){ INSTANCE = new SingleTon(); } return INSTANCE； } } 简单加上synchronized锁 双重检测(double check lock)是为了b线程在a线程刚结束的临界点执行锁内任务，存在DCL失效问题 public class Singleton { private Singleton() {} //私有构造函数 private static Singleton instance = null; //单例对象 //静态工厂方法 public static Singleton getInstance() { if (instance == null) { //双重检测机制 synchronized (Singleton.class){ //同步锁 if (instance == null) { //双重检测机制 instance = new Singleton(); } } } return instance; } } 以上实现还是有问题 ，单例第三种写法 JVM编译器有个指令重排的概念 * 什么是指令重排 java一个简单的instance = new instance()会被jvm编译成如下jvm指令 1. memory = allocate;分配对象的内存地址 2. creatinstance(memory);初始化对象 3. instance = memory设置instance指向刚分配的内存地址 但是这些指令顺序并非是一重不变，可能会经过jvm和cpu的优化，进行重排序 1.分配对象内存地址 3.设置instance指向刚分配的内存地址 2.初始化对象 当线程A执行完13的时候，线程B抢到资源，返回了一个还没有初始化完成的对象 * 如何避免以上问题？ 在instance对象前面增加一个volatile修饰符 public class Singleton { private Singleton() {} //私有构造函数 private volatile static Singleton instance = null; //单例对象 //静态工厂方法 public static Singleton getInstance() { if (instance == null) { //双重检测机制 synchronized (Singleton.class){ //同步锁 if (instance == null) { //双重检测机制 instance = new Singleton(); } } } return instance; } } volatile阻止了变量访问访问前后指令重排序，对于线程B来说，instance要么指向null，要么指向一个完整的instance,而不会出现中间状态 不仅可以防止指令重排，也可以保证线程访问的变量值是主内存种最新值，jdk1.6及以后才支持，每次均从主内存中读取，牺牲点效率，无伤大雅。 静态内部类 静态内部类只会被加载一次，首次调用，顾线程安全，类加载初始化阶段是单线程的同时延迟了初始化。 类加载时机 1. new,involk static,putstatic,getstatic,指令时若类未加载则触发 2. 反射使用某个类时，若类未加载则触发 3. 子类加载时若父类未加载则触发 4. 程序开始时主方法所在类会被加载 静态内部类的懒加载应该属于第一种情况，为什么外部类加载时，内部类未加载，静态内部类只是刚好写在了另一个类里面，实际上和外部类没什么附属关系。 public class Singleton{ private SingleTon (){} private static class Holder{ //这里的私有没有什么意义 private static SingleTon instance = new Singleton(); } public static Singleton getInstance(){ return Holder.instance } } 如何通过反射打破单例模式，只能构建一个对象 //获得构造器 Constructor con = Singleton.class.getDeclaredConstructor(); //设置为可访问 con.setAccessible(true); //构造两个不同的对象 Singleton singleton1 = (Singleton)con.newInstance(); Singleton singleton2 = (Singleton)con.newInstance(); //验证是否是不同对象 System.out.println(singleton1.equals(singleton2)); 如何防止反射？ 使用枚举实现单例 public enum SingletonEnum { INSTANCE; } 使用枚举单例，不仅可以防止反序列化，而且可以保证枚举对象被反序列化的时候，返回的对象是同一个对象 public enum SingletonEnum { INSTANCE; public void doSomething(){ System.out.printLn(\"do something\"); } } public enum SingletonEnum{ PERSON; private Person person = null; private SingletonEnum(){ person = new Person(); } public Person getPerson(){ return person; } } public class Person{ } 防止内存泄漏单例 public class A8PinPadManage { private A8PinPadManage(){} //私有构造函数 private volatile static Pinpad instance; //单例对象 public static Pinpad getInstance(Context context) { WeakReference<Context> contextWeakReference = new WeakReference<>(context); Context weakReferenceContext = contextWeakReference.get(); if (instance == null) { synchronized (A8PinPadManage.class) { if (instance == null) { instance = new Pinpad((int) SharedPrefsUtil.get(weakReferenceContext, CIL_KAP_ID, 2), \"IPP\"); } } } return instance; } } 解读 私有构造函数，全局只能构建一个对象，不能让随便的就去new,所以要私有 懒汉，单例刚开始没有构建，调用才构建 饿汉，调用new singleton主动构建，不需要判空 instance的初始值可以写成null或者new Singleton() 不加锁，线程不安全 不加双重验证直接锁getinstance方法，可以，增加内存开销，只用synchronize里面的判空，增加开销 参考 小灰漫画 https://www.zhihu.com/search?type=content&q=%E5%8D%95%E4%BE%8B","text_tokens":["结束","换","13","8b","jvm","工厂","只能","空间","构造","可能","返回","synchronized","被","点","使用","这里","若类","或者","一次","重","子类","/","问题","不同","这些","context","就是","多线程","防止","初始化","weakreferencecontext","get","constructor","风险",";","式","lock","分配","资源","附属","私有","1","memory","system","检测","\"","则",".","只用","双重","读取","return","以","饿汉",":","中间","同一个","singleton","漫画","主","状态","两个","应该","第三","出现","e5%","完成","开始","第三种","并非","序列化","写成","部类","out","加上","经过","一个","设置","加载","一种","执行","模式","是否","不能","static","不会","和","void","机制","时机","构建","{","了","getstatic","*","当","单线","环境","synchronize","里面","程序","另","volatile","安全","https","需要","未","某个","每次","com","中","java","a","反","=","刚","如下","以上","时主","从主","还","支持","holder","第一","同步","加","%","保证","be%","无伤大雅","null","前后","以后","单线程","三种","外","调用","编译器","a8pinpadmanage","jdk1.6","(","阻止","让","可","？","类时","true","时若","主动","重排","抢到","完","创建对象","是",")","3","下","时间","小灰","不仅","锁","实际","double","临界点","函数",">","顾","参考","同一","kap","同时","后","search","初始","singleton1","q","简单","可以","<","验证","而且","没有","实际上","只是","如何","int","getperson","zhihu","解读","去","单例"," ","。","写","无伤","设计模式","involk","最新","class","有个","但是","顺序","临界","}",",","设计","进行","修饰符","www","在","getinstance","contextweakreference","变量值","newinstance","刚好","?","对象","所以","种","一重","完整","反射","第一种","要","setaccessible","构造函数","只会","allocate","多线","均","，","修饰","会","初始值","对于","equals","值","也","是否是","singletonenum","_","所在","懒汉","获得","才","类会","4","check","触发","量值","为什么","creatinstance","public","dosomething","pinpad","开销","要么","地址","优化","关系","译成","泄漏","就","及","还是","判空","器","95%","content","首次","内存","的","序列","避免","不变","加锁","时若类","有","8d%","排序","&","概念","指向","内部","指令","前面","时候","通过","dcl","牺牲","sharedprefsutil","而","2","懒","全局","意义","cpu","person","锁内","什么","if","不","来说","写法","已经","为","ipp","静态","阶段","cil","类未","do","父类","weakreference","线程","增加","putstatic","任务","创建","没什么","变量","private","enum","枚举","实现","内存地址","情况","getdeclaredconstructor","失效","打破","时","e4%","属于","调起","随便","中间状态","编译","方法","println","id","大雅","编译成","b","；","singleton2","类","new","con","something","直接","延迟","type","访问","存在","效率","为了","instance"],"title":"单例","title_tokens":["单例"]},{"location":"designpattern/singleInstance/#_1","text":"线程不安全 public class Singleton { private Singleton() {} //私有构造函数 private static Singleton instance = null; //静态工厂方法 public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式 在类被初始化的时候就已经在内存中创建了对象，以空间换时间，不存在线程安全问题。 public class SingleTon{ private static SingleTon INSTANCE = new SingleTon(); private SingleTon(){} public static SingleTon getInstance(){ return INSTANCE; } } 懒汉式 在方法被调起后才创建对象，以时间换空间，在多线程环境下存在风险。 public class SingleTon{ private static SingleTon INSTANCE = null; private SingleTon(){} public static SingleTon getInstance() { if(INSTANCE == null){ INSTANCE = new SingleTon(); } return INSTANCE； } }","text_tokens":["已经","(","静态","换","调起","时候","私有","对象","就","懒汉","工厂","class","线程","方法","安全","创建对象","才","多线程","创建","；","空间",")","}","new","构造","static","private","类","内存","的","下","public","时间","构造函数","被","null","中","初始化","多线","return","getinstance","函数","在","以","饿汉","/","if","，","风险",";","式"," ","=","存在","问题","。","后","singleton","不","{","了","instance","初始","环境"],"title":"第一种不加锁的单例","title_tokens":["的","单例","加锁","第一种","不","一种","第一"]},{"location":"designpattern/singleInstance/#synchronized","text":"双重检测(double check lock)是为了b线程在a线程刚结束的临界点执行锁内任务，存在DCL失效问题 public class Singleton { private Singleton() {} //私有构造函数 private static Singleton instance = null; //单例对象 //静态工厂方法 public static Singleton getInstance() { if (instance == null) { //双重检测机制 synchronized (Singleton.class){ //同步锁 if (instance == null) { //双重检测机制 instance = new Singleton(); } } } return instance; } }","text_tokens":["结束","(","静态","私有","对象","dcl","工厂","线程","class","方法","检测","同步","b","执行","任务",".","是","临界","check",")","}","new","构造","static","private","的","public","构造函数","双重","synchronized","null","锁","double","临界点","锁内","在","getinstance","函数","return","a","单例","，","/","if","lock","问题"," ","存在","=",";","机制","为了","刚","singleton","{","失效","instance"],"title":"简单加上synchronized锁","title_tokens":["简单","锁","synchronized","加上"]},{"location":"designpattern/singleInstance/#_2","text":"JVM编译器有个指令重排的概念 * 什么是指令重排 java一个简单的instance = new instance()会被jvm编译成如下jvm指令 1. memory = allocate;分配对象的内存地址 2. creatinstance(memory);初始化对象 3. instance = memory设置instance指向刚分配的内存地址 但是这些指令顺序并非是一重不变，可能会经过jvm和cpu的优化，进行重排序 1.分配对象内存地址 3.设置instance指向刚分配的内存地址 2.初始化对象 当线程A执行完13的时候，线程B抢到资源，返回了一个还没有初始化完成的对象 * 如何避免以上问题？ 在instance对象前面增加一个volatile修饰符 public class Singleton { private Singleton() {} //私有构造函数 private volatile static Singleton instance = null; //单例对象 //静态工厂方法 public static Singleton getInstance() { if (instance == null) { //双重检测机制 synchronized (Singleton.class){ //同步锁 if (instance == null) { //双重检测机制 instance = new Singleton(); } } } return instance; } } volatile阻止了变量访问访问前后指令重排序，对于线程B来说，instance要么指向null，要么指向一个完整的instance,而不会出现中间状态 不仅可以防止指令重排，也可以保证线程访问的变量值是主内存种最新值，jdk1.6及以后才支持，每次均从主内存中读取，牺牲点效率，无伤大雅。","text_tokens":["一个","设置","优化","译成","简单","可以","13","及","jvm","没有","工厂","执行","如何","构造","内存","static","可能","的","返回","避免","不会","synchronized","被","不变","点","和","重","单例","/","排序"," ","问题","机制","概念","指向","。","{","了","指令","前面","当","*","这些","无伤","时候","最新","牺牲","而","class","有个","volatile","但是","顺序","防止","2","}","每次",",","中","cpu","进行","初始化","java","修饰符","在","getinstance","a","什么","if",";","=","刚","变量值","分配","资源","来说","如下","以上","静态","从主","还","支持","1","私有","对象","memory","线程","增加","种","检测","同步","一重","完整",".","变量","private","内存地址","构造函数","双重","保证","无伤大雅","null","读取","allocate","前后","均","以后","return","，","修饰","会","编译器","对于","中间","singleton","jdk1.6","值","(","阻止","也","主","？","状态","中间状态","编译","重排","抢到","方法","完","大雅","编译成","b","才","是","出现",")","3","量值","new","creatinstance","public","完成","不仅","锁","并非","函数","访问","效率","要么","地址","instance","初始","经过"],"title":"以上实现还是有问题 ，单例第三种写法","title_tokens":["有","单例","以上","实现","，","问题"," ","第三种","第三","写法","还是","三种"]},{"location":"designpattern/singleInstance/#_3","text":"静态内部类只会被加载一次，首次调用，顾线程安全，类加载初始化阶段是单线程的同时延迟了初始化。 类加载时机 1. new,involk static,putstatic,getstatic,指令时若类未加载则触发 2. 反射使用某个类时，若类未加载则触发 3. 子类加载时若父类未加载则触发 4. 程序开始时主方法所在类会被加载 静态内部类的懒加载应该属于第一种情况，为什么外部类加载时，内部类未加载，静态内部类只是刚好写在了另一个类里面，实际上和外部类没什么附属关系。 public class Singleton{ private SingleTon (){} private static class Holder{ //这里的私有没有什么意义 private static SingleTon instance = new Singleton(); } public static Singleton getInstance(){ return Holder.instance } }","text_tokens":["一个","关系","加载","没有","一种","实际上","只是","首次","static","的","被","时若类","使用","这里","和","若类","一次","子类","/","。"," ","时机","内部","{","了","getstatic","指令","单线","写","里面","involk","程序","class","另","安全","未","某个","2","}","懒",",","意义","初始化","在","getinstance","什么",";","=","时主","附属","静态","阶段","1","私有","刚好","类未","holder","父类","线程","第一","putstatic","则","反射",".","没什么","第一种","private","只会","情况","单线程","return","，","外","调用","singleton","时","(","属于","类时","所在","时若","方法","类会","应该","是","4","3",")","触发","类","new","为什么","public","开始","实际","延迟","部类","顾","同时","instance","初始"],"title":"静态内部类","title_tokens":["内部","类","静态"]},{"location":"designpattern/singleInstance/#_4","text":"//获得构造器 Constructor con = Singleton.class.getDeclaredConstructor(); //设置为可访问 con.setAccessible(true); //构造两个不同的对象 Singleton singleton1 = (Singleton)con.newInstance(); Singleton singleton2 = (Singleton)con.newInstance(); //验证是否是不同对象 System.out.println(singleton1.equals(singleton2)); 如何防止反射？ 使用枚举实现单例 public enum SingletonEnum { INSTANCE; } 使用枚举单例，不仅可以防止反序列化，而且可以保证枚举对象被反序列化的时候，返回的对象是同一个对象 public enum SingletonEnum { INSTANCE; public void doSomething(){ System.out.printLn(\"do something\"); } } public enum SingletonEnum{ PERSON; private Person person = null; private SingletonEnum(){ person = new Person(); } public Person getPerson(){ return person; } } public class Person{ }","text_tokens":["设置","为","(","singleton1","singletonenum","是否是","一个","时候","可","？","可以","true","返回","对象","验证","而且","do","获得","class","println","system","getperson","器","\"","两个","如何",".","防止","反射","是","是否",")","singleton2","}","new","构造","setaccessible","enum","private","con","的","枚举","实现","public","序列","保证","被","使用","不仅","something","null","void","dosomething","序列化","person","return","getdeclaredconstructor","constructor","单例","，","/","访问",";","out"," ","=","反","同一","同一个","singleton","equals","{","不同","newinstance","instance"],"title":"如何通过反射打破单例模式，只能构建一个对象","title_tokens":["单例","打破","，","一个","只能","反射","如何","通过","模式","构建","对象"]},{"location":"designpattern/singleInstance/#_5","text":"public class A8PinPadManage { private A8PinPadManage(){} //私有构造函数 private volatile static Pinpad instance; //单例对象 public static Pinpad getInstance(Context context) { WeakReference<Context> contextWeakReference = new WeakReference<>(context); Context weakReferenceContext = contextWeakReference.get(); if (instance == null) { synchronized (A8PinPadManage.class) { if (instance == null) { instance = new Pinpad((int) SharedPrefsUtil.get(weakReferenceContext, CIL_KAP_ID, 2), \"IPP\"); } } } return instance; } } 解读 私有构造函数，全局只能构建一个对象，不能让随便的就去new,所以要私有 懒汉，单例刚开始没有构建，调用才构建 饿汉，调用new singleton主动构建，不需要判空 instance的初始值可以写成null或者new Singleton() 不加锁，线程不安全 不加双重验证直接锁getinstance方法，可以，增加内存开销，只用synchronize里面的判空，增加开销","text_tokens":["一个","可以","<","验证","就","没有","判空","只能","int","不能","构造","static","内存","的","synchronized","加锁","解读","去","或者","单例","/"," ","构建","{","context","synchronize","里面","sharedprefsutil","class","volatile","安全","需要","2","}",",","全局","weakreferencecontext","getinstance","get","if",";","=","contextweakreference","刚","不","ipp","私有","cil","对象","weakreference","所以","线程","增加","\"",".","加","要","private","只用","构造函数","双重","null","return","，","饿汉","调用","初始值","a8pinpadmanage","singleton","(","让","随便","_","懒汉","主动","方法","id","才",")","new","public","直接","开始","锁","写成","函数","pinpad",">","kap","开销","instance","初始"],"title":"防止内存泄漏单例","title_tokens":["内存","泄漏","单例","防止"]},{"location":"designpattern/singleInstance/#_6","text":"https://www.zhihu.com/search?type=content&q=%E5%8D%95%E4%BE%8B","text_tokens":["q","e4%","?","8b","https",".","content","95%","%","zhihu","e5%","be%","com","www","type","/","8d%","=",":","&","search"],"title":"参考  小灰漫画","title_tokens":["参考"," ","漫画","小灰"]},{"location":"things/algorithm/","text":"HashMap 概念 用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。 put方法原理 调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。 get方法 首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找 初始化长度 初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。 高并发下的HashMap Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap. 什么是ConcurrentHashMap？ ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。 put和get原理 get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash 红黑树 （数据结构） 二叉树的特性 1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树 红黑树特性 节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。 调整红黑树的两种方法（变色、旋转） AES算法（对称加密算法） MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。 三个基本概念（密钥、填充、模式） 密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。 在java中的具体实现 注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。 AES算法的底层原理 一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey） 字节替代 subByte 十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11] 行移位 shiftRows 如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节 列混淆MixColumns 输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列 加 论密钥(add round key) 128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。 不同工作模式在加密流程中有什么不同？ 所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度 MD5 可以从任意长度的明文字符串生成128位的哈希值 验签过程 1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制 MD5底层原理 分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c Base64 排序 冒泡算法和优化","text_tokens":["遍历","结束","：","5","发生变化","覆盖","13","pkcs5padding","加盐","摘要","接插","最后","数据结构","具体位置","只能","m","最大","原理","混淆","m1","可能","总","叶子","electronoc","处理","被","14","使用","对","有限","那么","二分","第三行","或者","封装","相关","第三方","bit","一次","命名","不止","最好","第一个","代表","作用","几位","写入","/","问题","均匀","chainning","mi","轮","不同","这些","加密器","电码","由","传输","0x89abcdef","单","后面","就是","nopadding","既","除去","语言","完后","十进制","防止","份","数据","显然","一个个","用到","优点","^","生成","目标","随机","ff","初始化","只","7","aes128","水线","get","把","列","多个","原始","决定","一股脑","用于","键值","进制","4x4","0xfedcba98","表","chaining","变成","[","如果","只要","主体","多","c","1","12","keyexpentions","outputfeedback","哈希","是非","累加","典型","大于","红黑树","阻塞","怎么","四步","\"","黑色","则",".","一步","算法","z","共","本身","认为","参与","数量","平台","并行计算","y","当前","cipher","提供","这样","校验","64","田","0x01234567",":","同一个","向下","二维","带","第四行","四种","之后","主","到","所有","差别","取决","结果","修改","对称","拆分","-------------------------","f","账户","按照","并行","得出","基本概念","beauty","x","黄色","两个","说","一起","第三","都","出现","包含","旋转","每个","除了","替代","顺着","次数","起来","完成","zegment","左右","开始","官方","00","限制","从根","其余","二叉树","独立","相乘","数倍","底层","真正","求余","等同于","扩容","扩展","位","两种","box","经过","一个","依据","左移","value","设置","一段","映射","addroundkey","ecb","0x76543210","增长","10","记录","1111","个个","安全性","无法","i","32","不足","一列","越来","模式","影响","是否","直接插入","segment","block","业务","不能","之一","16x16","支付","第四","拆","和","补足","较差","剩余","16","轮数","不如","替换成","192bit","复杂度","）","二块","-","更高","子","依次","当于","192","{","了","当","*","作为","对应","新","相加","subbyte","约定","128bit","一行","反馈","创造","子树","二进制位","那个","填充","末尾","给定","解密","移位","原","输出","整段","448","3029737","安全","原文","需要","capacity","~","优势","ki","田字","打折扣","每","过程","前会","互不","无误","中","幂","sha256","额外","四行","java","对比","补全","a","=","分为","即","有利于","二个","主要","数值","从","如下","用","以上","组是","支持","插法","常量","验签","五种","256","第一","一股","成","缺少","或","有点像","攻击者","第","各种","因为","分组","加","有利","加密","matrix","完全","所","hashcode","找","保证","加轮","null","具体","d","三行","多少","排列成","环","一致性","三种","而是","外","调用","非线性","m16","归纳","走到","5b","假设","同样","值补","(","出","头","size","让","可","常用","？","码本","组","subbytes","因子","种子","key","hash","调整","counter","密钥","呢","是","结构","final","加工",")","3","下","加入","叫做","左子","代码","右","下图","锁","实际","一等","表面","知道","次子","cbc","函数","字符","高",">","达到","大小","ecb2","异或","同一","同时","连续","后","64bit","规则","m15","拼接","变化","初始","引入","ade876ishdfakhdj","次","三步","默认","例","简单","变色","可以","next","<","原先","initial","验证","没有","接收","替换","concurrenthashmap","aes192","如何","例如","255","它","特性","上","超过","大家","右子","分段","abcd","iv","链接","hashmap","平时","mixcolumns","8","二进制","分布","一共","ofb","0.75","块"," ","。","解决","取决于","处理过程","签名","上面","与","步骤","算器","成一","负载","必须","近似","首先","15","很","盒","一致","acount","最终","即可","第一位","几乎","有个","如图","排列","第一行","但是","创造者","index","数","第一步","很多","随之","演变","}","m0","字符串","密码","获取",",","分散","电码本","j","\\","只有","47","initialization","进行","一把","信息","循环","输入","尝试","shiftrows","金额","绿色","在","resize","阈值","密文","有些","任意","两件","读写","个","等于","行","链表","其它","160","两次","101110001110101110","上锁","尾端","持有","集合","刚好","二行","对象","所以","宏观","aes256","位置","空","高度","完整","这里","方式","fix","length","根","单次","要","性能","可逆","小于","元素","”","（","平衡","#","比如","铭文","请求","流水线","细节","字","重新","几种","第二行","不是","均","11","使得","entry","round","完整性","，","初始值","会","electronic","三个","+","参数","左","175","值","论","交替","所用","也","最","互不干涉","理过","当新","降低","利用","相应","_","许多","由于","java8","任何","赋值","冲突","发送","表达","4","换成","量值","为什么","搞笑","篡改","rounds","大","体现","前","这个","产生","均匀分布","1001","中有","vector","难免","并发","一位","w","双方","攻击","根据","计算器","指针","这","g","原本","1234","收集","add","越来越","好","优化","字节","可能性","9","泄漏","]","就","现象","loadfactor","大打折扣","相当","整个","sign","数组","粒度","rehash","定位","之所以","第二个","的","put","128","加锁","第二","不变","折扣","n","有","二位","条件","全为","释放","排序","subtitution","&","概念","指向","原来","内部","不断","加解密","再","后续","带上","生变","路径","重入","时候","少于","通过","容量","一样","运算","同于","要求","iso126padding","而","......","线性","相当于","、","代替","十六","孩子","amout","参数值","复杂","向","实践","下面","插入","矩阵","2","两位","操作","普通","另外","之间","二级","注意","存储","一轮","流程","查找","任一","树","取代","分成","什么","缺点","干涉","旧","二叉","整数倍","不","k","采用","难免会","源代码","向量","关联","十六进制","为","h","来","md5","阶段","512","明文","feedback","0","红色","最高","线程","数目","四个","mj","第二块","一直","增加","中当","》","将","创建","book","发生","做","列成","节点","实现","第四个","aes","名","私密","流水","得到","这种","等同","相同","6","情况","又","遇到","表示","某种","一组","体位","整数","e","分别","统计","cfb","|","有点","说明","思想","时","31","事情","属于","两倍","张图","修补","codebook","方法","直到","技术","是因为","三方","过去","冒泡","加密算法","ctr","匹配","b","当中","图中","长度","s","主干","base64","基本","等份","直接","且","工作","坏人","第三个","并","意思","假定","打折","计算","效率","为了","“","利于"],"title":"Algorithm","title_tokens":["algorithm"]},{"location":"things/algorithm/#hashmap","text":"","text_tokens":[],"title":"HashMap","title_tokens":["hashmap"]},{"location":"things/algorithm/#_1","text":"用于存储Key-Value键值对（entry）的集合,每一个键值对也叫做entry,这些entry分散存储在一个数组中，这个数组就是HashMap的主干。 每一个元素(entry)的初始值都是null 最常用的get和put方法。","text_tokens":["一个","(","value","也","最","常用","集合","就是","key","方法","都","数组","是",")","主干","元素","（","的",",","每","叫做","put","这个","存储","分散","对","null","和","中","hashmap","在","get","entry","，","）","初始值","。","用于","键值","-"," ","这些","初始"],"title":"概念","title_tokens":["概念"]},{"location":"things/algorithm/#put","text":"调用hashMap.put(\"beauty\",0),插入一个key为\"beauty\"的元素 index = hashcode(\"beauty\")&(hashMap.size-1) 假定最后得出的index为2 但是当插入的entry越来越多，难免会出现index冲突的现象 HashMap的数组每一个元素不止是一个entry对象，是一个链表的头节点，entry对象可以通过next指针指向它的下一个entry节点,当新插入的entry遇到冲突的数组位置时，直接插入到对应的链表即可： java8中当链表长度超过8，会直接变成红黑树 采用的是“头插法”，HashMap创造者认为，后插入的元素被查找的可能性大。","text_tokens":["一个","越来越","：","可以","next","可能性","现象","接插","最后","越来","数组","它","直接插入","超过","可能","的","put","被","hashmap","不止","8"," ","。","&","-","指向","当","对应","创造","通过","即可","但是","创造者","index","插入","2",",","每","查找","=","采用","难免会","链表","变成","为","多","插法","1","对象","0","位置","红黑树","中当","\"",".","元素","”","hashcode","认为","节点","遇到","entry","，","调用","会","时","(","头","size","到","当新","java8","key","得出","beauty","冲突","是","出现","长度",")","下","大","直接","难免","假定","后","指针","“"],"title":"put方法原理","title_tokens":["原理","put","方法"]},{"location":"things/algorithm/#get","text":"首先根据输入的key做一次hash映射，得到index index = hashcode(key)&(hashMap.size()-1) 同一个位置上有可能匹配到多个entry, 这个时候需要顺着链表的头节点一个一个向下找","text_tokens":["一个","(","头","映射","size","到","时候","1","首先","key","hash","位置","index","匹配",".","需要",")","上","做","hashcode","找","可能","的",",","顺着","节点","这个","hashmap","一次","得到","输入","entry","有","，","多个"," ","=","&","-","同一","同一个","根据","向下","链表"],"title":"get方法","title_tokens":["get","方法"]},{"location":"things/algorithm/#_2","text":"初始化长度为16,后面增长 长度是2的幂 哈希函数 index = hashcode(key)&(size-1) 例:计算book的index 1.计算hashcode-十进制3029737，二进制101110001110101110 1001 2.hashmap初始化长度16,计算length-1为十进制15,二进制1111 3.以上两个值做&运算 101110001110101110 1001 & 1111 ------------------------- 1001 对应的十进制9，所以index = 9 index结果取决于key的hashcode的最后几位 长度为16或其它2的幂，length-1的二进制位全为1，这种情况下与key的hashcode做&运算的结果等同于hashcode的后几位的值，只要输入的hashcode本身均匀，hash算法的结果就是均匀的。","text_tokens":["为","(","101110001110101110","以上","只要","size","例","1","后面","9","增长","15","结果","1111","运算","取决","二进制位","同于","就是","-------------------------","哈希","所以","key","hash","十进制","3029737","最后","或","两个","index",".","length","是","算法","长度",")","book","2","3","下","做","hashcode","对应","本身",",","的","幂","1001","16","hashmap","初始化","这种","等同","输入","情况","函数","二进制","几位","，","等同于","全为"," ","=","&","-",":","计算","进制","后","均匀","。","取决于","值","初始","与","其它"],"title":"初始化长度","title_tokens":["初始","初始化","长度"]},{"location":"things/algorithm/#hashmap_1","text":"Hashmap的容量是有限的，达到容量的时候需要扩容，resize 是否进行resize的条件如下 HashMap.size()>=Capacity LoadFactor Capacity:HashMap的当前长度，Hash的长度是2的幂 LoadFactor:HashMap负载因子，默认是0.75f resize做了两件事情： 1.扩容 创建新的数组长度是原来的两倍 2.Rehash *为什么要rehash，因为长度发生变化后，规则也随之发生变化，计算index的那个方法。 HashMap是非线程安全的 rehash在并发的情况下可能会出现链表环，如何解决？，使用ConcurrentHashMap.","text_tokens":["：","默认","发生变化","loadfactor","concurrenthashmap","如何","数组","是否","rehash","可能","的","使用","有限","hashmap","条件","0.75"," ","。","原来","解决","了","*","新","生变","负载","时候","容量","那个","安全","需要","capacity","index","2","随之","幂","进行","在","什么","resize","=","两件","链表","如下","1","线程","是非",".","创建","因为","发生","要","做","当前","情况","环","，","会",":","(","也","事情","size","？","两倍","因子","f","方法","hash","是","出现","长度",")","下","为什么","并发",">","达到","计算","扩容","后","规则","变化"],"title":"高并发下的HashMap","title_tokens":["的","高","hashmap","并发","下"]},{"location":"things/algorithm/#concurrenthashmap","text":"ConcurrentHashMap是如何实现线程安全的，又是怎么实现搞笑读写的？ ConCurrentHashMap相当于一个二级Hash表，它的优势就是采用了锁分段技术，每个segment都是独立的，zegment之间互不影响。 segment写入是需要上锁的，同一个segment的写入是阻塞的，每个segment持有一把锁，保证线程安全的同时，降低了锁的粒度，让并发操作效率更高。","text_tokens":["一个","上锁","让","持有","？","就是","降低","线程","hash","技术","安全","相当于","阻塞","怎么","concurrenthashmap","相当","需要","如何","影响","是","都","它","优势","粒度","segment","每个","分段","搞笑","操作","的","实现","之间","二级","zegment","保证","互不","锁","一把","并发","独立","又","写入","，"," ","。","同一","效率","同时","同一个","更高","读写","当于","了","采用","表"],"title":"什么是ConcurrentHashMap？","title_tokens":["concurrenthashmap","是","什么","？"]},{"location":"things/algorithm/#putget","text":"get方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 再通过hash值，定位到segment中数组的具体位置 put方法 输入的key做hash运算得到hash值 通过hash值定位到具体的segment对象 获取可重入锁 再通过hash,定位到segment数组的具体位置 插入或者覆盖entry对象 释放锁 3.size计算原理 遍历所有的segment 将segment的元素数量累加起来 把segment修改次数累加起来 总修改次数是否大于上一次修改次数，如果大于则说明计算过程中有修改，重新统计，尝试次数+1，如果不是，说明没有修改，结束统计 重新次数超过阈值，对每一个segment加锁，重新统计 conCurrentHashMap在对key进行hash时，为了实现segment均匀分布，进行了两次hash","text_tokens":["遍历","一个","结束","覆盖","没有","concurrenthashmap","具体位置","数组","是否","segment","上","定位","超过","原理","总","的","put","加锁","对","或者","一次","分布","释放"," ","均匀","了","再","重入","通过","运算","插入","获取",",","每","过程","中","进行","输入","尝试","在","get","把","阈值","两次","如果","1","对象","累加","大于","位置","则","将",".","元素","做","实现","数量","具体","重新","得到","不是","entry","，","体位","统计","+","说明","值","时","size","到","可","所有","修改","key","方法","hash","3","次数","起来","均匀分布","锁","中有","计算","为了"],"title":"put和get原理","title_tokens":["原理","和","put","get"]},{"location":"things/algorithm/#_3","text":"","text_tokens":[],"title":"红黑树  （数据结构）","title_tokens":["（","红黑树","数据结构","）"," ","结构","数据"]},{"location":"things/algorithm/#_4","text":"1. 左子树所有节点的值小于或者等于它的根节点的值 2. 右子树所有节点的值均大于或者等于根节点的值 3. 左右子树也分别为二叉排序树 例：查找10 1. 从根节点9开始找，由于10大于9，走到右孩子13 2. 由于10小于13走到左孩子11 3. 由于10小于11走到左孩子10，结束 二分查找思想，查找的最大次数等于二叉查找树的高度 插入节点也是利用相同的方法 二叉树的缺点： 例：8、9、10节点依次插入1、2、3、4、5、6，就变成如下： 查找的性能大打折扣，几乎变成了线性 如何解决这种不平衡？红黑树","text_tokens":["结束","：","5","例","13","9","10","就","大打折扣","如何","最大","它","右子","的","二分","或者","折扣","8","排序"," ","解决","依次","了","子树","线性","几乎","、","孩子","插入","2","打折扣","查找","树","缺点","二叉","不","等于","变成","如下","为","1","大于","红黑树","高度",".","根","性能","小于","找","平衡","节点","6","这种","相同","均","11","，","分别","走到","左","值","思想","也","所有","？","利用","由于","方法","是","4","3","次数","左子","左右","开始","右","从根","二叉树","打折"],"title":"二叉树的特性","title_tokens":["二叉树","的","特性","二叉"]},{"location":"things/algorithm/#_5","text":"节点是红色或者黑色 根节点是黑色 每个叶子节点都是空的黑色节点(null节点) 每个红色的两个子节点都是黑色(从每个叶子到根的所有路径不能有两个连续的红色节点) 从任一节点到叶子的所有路径都包含相同数目的黑色节点。","text_tokens":["路径","(","到","所有","红色","数目","空","黑色","两个","是","根","都",")","包含","每个","不能","叶子","节点","的","null","或者","任一","相同","有"," ","。","子","连续","从"],"title":"红黑树特性","title_tokens":["特性","红黑树"]},{"location":"things/algorithm/#_6","text":"","text_tokens":[],"title":"调整红黑树的两种方法（变色、旋转）","title_tokens":["（","调整","的","红黑树","、","）","变色","两种","旋转","方法"]},{"location":"things/algorithm/#aes","text":"MD5和sha256属于摘要算法，是不可逆的，主要的作用是对信息的一致性和完整性进行校验，对称加密算法可逆，保证私密信息不被泄漏。","text_tokens":["属于","md5","对称","泄漏","一致","摘要","加密算法","完整","是","算法","加密","可逆","的","保证","被","对","和","私密","sha256","信息","进行","校验","一致性","作用","完整性","，","。","不","主要"],"title":"AES算法（对称加密算法）","title_tokens":["（","aes","加密算法","）","对称","算法","加密"]},{"location":"things/algorithm/#_7","text":"密钥：AES支持三种密钥：128位、192位、256位,实际就是大家平时说的AES128\\AES192\\AES256。从安全性AES256最高，AES128性能最好，加密处理轮数不同。 填充 什么是分组加密？ AES加密过程： AES在对明文进行加密的时候并不是把整个明文一股脑的加密成一整段密文，而是把明文拆分成一个个独立的明文块，每个明文块的长度是128bit 这些铭文块经过加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。 但是有个问题？加入一段明文是192bit，拆分后第二块只有64bit，不足128bit，这个时候就需要填充。 AES在不同的语言中有许多不同的填充算法，典型的几种: NoPadding:不做任何填充，但是要求明文必须是16字节的整数倍。 PKCS5Padding(默认):如果明文块少于16个字节（128bit）,在明文块尾端补足相应数量的字符，且每个字节的值等于缺少的字符数。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6} ISO126Padding:如果明文块少于16字节（128bit），在明文块末尾不足相应数量的字节，最后一个字符值等于缺少的字符数，其它字符随机填充。 例：{1，2，3，4，5，a,b,c,d,e},缺少6个字节，则可能补全为{1，2，3，4，5，a,b,c,d,e,6,7,8,#,G,6} 注意：AES加密的时候用了某种填充方式，解密时也必须采用同样的解密方式。 模式 AES的工作模式，体现在把明文块加密成密文块的处理过程中，AES加密算法提供了五种不同的工作模式：ECB,CBC,CTR,CFB,OFB 模式之间的主体思想是近似的，处理细节上有些差别 ECB模式（默认）电码本模式Electronic CodeBook Book CBC 密码分组链接模式Cipher Block Chaining CTR 计算器模式 Counter CFB 密码反馈模式 Cipher FeedBack OFB 输出反馈模式 OutputFeedBack 同样在加密的时候使用某种工作模式，解密也必须采用相同的工作模式。","text_tokens":["一个","一段","：","默认","5","例","字节","ecb","pkcs5padding","个个","就","安全性","不足","最后","整个","aes192","模式","上","大家","block","可能","的","处理","128","拆","对","第二","使用","补足","链接","16","平时","最好","轮数","8","192bit","ofb","块","）","问题","。"," ","二块","192","{","了","不同","处理过程","这些","加密器","电码","算器","成一","时候","128bit","少于","反馈","必须","近似","就是","nopadding","末尾","填充","解密","要求","iso126padding","输出","整段","最终","语言","有个","安全","但是","、","需要","数","复杂","2","一个个","}","密码",",","之间","注意","过程","生成","电码本","\\","只有","随机","中","进行","7","aes128","在","补全","把","分成","什么","a","密文","一股脑","有些","整数倍","不","个","采用","从","等于","chaining","其它","用","为","如果","尾端","支持","主体","c","1","明文","五种","feedback","最高","outputfeedback","256","典型","aes256","一股","第二块","成","缺少","方式","则","分组","算法","book","性能","加密","做","（","#","数量","铭文","aes","cipher","细节","d","提供","几种","6","不是","相同","三种","，","而是","某种","整数","e","electronic",":","cfb","同样","值","思想","时","(","也","？","码本","差别","理过","结果","相应","拆分","许多","codebook","任何","counter","加密算法","ctr","密钥","b","说","一起","是","长度",")","3","4","每个","加入","体现","这个","且","工作","实际","中有","cbc","并","独立","数倍","字符","计算","位","64bit","后","计算器","拼接","g","经过"],"title":"三个基本概念（密钥、填充、模式）","title_tokens":["（","基本","基本概念","、","）","密钥","概念","三个","模式","填充"]},{"location":"things/algorithm/#java","text":"注意：调用封装好的AES算法时，表面上使用的key并不是真正用于AES加解密的密钥，而是生成真正密钥的种子。填充明文时，如果明文的长度原本就是16字节的整数倍，除了Nopadding外，其它填充方式都会填充一组额外的16字节明文块。","text_tokens":["时","如果","：","好","明文","字节","就是","nopadding","填充","解密","种子","key","密钥","方式","都","算法","长度","上","除了","的","注意","生成","aes","使用","封装","表面","16","额外","不是","并","数倍","真正","，","而是","外","整数","一组","调用","会","。","用于","块","整数倍","加解密","原本","其它"],"title":"在java中的具体实现","title_tokens":["的","实现","具体","中","java","在"]},{"location":"things/algorithm/#aes_1","text":"一个字节由两个十六进制位表示，00~ff表示0~255,一个字节刚好也可表示0~255 AES加密不是一次把明文加密成密文，而是经过很多轮的加密 具体需要多少论？》 初始轮 (Initial Round) 1次 普通轮 (Rounds) n次 最终轮 (Final Round) 1次 除去初始轮，各种Key长度对应的轮数如下： AES128：10轮 AES192：12轮 AES256：14轮 不同阶段的Round有不同的处理步骤。 初始轮只有一个步骤： 加轮密钥（AddRoundKey） 普通轮有四个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 列混淆（MixColumns） 加轮密钥（AddRoundKey） 最终轮有三个步骤： 字节代替（SubBytes） 行移位（ShiftRows） 加轮密钥（AddRoundKey）","text_tokens":["次","一个","addroundkey","：","字节","10","initial","aes192","255","混淆","的","处理","14","一次","mixcolumns","n","轮数","有","）"," ","。","轮","不同","对应","步骤","由","移位","除去","最终","代替","十六","需要","~","很多","普通",",","只有","ff","shiftrows","aes128","把","列","密文","进制","行","如下","十六进制","阶段","1","明文","刚好","12","0","四个","aes256","成","》","各种","加密","（","aes","加轮","具体","多少","不是","表示","round","，","而是","三个","论","(","也","可","？","subbytes","key","两个","密钥","final","长度",")","rounds","00","位","初始","经过"],"title":"AES算法的底层原理","title_tokens":["的","aes","算法","原理","底层"]},{"location":"things/algorithm/#subbyte","text":"十六字节的明文块在第一个处理步骤中被排列成一个4x4的二位数组，字节替代就是把明文块的每一个字节都替换成另外一个字节 替代的依据是通过一个S盒(subtitution Box)的16x16大小二维常量数组。 例如明文块a[2,2]=5B 一个字节是两位十六进制位，那么输出值b[2,2]=S[5,11]","text_tokens":["[","一个","依据","(","十六进制","5","常量","字节","明文","就是","通过","]","盒","输出","第一","排列","替换","十六","b","例如","都","数组","是","换成","s",")","2","两位","16x16","列成","替代","的",",","每","另外","处理","被","那么","中","排列成","11","第一个","在","把","a","替换成","二位","，","大小","块"," ","4x4","subtitution","。","=","进制","box","5b","位","二维","值","步骤"],"title":"字节替代 subByte","title_tokens":["替代"," ","subbyte","字节"]},{"location":"things/algorithm/#shiftrows","text":"如图： 第一行不变 第二行循环左移一个字节 第三行循环左移两个字节 第四行循环左移三个字节","text_tokens":["左移","一个","第四行","：","一行","二行","字节","第一","如图","第一行","两个","第三","第四","不变","第三行","第二","第二行","三行","四行","循环"," ","三个"],"title":"行移位 shiftRows","title_tokens":["shiftrows","行"," ","移位"]},{"location":"things/algorithm/#mixcolumns","text":"输入数组的每一列要和一个明文修补矩阵(fix matrix)的二位常量数组做矩阵相乘，得到对应的输出列","text_tokens":["一个","(","常量","明文","修补","输出","一列","fix","数组",")","矩阵","matrix","要","做","的","每","和","得到","输入","相乘","列","二位","，"," ","对应"],"title":"列混淆MixColumns","title_tokens":["列","mixcolumns","混淆"]},{"location":"things/algorithm/#add-round-key","text":"128bit的密钥同样被排列成4x4矩阵 输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次就生成了输出值b[i,j] 加密每一轮用到的密钥是不同的 扩展密钥(KeyExpentions) AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。","text_tokens":["一个","字节","10","]","就","i","32","数组","的","处理","被","和","16","一次","）"," ","。","-","{","轮","了","*","不同","后续","对应","与","由","128bit","15","同于","而","输出","......","最终","排列","矩阵","2","用到","}",",","每","生成","存储","j","一轮","中","47","输入","a","原始","4x4","用于","k","源代码","[","用","160","为","来","1","keyexpentions","0","位置","一直","第","加密","元素","做","列成","（","aes","排列成","等同","，","+","同样","175","值","(","31","所有","到","直到","赋值","密钥","b","当中","是","都","长度",")","4","代码","完成","w","等同于","计算","异或","扩展","初始"],"title":"加 论密钥(add round key)","title_tokens":["round","(","add"," ","密钥","加",")","论","key"]},{"location":"things/algorithm/#_8","text":"所有工作模式的差别都体现在宏观上，即明文块与明文块之间的关联，AES加密器的内部处理流程都是相同的。 1. ECB模式(electronoc CodeBook Book) 最简单的工作模式,每一个明文块的加密完全独立，互不干涉。 优点:1.简单2.有利于并行计算 缺点：相同的明文块经过加密会变成相同的密文块，安全性较差 CBC (Cipher Block Chainning) 引入了初始向量的概念(Initialization Vector)。iv的作用有点像MD5的加盐，防止同样的明文块加密成同样的密文块。 CBC模式在每一个明文块加密前会让明文块和一个值做异或操作，IV作为初始化向量，只参与第一个明文块的异或，后续的每一个明文块和前一个明文块所加密出的密文块做异或，这样相同的明文块，加密出的密文块显然是不一样的。 优点：安全性更高 缺点：1.无法并行计算，性能上不如ECB2.引入初始化向量iv增加复杂度","text_tokens":["一个","：","简单","ecb","加盐","安全性","无法","模式","上","block","的","electronoc","处理","和","iv","较差","第一个","不如","作用","复杂度","块","。"," ","chainning","概念","更高","内部","了","作为","后续","与","加密器","一样","安全","防止","复杂","显然","2","优点","操作",",","每","之间","前会","互不","initialization","流程","初始化","只","在","缺点","干涉","密文","即","有利于","不","变成","关联","向量","md5","1","明文","宏观","第一","增加","成","有点像",".","book","有利","加密","性能","完全","做","所","参与","并行计算","aes","cipher","这样","相同","，","会",":","同样","有点","值","(","出","最","让","所有","互不干涉","差别","codebook","并行","都","是",")","前","体现","工作","vector","引入","cbc","独立","计算","异或","ecb2","利于","初始","经过"],"title":"不同工作模式在加密流程中有什么不同？","title_tokens":["什么","工作","？","模式","中有","流程","加密","不同","在"]},{"location":"things/algorithm/#md5","text":"可以从任意长度的明文字符串生成128位的哈希值","text_tokens":["字符","的","生成","任意","128","可以","明文","位","长度","值","从","哈希","字符串"],"title":"MD5","title_tokens":["md5"]},{"location":"things/algorithm/#_9","text":"1. 收集相关业务参数，在这里时金额和目标账户。 2. 按照规则把参数名和参数值拼接成一个字符串，同时把给定的密钥也拼接起来，之所以需要密钥，是因为攻击者可能也知道拼接规则。amout=1_acount=1234_key=abcd 3. 利用MD5算法，从原文生成hash值，MD5生成的哈希值是128的二进制，也就是32位的十六进制 4. 发送的时候除了把基本请求参数带上，把sign:ADE876ISHDFAKHDJ也带上 5.第三方支付平台如何验证请求的签名？三步 * 双方约定相同的字符串拼接规则，和相同的密钥 * 第三方平台接收到请求后，按照拼接规则拼接业务参数和密钥，利用MD5算法生成sign * 生成的sign和请求带过去的sign做对比，如果两个值相同则签名无误，两个值不同则信息做了篡改 密钥本身不直接传输，只参与sign的拼接，如果坏人既知道拼接规则又知道密钥，只能通过业务上的规则来限制，比如最大金额的限制","text_tokens":["一个","收集","5","验证","接收","32","只能","如何","sign","最大","上","业务","之所以","支付","可能","的","abcd","这里","128","相关","和","第三方","二进制"," ","。","了","*","不同","签名","带上","传输","约定","时候","就是","通过","给定","既","acount","amout","原文","十六","参数值","需要","2","字符串","生成","无误","目标","信息","对比","只","金额","在","把","=","进制","不","数值","从","十六进制","如果","来","md5","1","所以","哈希","成","攻击者","则",".","因为","算法","做","本身","参与","比如","平台","请求","名","相同","又","，",":","参数","带","值","时","也","到","？","_","利用","账户","key","按照","是因为","hash","三方","过去","两个","密钥","发送","第三","是","4","3","除了","篡改","基本","直接","起来","三步","坏人","限制","知道","字符","双方","攻击","同时","位","后","规则","拼接","1234","ade876ishdfakhdj"],"title":"验签过程","title_tokens":["验签","过程"]},{"location":"things/algorithm/#md5_1","text":"分为四步：处理原文，设置初始值，循环加工，拼接结果 1. 处理原文 首先，计算原文的长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448.填充方法就是第一位填充1，其余位填充0，填充完后，信息的长度就是512*N+448 之后用剩余的位置（512-448=64）记录原文的真正长度，把长度的二进制值补在最后这样处理后的信息长度就是512*（N+1） 设置初始值 MD5的哈希结果长度为128位，按照每32位一组共4组，4组是由四个初始向量值A,B,C,D经过不断演变得到，MD5的官方实践中A,B,C,D的初始值如下(十六进制)： A= 0x01234567 B= 0x89ABCDEF C= 0xFEDCBA98 D= 0x76543210 循环加工 最复杂的一步，下图代表了单次A,B,C,D演变的流程 图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。 假设处理后的原文长度是M 主循环次数 = M / 512 每个主循环中包含 512 / 32 * 4 = 64 次 子循环。 上面这张图所表达的就是单次子循环的流程。 1.绿色F 图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种： F(X, Y, Z) =(X&Y) | ((~X) & Z) G(X, Y, Z) =(X&Z) | (Y & (~Z)) H(X, Y, Z) =X^Y^Z I(X, Y, Z)=Y^(X|(~Z)) 在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。 2.红色“田”字 很简单，红色的田字代表相加的意思。 3.Mi Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。 4.Ki 一个常量，在64次子循环中，每一次用到的常量都是不同的。 5.黄色的<<<S 左移S位，S的值也是常量。 “流水线”的最后，让计算的结果和B相加，取代原先的B。新ABCD的产生可以归纳为： 新A = 原d 新B = b+((a+F(b,c,d)+Mj+Ki)<<<s) 新C = 原b 新D = 原c","text_tokens":["次","设置","一个","左移","：","5","简单","原先","可以","0x76543210","<","记录","就","i","32","最后","m","之一","m1","第二个","的","第四","处理","abcd","128","使用","对","第二","bit","黄色","和","剩余","16","一次","命名","第一个","n","代表","二进制","有","一共","/","）"," ","。","&","-","子","mi","不断","了","*","不同","上面","再","新","相加","由","0x89abcdef","单","就是","首先","填充","很","原","第一位","线性","完后","448","原文","、","十六","需要","第一步","份","复杂","向","~","实践","下面","2","ki","演变","^","田字","m0","用到",",","每","中","流程","信息","循环","进行","绿色","取代","水线","在","把","a","分成","旧","决定","0xfedcba98","分为","=","进制","整数倍","不","二个","等于","用","如下","为","十六进制","如果","组是","h","md5","c","常量","1","512","0","红色","四个","哈希","第一","mj","位置","四步",".","单次","一步","分组","z","共","所","”","（","第四个","y","流水线","字","d","流水","多少","这样","得到","使得","64","田","，","一组","整数","初始值","0x01234567","会","非线性","m16","三个","归纳","|","+","假设","值","交替","所用","值补","(","四种","也","之后","最","让","主","到","？","组","结果","张图","f","方法","按照","x","b","呢","图中","第三","都","是","表达","加工","长度",")","4","包含","3","量值","每个","s","等份","产生","次数","官方","下图","一等","第三个","次子","其余","数倍","函数","真正","求余","意思","一位","计算","位","后","“","m15","拼接","这","g","初始","经过"],"title":"MD5底层原理","title_tokens":["md5","原理","底层"]},{"location":"things/algorithm/#base64","text":"","text_tokens":[],"title":"Base64","title_tokens":["base64"]},{"location":"things/algorithm/#_10","text":"","text_tokens":[],"title":"排序","title_tokens":["排序"]},{"location":"things/algorithm/#_11","text":"","text_tokens":[],"title":"冒泡算法和优化","title_tokens":["优化","算法","和","冒泡"]},{"location":"things/cutline/","text":"分割线使用三个或以上 * ，也可以使用 - 和 _ ，下面仅以 - 作为示例 --- 效果","text_tokens":["以上","也","可以","_","分割线","分割","或","*","仅以","下面","效果","---","使用","和","割线","，","示例"," ","三个","-","作为"],"title":"Cutline","title_tokens":["cutline"]},{"location":"things/main/","text":"由于语法众多，因此将 大部分语法 汇总在下面表格里，便于一览。 但该表并未涵盖全部语法(如某些特殊符号) ，因此详情请翻看语法的具体章节。 符号 用途 # 标题 空行 段落 > 引用 [^sth] 脚注 !!! 注解 ??? 折叠注解 \\ 转义 * 列表 + 列表 - 列表 *[x] 任务列表 +[x] 任务列表 -[x] 任务列表 --- 分割线 :shortname: emoji ` 行内代码 ```语言 代码块,带高亮 TAB 代码块 #! 代码高亮 ::: 代码高亮 *sth* 斜体 _sth_ 斜体 **sth** 粗体 __sth__ 粗体 ***sth*** 粗斜体 ___sth___ 粗斜体 \\^sth\\^ 上标 \\~sth\\~ 下标 \\^\\^sth\\^\\^ 文字下划线 \\~\\~sth\\~\\~ 文字中横线 {++sth++} 文字下划线,绿色背景高亮 {--sth--} 文字中横线,红色背景高亮 {\\~\\~false\\~>true\\~\\~} 文字下划线接文字横线,绿接红背景高亮 {>>sth<<} 表示注解,灰色背景高亮 \\=\\=sth\\=\\= 黄色背景高亮 {\\=\\=sth\\=\\=} 黄色背景高亮 \\$sth$ 行内式数学公式 \\(sth)\\ 行内式数学公式 \\$\\$...$$ 区块式数学公式 \\begin{}...\\end{} 区块式数学公式 [text](url \"title\") 行内式链接 [text][index],文档最后[index]: url \"title\" 参考式链接 符合要求的URL 自动链接 ![alt](url \"title\") 行内式图片 ![alt][index],文档最后[index]: url \"title\" 参考式图片","text_tokens":["汇总","<","涵盖","]","斜体","大部分","众多","最后","符号","---","的","黄色","title","end","横线","下划","绿接","链接","符合要求","翻看","!","折叠","灰色","接","$","符合","因此","块"," ","。","特殊符号","-","红","{","tab","*","上标","空行","url","表格","要求","章节","语言","下标","划线","标题","详情","index","...","~","下面","^","}","引用","begin","高亮","行内",",","自动","该表","\\","割线","中","图片","用途","绿色","在","粗","文字","式","=","段落","++","数学","false","[","粗体","背景","便于","?","红色","分割线","部分","分割","\"","将","大部","任务","--","如","转义","并未","详情请","__","#","具体","sth","里","注解","表示","，",":","下划线","+","文档","(","emoji","公式","true","_","由于","`","带高亮","x","特殊",")","全部","___","代码","区块","语法","列表","shortname","数学公式",">","参考","某些","一览","alt","text","脚注","但"],"title":"Main","title_tokens":["main"]},{"location":"things/things/","text":"this is interesting things dadadada dididididi","text_tokens":["interesting","things","this","is"," ","dadadada","dididididi"],"title":"Things","title_tokens":["things"]},{"location":"things/things/#dadadada","text":"","text_tokens":[],"title":"dadadada","title_tokens":["dadadada"]},{"location":"things/things/#dididididi","text":"","text_tokens":[],"title":"dididididi","title_tokens":["dididididi"]}]}